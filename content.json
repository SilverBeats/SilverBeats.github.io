{"meta":{"title":"LearnForever","subtitle":"","description":"坚持学习每一天","author":"silverbeats","url":"blog.silverbeats.cn","root":"/"},"pages":[{"title":"categories","date":"2020-09-15T10:32:54.000Z","updated":"2020-09-15T11:38:48.370Z","comments":false,"path":"categories/index.html","permalink":"blog.silverbeats.cn/categories/index.html","excerpt":"","text":""},{"title":"schedule","date":"2020-09-15T10:47:30.000Z","updated":"2020-09-15T11:38:33.448Z","comments":false,"path":"schedule/index.html","permalink":"blog.silverbeats.cn/schedule/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-09-15T10:33:05.000Z","updated":"2020-09-15T11:38:04.782Z","comments":false,"path":"tags/index.html","permalink":"blog.silverbeats.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"课外书","slug":"课外书","date":"2020-10-24T11:19:20.000Z","updated":"2020-10-24T11:43:19.352Z","comments":true,"path":"课外书/","link":"","permalink":"blog.silverbeats.cn/%E8%AF%BE%E5%A4%96%E4%B9%A6/","excerpt":"","text":"1 语言相关 1.1 Java 3y教你学java（提取码：vzs2） Effective Java 原书第三版（提取码：4f4l ） 1.2 JavaScript 阮一峰 ES6 （提取码：kgp9 ） Javascript高级程序设计（提取码：ic9o） JavaScript设计模式—张容铭（提取码：i41t） [JavaScript设计模式—Ross Harmes（提取码：23uw） 编写可维护的JavaScript（提取码：asjn） 2 Web 图解HTTP（提取码：vybw） 3 版本控制 GitHub入门与实践 （提取码：yxcl） 4 服务器 Nginx开发从入门到精通 (淘宝团队出品) Nginx教程从入门到精通(PDF版本，运维生存时间出品) 5 设计模式 设计模式_可复用面向对象软件的基础 C/C++（提取码：6l3a） 6 分布式系统 走向分布式","categories":[{"name":"书籍","slug":"书籍","permalink":"blog.silverbeats.cn/categories/%E4%B9%A6%E7%B1%8D/"}],"tags":[{"name":"书籍","slug":"书籍","permalink":"blog.silverbeats.cn/tags/%E4%B9%A6%E7%B1%8D/"}],"author":"silverbeats"},{"title":"单例模式","slug":"单例模式","date":"2020-10-24T05:31:01.000Z","updated":"2020-10-24T06:44:05.529Z","comments":false,"path":"单例模式/","link":"","permalink":"blog.silverbeats.cn/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"推荐文章： 你知道吗？枚举单例模式是世界上最好的单例模式！！！ https://blog.csdn.net/fvdfsdafdsafs/article/details/88541909 1 饿汉式单例 构造器私有化 JVM保证线程安全 缺点： 不管是否使用，一上来就会加载对象，会浪费空间 反射可破坏单例 public class SingleTon01 &#123; // 构造器私有 private SingleTon01()&#123;&#125; // 类加载到内存后,就实例化一个单例,JVM保证线程安全 private static final SingleTon01 INSTANCE = new SingleTon01(); public static SingleTon01 getINSTANCE() &#123; return INSTANCE; &#125; &#125; 1.1 反射破坏单例 @Test public void testsingle01() throws Exception&#123; // 获取SingleTon01的Class属性 Class singleTon01Class = Class.forName(\"com.silverbeats.singleton.SingleTon01\"); // 通过正常方式获取instance1,instance2 SingleTon01 instance1 = SingleTon01.getINSTANCE(); SingleTon01 instance2 = SingleTon01.getINSTANCE(); // 获取该Class的无参构造器 Constructor declaredConstructor = singleTon01Class.getDeclaredConstructor(null); // 破坏构造器私有 declaredConstructor.setAccessible(true); // 通过反射创建instance3和instance4 SingleTon01 instance3 = (SingleTon01) declaredConstructor.newInstance(); SingleTon01 instance4 = (SingleTon01) declaredConstructor.newInstance(); // 输出instance1、instance2、instance3、instance4的地址 System.out.println(instance1); System.out.println(instance2); System.out.println(instance3); System.out.println(instance4); &#125; 输出的结果： com.silverbeats.singleton.SingleTon01@504bae78 com.silverbeats.singleton.SingleTon01@504bae78 com.silverbeats.singleton.SingleTon01@3b764bce com.silverbeats.singleton.SingleTon01@759ebb3d 可知，通过非反射的方式获取的instance1和instance2是同一个对象，符合单例。但是通过==反射==可以创建多个对象，破坏单例的效果，如instance3和instance4，都是不同于instance1的对象实例。 1.2 序列化破坏单例 倘若该单例实现了序列化接口java.io.Serializable，会被序列化反序列化破坏单例 @Test public void serializeSingle01() throws Exception &#123; SingleTon01 instance = SingleTon01.getINSTANCE(); // instance序列化输出流 FileOutputStream fileOutputStream = new FileOutputStream(\"/singleton01.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); // 序列化 objectOutputStream.writeObject(instance); // 关闭输出流 fileOutputStream.close(); objectOutputStream.close(); // 声明一个对象用来接收反序列化的结果 SingleTon01 instance2; // instance反序列化,输入流 FileInputStream fileIn = new FileInputStream(\"/singleton01.ser\"); ObjectInputStream in = new ObjectInputStream(fileIn); // 反序列化 instance2 = (SingleTon01)in.readObject(); // 关闭输入流 in.close(); fileIn.close(); // 判断是否是同一个对象 System.out.println(instance == instance2); // false &#125; 2 懒汉式：写法一 public class SingleTon02 &#123; private static SingleTon02 INSTANCE; private SingleTon02()&#123;&#125; public static SingleTon02 getINSTANCE() &#123; // 倘若没有创建,则创建对象 if(INSTANCE == null) &#123; /* 这里可以加线程睡眠,模拟效果 */ INSTANCE = new SingleTon02(); &#125; return INSTANCE; &#125; &#125; 3 懒汉式：写法二 加锁，方法锁 public static synchronized SingleTon02 getINSTANCE() &#123; if(INSTANCE == null) &#123; /* 这里可以加线程睡眠,模拟效果 */ INSTANCE = new SingleTon02(); &#125; return INSTANCE; &#125; 3 懒汉式：写法三 ==双重检查==单例。添加volatile保证创建对象是原子性，防止指令重排 创建对象的过程： 分配内存空间 执行构造方法，初始化对象 把对象指向这个空间 上面三个步骤，可能会出现指令重排现象,导致线程不安全 public class SingleTon02 &#123; // volatile保证创建对象是原子性 private static volatile SingleTon02 INSTANCE; private SingleTon02()&#123;&#125; public static SingleTon02 getINSTANCE() &#123; if(INSTANCE == null) &#123; synchronized (SingleTon02.class) &#123; /* 这里可以加线程睡眠,模拟效果 */ if(INSTANCE == null) &#123; INSTANCE = new SingleTon02(); &#125; &#125; &#125; return INSTANCE; &#125; &#125; 4 懒汉式：写法四 枚举类 public enum EnumClass &#123; INSTANCE; public EnumClass getInstance() &#123; return INSTANCE; &#125; &#125; **多线程测试：**通过,打印的都是同一个hashCode for (int i = 0; i &lt; 100; i++) &#123; new Thread(()->&#123; System.out.println(SingleTon03.getInstance().hashCode()); &#125;).start(); &#125; **反射测试：**结果报错，无法创建 Class singleTon01Class = Class.forName(\"com.silverbeats.singleton.SingleTon03\"); // 获取无参构造器 Constructor declaredConstructor = singleTon01Class.getDeclaredConstructor(null); // 破坏私有 declaredConstructor.setAccessible(true); // 创建对象 SingleTon01 instance = (SingleTon01) declaredConstructor.newInstance(); // 打印对象 System.out.println(instance.hashCode()); 序列化测试： @Test public void serializeEnumClass() throws Exception &#123; EnumClass instance = EnumClass.INSTANCE; // instance序列化输出流 FileOutputStream fileOutputStream = new FileOutputStream(\"/enumInstance.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); // 序列化 objectOutputStream.writeObject(instance); // 关闭输出流 fileOutputStream.close(); objectOutputStream.close(); // 声明一个对象用来接收反序列化的结果 EnumClass instance2; // instance反序列化,输入流 FileInputStream fileIn = new FileInputStream(\"/enumInstance.ser\"); ObjectInputStream in = new ObjectInputStream(fileIn); // 反序列化 instance2 = (EnumClass)in.readObject(); // 关闭输入流 in.close(); fileIn.close(); // 判断是否是同一个对象 System.out.println(instance == instance2); // true &#125; 4.1 防止反射的原因 反射newInstance方法中有这样一段代码： if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0) throw new IllegalArgumentException(\"Cannot reflectively create enum objects\"); 可知，枚举类型不可被创建，故可以防反射破坏枚举单例。枚举类型最终反编译源码中没有无参构造器，有一个接受string和int两个参数的有参构造器 4.2 防序列化的原因 Java的序列化专门对枚举的序列化做了规定，在序列化时，只是将枚举对象的name属性输出到结果中，在反序列化时通过java.lang.Enum的valueOf方法根据名字查找对象，而不是新建一个新的对象，所以防止了反序列化对单例的破坏。 可以查看java.io.ObjectInputStream#readObject验证。readObject判断到枚举类时，调用的了这个方法java.io.ObjectInputStream#readEnum jdk文档： 枚举常数的反序列化与普通可序列化或外部化对象不同。 枚举常数的序列化形式仅由其名称组成; 不传输常数的字段值。 要反序列化枚举常量，ObjectInputStream从流中读取常量名称; 然后通过使用枚举常量的基本类型和接收的常量名称作为参数调用静态方法Enum.valueOf(Class, String)获得反序列化常数。 像其他可序列化或可外部化的对象一样，枚举常量可以作为随后在序列化流中出现的反向引用的目标。 枚举常量被反序列化的过程无法自定义：在反序列化期间将忽略由枚举类型定义的任何特定于类的readObject，readObjectNoData和readResolve方法。 类似地，任何serialPersistentFields或serialVersionUID字段声明也被忽略 - 所有枚举类型都有一个固定的serialVersionUID为0L。 5 单例模式总结 单例写法 优点 缺点 饿汉式 JVM保证线程安全 ①浪费空间；②反射可以破坏单例③序列化可以破坏单例 懒汉式：写法一 需要的时候创建，避免空间的浪费 ①线程不安全；②反射可破坏单例③序列化可以破坏单例 懒汉式：写法二 ①需要的时候创建，避免空间的浪费②线程安全 ①因为加锁，影响效率；②反射可破坏单例③序列化可以破坏单例 懒汉式：写法三 ①需要的时候创建，避免空间的浪费②线程安全 ①比上面的写法效率会高一些；②反射破坏单例③序列化可以破坏单例 懒汉式：写法四 ①需要的时候创建，避免空间的浪费②线程安全③没有锁，效率高④防反射、防序列化","categories":[{"name":"java","slug":"java","permalink":"blog.silverbeats.cn/categories/java/"},{"name":"设计模式","slug":"java/设计模式","permalink":"blog.silverbeats.cn/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"blog.silverbeats.cn/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"blog.silverbeats.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"silverbeats"},{"title":"GOF23种设计模式","slug":"GOF23种设计模式","date":"2020-10-23T14:07:56.000Z","updated":"2020-10-24T06:44:05.524Z","comments":false,"path":"GOF23种设计模式/","link":"","permalink":"blog.silverbeats.cn/GOF23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 概述 设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解 1.1 优点 可以提高思维能力、编程能力和设计能力 程序设计更加标准化、编码编制更加工程化，使软件开发效率提高，缩短开发周期 使代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强 1.2 基本要素 模式名称 问题 解决方案 效果 1.3 分类 1.3.1 创建型模式 单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式 1.3.2 构建型模式 适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式 1.3.3 行为模式 模板方法模式，命令模式，迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式 2 面向对象OOP七大原则 开闭原则：对扩展开放，对修改关闭 里氏替换原则：继承必须确保超类所拥有的性质在之类中仍然成立。不要破坏继承关系。 依赖倒置原则：要面向接口编程，不要面向实现编程 单一职责原则：控制类的粒度大小、将对象解耦、提高其内聚性。要求每个类的职责单一。 接口隔离原则：要为各类建立它们需要的专用接口。保证接口的精简和单一。 迪米特法则：只与你的直接朋友交谈，不跟陌生人说话。降低程序之间的耦合度 合成复用原则：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系实现 3 创建型模式 单例模式 Post not found: 工厂模式 工厂模式 Post not found: 抽象工厂模式 抽象工厂模式 Post not found: 建造者模式 建造者模式 Post not found: 原型模式 原型模式","categories":[{"name":"java","slug":"java","permalink":"blog.silverbeats.cn/categories/java/"},{"name":"设计模式","slug":"java/设计模式","permalink":"blog.silverbeats.cn/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"blog.silverbeats.cn/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"blog.silverbeats.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"silverbeats"},{"title":"数据结构题目","slug":"数据结构题目","date":"2020-10-21T01:56:26.000Z","updated":"2020-10-23T08:47:54.068Z","comments":false,"path":"数据结构题目/","link":"","permalink":"blog.silverbeats.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE/","excerpt":"","text":"1 线性表 public class SingleLinearNode &#123; private int elemData; private SingleLinearNode next; // 以及get、set方法 &#125; 1.1 单链表原地逆置 单链表原地逆置（假定需要逆置的单链表不含头结点） public SingleLinearNode reverseLinear(SingleLinearNode linear) &#123; SingleLinearNode head = new SingleLinearNode(), temp, lp; lp = linear; while (lp != null) &#123; temp = lp.getNext(); lp.setNext(head.getNext()); head.setNext(lp); lp = temp; &#125; return head.getNext(); &#125; 1.2 将两个有序的单链表合并，合并后结果仍然有序 将两个有序的单链表合并，合并后结果仍然有序（假定两个链表不含头结点并非减） public SingleLinearNode combineTwoLinear(SingleLinearNode linear1, SingleLinearNode linear2) &#123; SingleLinearNode p1 = linear1, p2 = linear2; SingleLinearNode head = new SingleLinearNode(), hp = head, temp; while (p1 != null &amp;&amp; p2 != null) &#123; if (p1.getElemData() &lt; p2.getElemData()) &#123; hp.setNext(p1); hp = p1; p1 = p1.getNext(); &#125; else &#123; hp.setNext(p2); hp = p2; p2 = p2.getNext(); &#125; hp.setNext(null); &#125; // 如果某个链表还有节点 if (p1 != null) hp.setNext(p1); if (p2 != null) hp.setNext(p2); return head.getNext(); &#125; 1.3 现有两个递增单链表，要求合并后递减 现有两个递增单链表，要求合并后递减，含关键字的节点需要利用原有的 public SingleLinearNode MergeDiminishing(SingleLinearNode linear1, SingleLinearNode linear2) &#123; return reverseLinear(combineTwoLinear(linear1, linear2)); &#125; 1.4 一个数组正数负数混合，以最快的速度将所有的负数挪到整个数组的最前面 一个数组，其中有正数和负数，以最快的速度将所有的负数挪到整个数组的最前面 public void negativeFrontPositive(int[] arr) &#123; if (arr.length &lt;= 1) return; // left表示负数存储的下标,right表示正数的位置 int left = 0, right = arr.length - 1; while (left &lt; right) &#123; while (arr[left] &lt; 0) ++left; while (arr[right] > 0) --right; // 经过两个while,left的位置是正数,right的位置是负数,进行交换 swap(arr, left, right); ++left; --right; &#125; &#125; 1.5 一个递增有序数组，以最快的方式找到某个值，找到则将该值与后继进行交换，找不到则插入 一个递增有序数组，以最快的方式找到某个值，找到则将该值与后继进行交换，找不到则插入 public int[] findSwapOrInsert(int[] arr, int target) &#123; if (arr.length == 0) return new int[]&#123;target&#125;; // 二分查找 int left = 0, right = arr.length - 1, mid; while (left &lt; right) &#123; mid = (left + right) >> 1; if (arr[mid] > target) right = mid - 1; else if (arr[mid] &lt; target) left = mid + 1; else &#123; // 如果找到了 swap(arr, mid, mid + 1); return arr; &#125; &#125; // 如果没找到 int i = Math.max(right, 0); for (; i &lt; arr.length; i++) &#123; if (target &lt; arr[i]) break; &#125; // 此时i就是插入位置 int[] newArr = new int[arr.length + 1]; System.arraycopy(arr, 0, newArr, 0, i); newArr[i] = target; System.arraycopy(arr, i, newArr, i + 1, arr.length - i); return newArr; &#125; 1.6 判断某单链表前n个字符是否是中心对称 判断某单链表前n个字符是否是中心对称 public boolean isCenterSymmetry(SingleLinearNode linear, int len) &#123; // 先统计linear有多少个节点 int count = 0; SingleLinearNode lp = linear; while (lp != null) &#123; ++count; lp = lp.getNext(); &#125; // 可能会出现链表4个节点,让判断前5个乃至更多是否中心对称 int realN = Math.min(len, count); // 创建一个数组用来存储linear前realN个关键字 int[] arr = new int[realN]; for (int i = 0; i &lt; realN; i++) &#123; arr[i] = linear.getElemData(); linear = linear.getNext(); &#125; // 定义左右指针 int left = 0, right = realN - 1; // 判断是否中心对称 while (left &lt; right) &#123; if (arr[left++] != arr[right--]) return false; &#125; return true; &#125; 1.7 删除不带头结点的单链表，begin位置后的len个节点 删除不带头结点的单链表，begin位置后的len个节点 begin = 0：从单链表第一个节点开始删 begin = 1：从单链表第二个位置开始删除，第一个节点保留 …… 起始位置超出链表长度：报错 能删除的节点数量不足len个：有多少删多少 public SingleLinearNode deleteNodeFrom(SingleLinearNode linear, int begin, int len) &#123; if (begin &lt; 0) throw new RuntimeException(\"deleteNodeFrom参数错误,begin需要≥0\"); if (len &lt; 0) throw new RuntimeException(\"deleteNodeFrom参数错误,len需要≥0\"); if (linear == null) return null; // 令传递过来的单链表配上一个头结点 SingleLinearNode head = new SingleLinearNode(), hp = head; head.setNext(linear); int i = 0; while(i++ &lt; begin &amp;&amp; hp != null) hp = hp.getNext(); if(hp == null) throw new RuntimeException(\"起始位置超出链表长度\"); // 此时,从hp后面的节点开始计数len个要删除 SingleLinearNode temp = hp; for(i = 1; i &lt;= len &amp;&amp; temp != null; i++) temp = temp.getNext(); // 此时temp指向被删除的最后一个节点 if(temp != null) hp.setNext(temp.getNext()); // 说明能删的不够len个 else hp.setNext(null); return head.getNext(); &#125; 1.8 定位到单链表中某个位置 如果需要定位的位置超过链表长度：返回null public SingleLinearNode getPos(SingleLinearNode linear, int pos) &#123; if (pos &lt; 1) throw new RuntimeException(\"getPos参数错误,position需要≥1\"); if(linear == null) return null; SingleLinearNode lp = linear; for (int i = 2; i &lt;= pos &amp;&amp; lp != null; i++) lp = lp.getNext(); return lp; &#125; 1.9 删除linear1自begin后面的len个节点,并将linear1剩余的节点插入到linear2第insertPos位置之前 删除linear1自begin后面的len个节点,并将linear1剩余的节点插入到linear2第insertPos位置之前 public SingleLinearNode q7(SingleLinearNode linear1, int begin, int len, SingleLinearNode linear2, int insertPos) &#123; if(insertPos &lt; 0) throw new RuntimeException(\"linear2插入位置需要≥0\"); // 先对linear1进行处理,进行删除 linear1 = deleteNodeFrom(linear1, begin, len); // 判断经过删除后,linear1还有没有可以插入的节点 if(linear1 != null) &#123; // p定位到linear1的最后一个节点 SingleLinearNode p = linear1; while(p.getNext() != null) p = p.getNext(); if(insertPos > 0) &#123; // 找到linear的第j个位置的前一个位置 SingleLinearNode prePos = getPos(linear2, insertPos - 1); if(prePos != null) &#123; p.setNext(prePos.getNext()); prePos.setNext(linear1); &#125; else &#123; // 如果定位失败,则将linear1剩下的节点插入到linear2的最后 // 此时p指向linear2的最后一个节点 p = linear2; while(p.getNext() != null) p = p.getNext(); // linear1剩余节点插入linear2最后 p.setNext(linear1); &#125; &#125; else &#123; // 若j=0 p.setNext(linear2); return linear1; &#125; &#125; return linear2; &#125; 2 栈和队列 2.1 给定入栈序列和某个出栈序列，判断该出栈序列是否合法 给定入栈序列和某个出栈序列，判断该出栈序列是否合法 /** * @param inStackSeq: 入栈顺序 * @param outStackSeq: 出栈顺序 * @return: boolean */ public static boolean isRightOutStackSeq(String inStackSeq, String outStackSeq) &#123; if(inStackSeq.length() != outStackSeq.length()) return false; // 入栈序列和出栈序列转为数组,方便处理 char[] inStackSeqChars = inStackSeq.toCharArray(); char[] outStackSeqChars = outStackSeq.toCharArray(); // 声明一个栈 SequenceStack&lt;Character> stack = new SequenceStack&lt;>(inStackSeqChars.length); // 声明一个指针i,指向出栈序列,这里不借助队列实现 // 指针j指向入栈序列 int i = 0, j = 0; while(j &lt; inStackSeqChars.length) &#123; stack.push(inStackSeqChars[j++]); // 每次入栈和出栈顺序队列第一个比较,如果相等 while(!stack.isEmpty() &amp;&amp; stack.peek() == outStackSeqChars[i]) &#123; i++; stack.pop(); &#125; &#125; return i >= outStackSeqChars.length &amp;&amp; stack.isEmpty(); &#125; 2.2 前缀、中缀、后缀表达式 /** * @param char1: 第一个运算符 * @param char2: 第二个运算符 * @return: int * @description: 返回0,优先级一致;正数,前面优先级高;负数,前面优先级低 */ private int cmp(char char1, char char2) &#123; Map&lt;Character, Integer> map = new HashMap&lt;>(); char[] chars = &#123;'/', '*', '%'&#125;; for (char item : chars) map.put(item, 3); chars = new char[]&#123;'+', '-'&#125;; for (char item : chars) map.put(item, 4); chars = new char[]&#123;'^'&#125;; for (char item : chars) map.put(item, 9); return map.get(char2) - map.get(char1); &#125; /** * @param op: 操作符 * @return: boolean * @description: 判断是否是操作符 */ private boolean isOp(char op) &#123; return op == '*' || op == '+' || op == '/' || op == '-' || op == '%' || op == '^'; &#125; 2.2.1 中缀——&gt;前缀表达式 遵循右优先，倘若一个中缀表达式右边的运算符能够先运算，该右边的运算符优先级高 规则： 从右向左遍历 操作数前插 操作符，若栈空入栈；不空，则将栈中大于当前运算符优先级出栈进行前插,或遇到右括号停止。之后再将当前运算符压栈 右括号入栈，遇到左括号不断弹出操作符前插，直到遇到右括号 /** * @param nifixExpression : 中缀表达式 * @return: String * @description: 中缀转前缀 */ public String nifixToPrefix(String[] nifixExpression) &#123; // 存储表达式拼接的结果 StringBuilder sb = new StringBuilder(); // 存储界限符和运算符的栈 Stack&lt;Character> stack = new Stack&lt;>(); char top; for (int i = nifixExpression.length - 1; i >= 0; i--) &#123; String temp = nifixExpression[i]; // 如果长度是1,可能是：1位数字,界限符,操作符 if(temp.length() == 1) &#123; char item = temp.charAt(0); // 如果是操作符 if(isOp(item)) &#123; if(stack.isEmpty()) stack.push(item); else &#123; while(!stack.isEmpty() &amp;&amp; (top = stack.peek())!=')' &amp;&amp; cmp(item, top) &lt; 0) sb.insert(0, top); stack.push(item); &#125; &#125; else if(item == ')' || item == '(') &#123; // 如果是左括号,不断出栈直到遇到右括号 if(item == '(') &#123; while(!stack.isEmpty() &amp;&amp; (top = stack.pop())!=')') sb.insert(0, top); &#125; else stack.push(')'); &#125; else &#123; // 如果是1位数字 sb.insert(0, item); &#125; &#125; else &#123; // 如果长度不为1,说明是多位的数字,进行前插 sb.insert(0, temp); &#125; &#125; while(!stack.isEmpty()) sb.insert(0, stack.pop()); return sb.toString(); &#125; 2.2.2 前缀——&gt;中缀表达式 该前缀表达式的运算符从右向左依次生效，故前缀转中缀规则： 从右向左遍历 将操作数压栈 遇到操作符，则将栈中最上面的两个元素弹出比如A和B，进行拼接。最后将拼接结果压栈 整个数组遍历结束后，栈中就是中缀结果 /** * @param prefixExpression: 前缀表达式 * @return: String * @description: 后缀转中缀 */ public String PrefixToNifix(String[] prefixExpression) &#123; if (prefixExpression.length == 0) return null; // 栈 Stack&lt;String> stack = new Stack&lt;>(); String top1, top2; for (int i = prefixExpression.length - 1; i >= 0; i--) &#123; String item = prefixExpression[i]; if (item.length() == 1 &amp;&amp; isOp(item.charAt(0))) &#123; // 如果是操作符,则取出栈中最上面两个元素进行合并 top1 = stack.pop(); top2 = stack.pop(); // 合并后重新压栈 stack.push('(' + top1 + item + top2 + ')'); &#125; else &#123; // 如果是操作数直接压栈 stack.push(item + \"\"); &#125; &#125; // 此时栈顶元素就是中缀表达式 String res = stack.pop(); // 处理多余的括号 return res.substring(1, res.length() - 1); &#125; 2.2.3 中缀——&gt;后缀表达式 遵循左优先，倘若一个中缀表达式左边的运算符能够先运算，该左边的运算符可以运算 规则： 遇到操作数。直接加入后缀表达式 遇到界限符。比如()[]{}，遇到左半部分入栈，遇到右半部分依次弹出栈内运算符并加入后缀表达式，直到弹出对应的左半部分界限符 遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式。若遇到左半部分界限符或者栈空，则停止。之后再把当前运算符入栈。 将栈中剩余元素弹出加入表达式 /** * @param nifixExpression : 中缀表达式 * @return: String * @description: 中缀转后缀 */ public String nifixToPostfix(String[] nifixExpression) &#123; StringBuilder sb = new StringBuilder(); // 存储界限符和运算符的栈 Stack&lt;Character> stack = new Stack&lt;>(); char top, item; for (String s : nifixExpression) &#123; // 每个s判断长度,如果是1,则可能为：一位的数字,操作符或者界限符 if (s.length() == 1) &#123; item = s.charAt(0); if (isOp(item)) &#123; if(stack.isEmpty()) stack.push(item); else &#123; // 如果遇到运算符,将优先级高于或等于item的运算符出栈加入表达式,直到栈空或遇到左半部分括号 while(!stack.isEmpty() &amp;&amp; (top = stack.peek())!= '(' &amp;&amp; cmp(item, top) &lt;= 0) sb.append(stack.pop()); stack.push(item); &#125; &#125; else if (item == ')' || item == '(') &#123; // 如果是界限符的右半部分 if (item == ')') &#123; // 不断出栈加入表达式中,直到遇到右半部分的括号 while (!stack.isEmpty() &amp;&amp; (top = stack.pop()) != '(') sb.append(top); &#125; else stack.push(item); &#125; else &#123; sb.append(s); &#125; &#125; else &#123; // 长度大于1说明一定是多位数字操作数 sb.append(s); &#125; &#125; while(!stack.isEmpty()) sb.append(stack.pop()); return sb.toString(); &#125; 2.2.4 后缀——&gt;中缀表达式 该后缀表达式的运算符从左向右依次生效，故后缀转中缀规则： 从左向右遍历 将操作数压栈 遇到操作符，则将栈中最上面的两个元素弹出比如A和B，进行拼接。需要注意拼接时，先弹出来的要放到操作符的后面，比如B*A。最后将拼接结果压栈 整个数组遍历结束后，栈中就是中缀结果 /** * @param postfixExpression: 后缀表达式 * @return: String * @description: 后缀转中缀 */ public String PostfixToNifix(String[] postfixExpression) &#123; if(postfixExpression.length == 0) return null; Stack&lt;String> stack = new Stack&lt;>(); String top1, top2; for (String item : postfixExpression) &#123; if (item.length() == 1 &amp;&amp; isOp(item.charAt(0))) &#123; // 如果是操作符,则取出栈中最上面两个元素进行合并 top1 = stack.pop(); top2 = stack.pop(); // 合并后重新压栈 stack.push('(' + top2 + item + top1 + ')'); &#125; else &#123; // 如果是操作数直接压栈 stack.push(item + \"\"); &#125; &#125; // 此时栈顶元素就是中缀表达式 String res = stack.pop(); // 处理多余的括号 return res.substring(1, res.length() - 1); &#125; 3 树 @Data @AllArgsConstructor @NoArgsConstructor public class TreeNode &#123; private int elem; private TreeNode lChild; private TreeNode rChild; &#125; 3.1 遍历 递归 3.1.1 先序遍历（递归） /** * @param root: 根节点 * @return: void * @description: 先序遍历 */ public void preOrder(TreeNode root) &#123; if (root != null) &#123; System.out.println(root.getElem()); preOrder(root.getlChild()); preOrder(root.getrChild()); &#125; &#125; 3.1.2 中序遍历（递归） /** * @param root: 根节点 * @return: void * @description: 中序遍历 */ public void inOrder(TreeNode root) &#123; if (root != null) &#123; preOrder(root.getlChild()); System.out.println(root.getElem()); preOrder(root.getrChild()); &#125; &#125; 3.1.3 后序遍历（递归） /** * @param root: 根节点 * @return: void * @description: 后序遍历 */ public void postOrder(TreeNode root) &#123; if (root != null) &#123; postOrder(root.getlChild()); postOrder(root.getrChild()); System.out.println(root.getElem()); &#125; &#125; 3.2 遍历 非递归 3.2.1 先序遍历（非递归） /** * @param root: 根节点 * @return: void * @description: 先序遍历,非递归 */ public void preOrderNonRecursion(TreeNode root) &#123; /** * 规则： * 1. 先将根节点入栈 * 2. 栈不为空, 出栈, 访问, 将出栈元素的右孩子、左孩子入栈 * 3. 循环第二步 */ if (root == null) return; StringBuilder res = new StringBuilder(); // 存储访问结果 TreeNode p = root; // 指针 Stack&lt;TreeNode> stack = new Stack&lt;>(); // 栈 stack.push(p); // 根节点入栈 while (!stack.isEmpty()) &#123; // 元素出栈 p = stack.pop(); // 访问出栈元素 res.append(p.getElem()); // 右孩子存在,入栈 if (p.getrChild() != null) stack.push(p.getrChild()); // 左孩子存在,入栈 if (p.getlChild() != null) stack.push(p.getlChild()); &#125; System.out.println(res.toString()); &#125; 3.2.2 中序遍历（非递归） /** * @param root: 根节点 * @return: void * @description: 中序遍历,非递归 */ public void inOrderNonRecursion(TreeNode root) &#123; /** * 规则： * 1. 先将根节点入栈 * 2. 如果该节点有左孩子,循环将所有左孩子入栈 * 3. 出栈,访问,如果出栈元素有右孩子,压栈 */ if (root == null) return; StringBuilder res = new StringBuilder(); // 存储访问结果 TreeNode p = root; // 指针 Stack&lt;TreeNode> stack = new Stack&lt;>(); // 栈 while (!stack.isEmpty() || p != null) &#123; // 将节点的所有左孩子入栈 while (p != null) &#123; stack.push(p); p = p.getlChild(); &#125; if (!stack.isEmpty()) &#123; // 出栈, 访问, 若有右孩子, 则入栈 p = stack.pop(); res.append(p.getElem()); p = p.getrChild(); &#125; &#125; System.out.println(res.toString()); &#125; 3.2.3 后序遍历（非递归|双栈） /** * @param root: 根节点 * @return: void * @description: 后序遍历,非递归,双栈 */ public void postOrderNonRecursion(TreeNode root) &#123; /** * 规则： * 1. 先按照根-右-左的顺序入栈 * 2.等所有节点入栈结束后, 一个个出栈 */ if (root == null) return; StringBuilder res = new StringBuilder(); // 存储访问结果 TreeNode p = root; // 指针 Stack&lt;TreeNode> stack1 = new Stack&lt;>(); // 栈 Stack&lt;TreeNode> stack2 = new Stack&lt;>(); // 栈 stack1.push(p); while (!stack1.isEmpty()) &#123; // 元素出栈 p = stack1.pop(); // 访问出栈元素 stack2.push(p); // 左孩子存在,入栈 if (p.getlChild() != null) stack1.push(p.getlChild()); // 右孩子存在,入栈 if (p.getrChild() != null) stack1.push(p.getrChild()); &#125; while(!stack2.isEmpty()) &#123; p = stack2.pop(); // 访问出栈元素 res.append(p.getElem()); &#125; System.out.println(res.toString()); &#125; 3.2.4 后序遍历（非递归|单栈） class MyEntry&lt;K, V> implements Map.Entry&lt;K,V> &#123; private final K key; private V value; MyEntry(K key, V value) &#123; this.key = key; this.value = value; &#125; @Override public K getKey() &#123; return key; &#125; @Override public V getValue() &#123; return value; &#125; @Override public V setValue(V value) &#123; V old = this.value; this.value = value; return old; &#125; &#125; 实现Map.Entry接口，重写方法 stack中存储的是一个键值对，key是树的节点，value是该节点的右孩子是否被访问，是boolean类型 /** * @param root: 根节点 * @return: void * @description: 后序遍历,非递归,一个栈 */ public void postOrderNonRecursion(TreeNode root) &#123; if (root == null) return; StringBuilder res = new StringBuilder(); // 存储访问结果 TreeNode bt = root; // 指针 Stack&lt;MyEntry&lt;TreeNode, Boolean>> stack = new Stack&lt;>(); MyEntry&lt;TreeNode, Boolean> stackNode; while(bt != null || !stack.isEmpty()) &#123; // 将该bt指向的节点以及所有的左孩子入栈 while(bt != null) &#123; // false表示该节点的右孩子没有被访问过 stackNode = new MyEntry&lt;>(bt, false); stack.push(stackNode); bt = bt.getlChild(); &#125; // 栈不空,并且栈顶元素的右孩子被访问过 while(!stack.isEmpty() &amp;&amp; stack.peek().getValue()) // 出栈,加入遍历结果中 res.append(stack.pop().getKey().getElem()); if(!stack.isEmpty()) &#123; // 令栈顶的右孩子被访问 stack.peek().setValue(true); // bt指向栈顶节点的右孩子 bt = stack.peek().getKey().getrChild(); &#125; &#125; System.out.println(res.toString()); &#125; 3.2.5 层次遍历 /** * @param root: 根节点 * @return: void * @description: 层次遍历 */ public void levelTraversal(TreeNode root) &#123; if(root == null) return; // 记录遍历结果 StringBuilder sb = new StringBuilder(); // 队列 Queue&lt;TreeNode> queue = new LinkedBlockingQueue&lt;>(); TreeNode node; queue.add(root); while(!queue.isEmpty()) &#123; node = queue.poll(); sb.append(node.getElem()); if(node.getlChild() != null) queue.add(node.getlChild()); if(node.getrChild() != null) queue.add(node.getrChild()); &#125; System.out.println(sb.toString()); &#125; 3.3 获取树的高度 获取树的高度 /** * @param root: 根节点 * @return: void * @description: 获取树的高度/深度 */ public void getTreeHeight(TreeNode root) &#123; if(root == null) return 0; // 获取左子树高度 int leftChildHeight = getTreeHeight(root.getlChild()); // 获取右子树高度 int rightChildHeight = getTreeHeight(root.getrChild()); return Math.max(leftChildHeight, rightChildHeight) + 1; &#125; 3.4 判断该树是否是平衡二叉树 判断该树是否是平衡二叉树 /** * @param root: 根节点 * @return: void * @description: 判断是否是AVL树 */ public boolean isAVL(TreeNode root) &#123; // 如果是空树 if(root == null) return true; // 获取左子树高度 int leftChildHeight = getTreeHeight(root.getlChild()); // 获取右子树高度 int rightChildHeight = getTreeHeight(root.getrChild()); return Math.abs(leftChildHeight - rightChildHeight) &lt;= 1; &#125; 3.5 给定一个数组建树 给定一个数组建树。利用层次遍历 /** * @param arr: 数组 * @return: TreeNode * @description: 根据数组创建树 */ public TreeNode createTreeByArray(int[] arr) &#123; if(arr.length == 0) return null; // 建立根节点 TreeNode root = new TreeNode(); root.setElem(arr[0]); // 创建队列 Queue&lt;TreeNode> queue = new LinkedBlockingQueue&lt;>(); TreeNode node, temp; // i用来指向数组元素的位置 int i = 1; // 根节点入队列 queue.add(root); while(!queue.isEmpty() &amp;&amp; i &lt; arr.length) &#123; // 出队列一个节点 node = queue.poll(); // 新建一个节点,将出栈节点的左指针指向该节点,新建的节点入栈 temp = new TreeNode(); temp.setElem(arr[i++]); node.setlChild(temp); queue.add(temp); // 如果数组还有元素,新建一个节点,将出栈节点的右指针指向该节点,新建的节点入栈 if(i &lt; arr.length) &#123; temp = new TreeNode(); temp.setElem(arr[i++]); node.setrChild(temp); queue.add(temp); &#125; &#125; queue.clear(); return root; &#125; 3.6 判断一颗树是否是完全二叉树 判断一颗树是否是完全二叉树 原理：若节点无左子树，则不应该有右子树 /** * @param root: 根节点 * @return: void * @description: 判断是否是FBT树 */ public boolean isFBT(TreeNode root) &#123; public boolean isFBT(TreeNode root) &#123; // 如果是空树 if (root == null) return true; // 声明一个队列,对树进行层次遍历 Queue&lt;TreeNode> queue = new LinkedBlockingQueue&lt;>(); // 当第一次出现null时,tag会置位true boolean tag = false; TreeNode node; // 根节点入队列 queue.add(root); while (!queue.isEmpty()) &#123; // 出队列 node = queue.poll(); // 如果有左孩子并且还没有出现第一个null if (!tag &amp;&amp; node.getlChild() != null) queue.add(node.getlChild()); else if (node.getlChild() != null) return false; else tag = true; // 如果有右孩子并且还没有出现第一个null if (!tag &amp;&amp; node.getrChild() != null) queue.add(node.getrChild()); else if (node.getrChild() != null) return false; else tag = true; &#125; return true; &#125; &#125; 3.7 给定一棵树的根节点和某个值,得到该值对应的所有祖先节点 给定一棵树的根节点和某个值,得到该值对应的所有祖先节点 利用单栈的后序遍历 /** * @param root: 树的根节点 * @param x: 被查找的值 * @return: TreeNode * @description: 根据数组创建树 */ public String getParents(TreeNode root, int x) &#123; // 存储该node节点的所有祖先 StringBuilder sb = new StringBuilder(); // 栈 Stack&lt;MyEntry&lt;TreeNode, Boolean>> stack = new Stack&lt;>(); TreeNode bt = root; while(bt != null || !stack.isEmpty()) &#123; // 如果bt有左孩子,并且bt的值不为x,则沿左分支向下入栈 while(bt != null &amp;&amp; bt.getElem() != x) &#123; stack.push(new MyEntry&lt;>(bt, false)); bt = bt.getlChild(); &#125; // bt指针一定不空,并且指向的节点要么是某个节点的左分支最后一个,要么该节点的值就位x if(bt != null &amp;&amp; bt.getElem() == x) &#123; while(!stack.isEmpty()) sb.insert(0,stack.pop().getKey().getElem()); return sb.toString(); &#125; while(!stack.isEmpty() &amp;&amp; stack.peek().getValue()) stack.pop(); if(!stack.isEmpty()) &#123; stack.peek().setValue(true); bt = stack.peek().getKey().getrChild(); &#125; &#125; return null; &#125; 3.8 统计某二叉树度1节点的数量 统计某二叉树度1节点的数量 /** * @param root: 树的根节点 * @param degree: 度 * @return: int * @description: 统计数中度为degree的节点数量 */ public int treeCountDegree(TreeNode root, int degree) &#123; int count = 0; LinkedBlockingQueue&lt;TreeNode> queue = new LinkedBlockingQueue&lt;>(); TreeNode bt; queue.add(root); // 通过层次遍历实现统计 while(!queue.isEmpty()) &#123; bt = queue.poll(); int temp = 0; if(bt.getlChild() != null)&#123; temp++; queue.add(bt.getlChild()); &#125; if(bt.getrChild() != null) &#123; temp++; queue.add(bt.getrChild()); &#125; if(temp == degree) count++; &#125; return count; &#125; 3.9 交换一个树所有节点的左右之树 交换一个树所有节点的左右之树 递归版本 /** * @param root: 根节点 * @return: void * @description: 交换树的左右子树, 递归 */ public void changeLeftAndRightChild(TreeNode root) &#123; if(root != null) &#123; // 交换左右子树 TreeNode temp = root.getlChild(); root.setlChild(root.getrChild()); root.setrChild(temp); // 递归修改左子树 changeLeftAndRightChild(root.getlChild()); // 递归修改左子树 changeLeftAndRightChild(root.getrChild()); &#125; &#125; 非递归版本 /** * @param root: 根节点 * @return: void * @description: 交换树的左右子树, 非递归 */ public void changeLeftAndRightChildNonRecursion(TreeNode root) &#123; if(root == null) return; // 利用层次遍历来完成 LinkedBlockingQueue&lt;TreeNode> queue = new LinkedBlockingQueue&lt;>(); TreeNode temp,bt; queue.add(root); while(!queue.isEmpty()) &#123; bt = queue.poll(); // 交换bt的左右子树 temp = bt.getlChild(); bt.setlChild(bt.getrChild()); bt.setrChild(temp); if(bt.getlChild() != null) queue.add(bt.getlChild()); if(bt.getrChild() != null) queue.add(bt.getrChild()); &#125; &#125; 3.10 已知先序和中序构建二叉树 已知先序和中序构建二叉树 3.11 已知后序和中序构建二叉树 已知先序和中序构建二叉树 3.12 给定一个整数数组，构建二叉排序树 给定一个数组，构建二叉排序树 3.13 将一颗二叉树调整为平衡二叉树 4 查找 5 排序 排序","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"blog.silverbeats.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法设计题目","slug":"算法设计题目","permalink":"blog.silverbeats.cn/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE/"}],"author":"silverbeats"},{"title":"Mybatis","slug":"Mybatis","date":"2020-10-18T08:39:50.000Z","updated":"2020-10-21T06:24:53.049Z","comments":true,"path":"Mybatis/","link":"","permalink":"blog.silverbeats.cn/Mybatis/","excerpt":"","text":"1. 简介 1.1 什么是Mybatis MyBatis本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github MyBatis 是一款优秀的持久层框架 它支持自定义 SQL、存储过程以及高级映射。 MyBatis免除了几乎所有的 JDBC代码以及设置参数和获取结果集的工作。MyBatis可以通过简单的XML或注解来配置和映射原始类型、接口和 Java的POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 1.2 获得Mybatis Maven仓库 &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --> &lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> &lt;artifactId>mybatis&lt;/artifactId> &lt;version>3.5.3&lt;/version> &lt;/dependency> GitHub 中文文档 1.2 使用Mybatis的原因 简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。 解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 提供映射标签，支持对象与数据库的orm字段关系映射 提供对象关系映射标签，支持对象关系组建维护 提供xml标签，支持编写动态sql 2. 第一个Mybatis程序 2.1 环境搭建 搭建数据库 CREATE DATABASE `mybatistest`; USE `mybatistest`; CREATE TABLE `user` ( `id` INT(20) NOT NULL PRIMARY KEY, `name` VARCHAR(30) DEFAULT NULL, `pwd` VARCHAR(30) DEFAULT NULL )ENGINE=INNODB DEFAULT CHARSET=utf8; INSERT INTO `user` VALUES (1,\"张三\", \"123456\"), (2,\"李四\", \"1234567\"), (3,\"王五\", \"1234568\") 创建Maven项目 删除src目录 导入Maven依赖 &lt;dependencies> &lt;!--mysql驱动--> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>8.0.18&lt;/version> &lt;/dependency> &lt;!--mybatis--> &lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> &lt;artifactId>mybatis&lt;/artifactId> &lt;version>3.5.3&lt;/version> &lt;/dependency> &lt;!--Junit--> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.13&lt;/version> &lt;/dependency> &lt;/dependencies> 2.2 创建一个模块 在resources文件夹下，创建Mybatis核心配置文件 &lt;!--configuration核心配置文件--> &lt;configuration> &lt;!--多个环境--> &lt;environments default=\"development\"> &lt;!--开发环境--> &lt;environment id=\"development\"> &lt;!--事务管理--> &lt;transactionManager type=\"JDBC\"/> &lt;!--数据库相关--> &lt;dataSource type=\"POOLED\"> &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/> &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatistest?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai\"/> &lt;property name=\"username\" value=\"root\"/> &lt;property name=\"password\" value=\"root\"/> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;/configuration> 编写Mybatis的工具类 package com.silverbeats.utils; public class MybatisUtil &#123; private static SqlSessionFactory sqlSessionFactory; static &#123; // 使用Mybatis第一步：获取SQLSessionFactory对象 try &#123; String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。 // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession // 实例来直接执行已映射的 SQL 语句 public static SqlSession getSqlSession() &#123; return sqlSessionFactory.openSession(); &#125; &#125; 2.3 编写代码 实体类 public class User &#123; private int id; private String name; private String pwd; // 以及空参、有参、get、set、toString方法 &#125; Dao接口 public interface UserMapper &#123; List&lt;User> getUserList(); &#125; 接口实现类 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;!--命名空间 绑定一个对应的dao接口也就是mapper接口--> &lt;mapper namespace=\"com.silverbeats.dao.UserMapper\"> &lt;!--id对应绑定接口的方法,resultType返回类型要写全类名--> &lt;select id=\"getUserList\" resultType=\"com.silverbeats.pojo.User\"> select * from mybatistest.user &lt;/select> &lt;/mapper> 2.4 Junit测试 根据上面的内容进行测试一定出现下面的异常 绑定异常 org.apache.ibatis.binding.BindingException: Type interface com.silverbeats.dao.UserMapper is not known to the MapperRegistry 这是因为在Maybatis核心配置文件中缺少内容 &lt;!--每一个Mapper.xml都需要在Mybatis核心配置文件中注册,这里就是MapperRegistry--> &lt;mappers> &lt;mapper resource=\"com/silverbeats/dao/UserMapper.xml\"/> &lt;/mappers> 但是运行单元测试还是会出现下面的异常，表示找不到配置文件 java.lang.ExceptionInInitializerError at com.silverbeats.dao.UserMapperTest.test(UserMapperTest.java:15) …… Caused by: org.apache.ibatis.exceptions.PersistenceException: ### Error building SqlSession. ### The error may exist in com&#x2F;silverbeats&#x2F;dao&#x2F;UserMapper.xml ### Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.io.IOException: Could not find resource com&#x2F;silverbeats&#x2F;dao&#x2F;UserMapper.xml 这是因为Maven项目中资源导出的问题，需要在父工程或者子工程的pom.xml导入如下代码（保险起见都父子工程导入） &lt;build> &lt;resources> &lt;resource> &lt;directory>src/main/resources&lt;/directory> &lt;includes> &lt;include>**/*.properties&lt;/include> &lt;include>**/*.xml&lt;/include> &lt;/includes> &lt;filtering>false&lt;/filtering> &lt;/resource> &lt;resource> &lt;directory>src/main/java&lt;/directory> &lt;includes> &lt;include>**/*.properties&lt;/include> &lt;include>**/*.xml&lt;/include> &lt;/includes> &lt;filtering>false&lt;/filtering> &lt;/resource> &lt;/resources> &lt;/build> @Test public void test() &#123; // 获得SqlSession对象 SqlSession sqlSession = MybatisUtil.getSqlSession(); try &#123; // 方式一：执行sql UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User> userList = userMapper.getUserList(); // 方法2 // List&lt;User> userList = sqlSession.selectList(\"com.silverbeats.dao.UserMapper.getUserList\"); // 打印数据 for (User user : userList) &#123; System.out.println(user); &#125; &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭SqlSession sqlSession.close(); &#125; &#125; 2.5 总结 上面的第一个程序中，一共创建了6个文件 子工程resources/mybatis-config.xml Mybatis核心配置文件 子工程java目录下建包，dao目录下User实体类对应的接口UserMapper dao目录下实体类接口UserMapper对应的配置文件UserMapper.xml，并且每个xml配置文件都需要在Mybatis核心配置文件中进行注册 pojo目录下，User实体类，JavaBean utils目录下，MybatisUtil工具类，加载核心配置文件，返回sqlSession test目录下，对应目录结构，创建了Junit测试类 其中，在后期使用过程中，有一些文件是不需要修改的： MybatisUtil类不需要修改 User实体类不需要变动，除非数据库对应的字段发生变化 当需要向数据库添加新的表时，只需要在dao目录下创建对应的Mapper、Mapper.xml并在Mybatis-config.xml进行注册，以及pojo下的实体类即可 3. CRUD 在UserMapper.xml书写sql，进行CRUD 3.1 select标签 编写接口 // 查询全部用户 List&lt;User> getUserList(); // 根据id查询用户 User getUserById(int id); 编写对应Mapper.xml的sql &lt;!--普通查询--> &lt;select id=\"getUserList\" resultType=\"com.silverbeats.pojo.User\"> select * from mybatistest.user; &lt;/select> &lt;!--带有条件的查询--> &lt;select id=\"getUserById\" resultType=\"com.silverbeats.pojo.User\" parameterType=\"int\"> select * from mybatistest.user where id = #&#123;id&#125;; &lt;/select> id 绑定的namespace中的方法名 resultType sql语句执行的返回值 parameterType 参数类型 @Test public void getUserById() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.getUserById(2); System.out.println(user); sqlSession.close(); &#125; 3.2 insert标签 编写接口 // 插入用户 int addUser(User user); // 删除用户 int deleteUser(int id); 编写对应Mapper.xml的sql &lt;insert id=\"addUser\" parameterType=\"com.silverbeats.pojo.User\"> insert into mybatistest.user (id, name, pwd) values(#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;); &lt;/insert> @Test public void addUser() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int res = userMapper.addUser(new User(4, \"胡娜\", \"asdf\")); // 插入成功，提交事务 if(res > 0) &#123; sqlSession.commit(); &#125; sqlSession.close(); &#125; 3.3 update标签 编写接口 // 修改用户 int updateUser(User user); 编写对应Mapper.xml的sql &lt;update id=\"updateUser\" parameterType=\"com.silverbeats.pojo.User\"> update mybatistest.user set name=#&#123;name&#125;, pwd=#&#123;pwd&#125; where id = #&#123;id&#125;; &lt;/update> @Test public void updateUser() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int res = userMapper.updateUser(new User(4, \"胡娜12\", \"asdf\")); // 更新成功，提交事务 if(res > 0) &#123; sqlSession.commit(); &#125; sqlSession.close(); &#125; 3.4 delete标签 编写接口 // 删除用户 int deleteUser(int id); 编写对应Mapper.xml的sql &lt;delete id=\"deleteUser\" parameterType=\"int\"> delete from mybatistest.user where id = #&#123;id&#125;; &lt;/delete> @Test public void deleteUser() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int res = userMapper.deleteUser(4); // 插入成功，提交事务 if(res > 0) &#123; sqlSession.commit(); &#125; sqlSession.close(); &#125; 3.5 Map 倘若实体类或者数据库中的表字段过多，可以考虑使用Map集合来解决 // 用map插入用户 int addUser2(Map&lt;String, Object> map); &lt;!--通过map添加--> &lt;insert id=\"addUser2\" parameterType=\"map\"> insert into mybatistest.user (id, name, pwd) values(#&#123;userid&#125;, #&#123;userName&#125;, #&#123;password&#125;); &lt;/insert> @Test public void addUser2() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); HashMap&lt;String, Object> map = new HashMap&lt;String, Object>(); map.put(\"userid\", 7); map.put(\"userName\", \"呼啦啦\"); map.put(\"password\", \"lliiww\"); userMapper.addUser2(map); sqlSession.commit(); sqlSession.close(); &#125; Map传递参数，直接在sql中取出对应的key即可，parameterType=“map” 对象传递参数，直接在sql中取对象的属性即可，parameterType=“com.silverbeats.pojo.User” 在只有一个基本类型参数的情况下，可以直接在sql中取到 多个参数用Map，或者注解 4. 配置解析 配置文档 4.1 核心配置文件mybatis-config.xml 标签书写顺序 The content of element type “configuration” must match “(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)”. 4.2 properties 属性 可以通过properties 属性来实现引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置 在[上面的程序](#2. 第一个Mybatis程序)的核心配置文件中，可以将其中的driver、url、username、password写到properties文件中 driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatistest?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai username=root password=root 然后在核心配置文件中引入该properties文件 &lt;configuration> &lt;!--引入外部配置文件--> &lt;properties resource=\"db.properties\" /> &lt;environments default=\"development\"> &lt;environment id=\"development\"> &lt;transactionManager type=\"JDBC\"/> &lt;dataSource type=\"POOLED\"> &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/> &lt;property name=\"url\" value=\"$&#123;url&#125;\"/> &lt;property name=\"username\" value=\"$&#123;username&#125;\"/> &lt;property name=\"password\" value=\"$&#123;password&#125;\"/> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;!--每一个Mapper.xml都需要在Mybatis核心配置文件中注册--> &lt;mappers> &lt;mapper resource=\"com/silverbeats/dao/UserMapper.xml\"/> &lt;/mappers> &lt;/configuration> 同时properties标签内可以使用property标签来添加属性，比如将username和password用property传递，url和driver用properties文件 driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatistest?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai &lt;properties resource=\"db.properties\"> &lt;property name=\"username\" value=\"root\"/> &lt;property name=\"password\" value=\"root\"/> &lt;/properties> 这样也可以达到相同的效果。 倘若是下面这种情况 password=root &lt;properties resource=\"db.properties\"> &lt;property name=\"password\" value=\"1234\"/> &lt;/properties> 会优先使用properties文件中的password值 4.3 settings 设置 settings 设置文档 4.4 typeAliases 类型别名 在核心配置文件中给实体类起别名，这样，可以在Mapper.xml中的resultType和parameterType直接使用这个别名即可，而不需要写全类名 &lt;!--给实体类起别名--> &lt;typeAliases> &lt;typeAlias type=\"com.silverbeats.pojo.User\" alias=\"User\" /> &lt;/typeAliases> 也可以指定一个包名，Mybatis会在包名下面搜索需要的JavaBean，在没有注解的情况下，扫描到的Bean别名模式是类名小写 &lt;typeAliases> &lt;package name=\"com.silverbeats.pojo\"/> &lt;/typeAliases> 第三种起别名方式为加注解 @Alias(\"hulala\") public class User &#123;&#125; 上面三个方式都可以给实体类起别名，优先级不同，第一种直接给实体类起别名优先级最高，其次是注解，最后是指定包名给实体类起别名 4.5 environments 环境变量 MyBatis 可以配置成适应多种环境，尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境 &lt;!--通过修改default的值来切换环境--> &lt;environments default=\"development\"> &lt;environment id=\"development\"> &lt;transactionManager type=\"JDBC\"> &lt;property name=\"...\" value=\"...\"/> &lt;/transactionManager> &lt;dataSource type=\"POOLED\"> &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/> &lt;property name=\"url\" value=\"$&#123;url&#125;\"/> &lt;property name=\"username\" value=\"$&#123;username&#125;\"/> &lt;property name=\"password\" value=\"$&#123;password&#125;\"/> &lt;/dataSource> &lt;/environment> &lt;/environments> transactionManager事务管理器 JDBC 默认 MANAGED dataSource数据源，dataSource元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源，三种内建的数据源类型 UNPOOLED 这个数据源的实现会每次请求时打开和关闭连接。虽然有点慢，但对那些数据库连接可用性要求不高的简单应用程序来说，是一个很好的选择。 性能表现则依赖于使用的数据库，对某些数据库来说，使用连接池并不重要，这个配置就很适合这种情形 POOLED 默认 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这种处理方式很流行，能使并发 Web 应用快速响应请求 JNDI 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用 4.6 映射器Mappers 既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要来定义 SQL 映射语句了。 但首先，我们需要告诉 MyBatis 到哪里去找到这些语句。 在自动查找资源方面，Java 并没有提供一个很好的解决方案，所以最好的办法是直接告诉 MyBatis 到哪里去找映射文件。 你可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 file:/// 形式的 URL），或类名和包名等。例如： &lt;!-- 使用相对于类路径的资源引用 --> &lt;mappers> &lt;mapper resource=\"org/mybatis/builder/AuthorMapper.xml\"/> &lt;mapper resource=\"org/mybatis/builder/BlogMapper.xml\"/> &lt;mapper resource=\"org/mybatis/builder/PostMapper.xml\"/> &lt;/mappers> &lt;!-- 使用完全限定资源定位符（URL） --> &lt;mappers> &lt;mapper url=\"file:///var/mappers/AuthorMapper.xml\"/> &lt;mapper url=\"file:///var/mappers/BlogMapper.xml\"/> &lt;mapper url=\"file:///var/mappers/PostMapper.xml\"/> &lt;/mappers> 下面两个方法需要注意： 接口和它的Mapper配置文件必须同名 接口和它的Mapper配置文件必须同包 &lt;!-- 使用映射器接口实现类的完全限定类名 --> &lt;mappers> &lt;mapper class=\"org.mybatis.builder.AuthorMapper\"/> &lt;mapper class=\"org.mybatis.builder.BlogMapper\"/> &lt;mapper class=\"org.mybatis.builder.PostMapper\"/> &lt;/mappers> &lt;!-- 将包内的映射器接口实现全部注册为映射器 --> &lt;mappers> &lt;package name=\"org.mybatis.builder\"/> &lt;/mappers> 4.7 其他 typeHandlers 类型处理器 objectFactory 对象工厂 plugins 插件 Mybatis-generator-core Mybatis-plus 通用mapper 5. 生命周期和作用域 作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题 对象生命周期和依赖注入框架 依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。 如果对如何通过依赖注入框架使用 MyBatis 感兴趣，可以研究一下 MyBatis-Spring 或 MyBatis-Guice 两个子项目。 5.1 SqlSessionFactoryBuilder 可实例化 一旦创建了 SqlSessionFactory，就不再需要它了 作用域：局部变量 5.2 SqlSessionFactory 一旦创建，一直存在 可以想象为：数据库连接池 单例模式或静态单例模式 作用域：全局作用域 5.3 SqlSession 每个线程都应该有它自己的 SqlSession 实例，可以理解为连接到连接池的一个请求，需要自行请求和关闭 SqlSession 的实例不是线程安全的，因此是不能被共享的 用完就关闭，否则会出现资源占用 最佳的作用域是请求或方法作用域 6. 解决属性名和字段名不一致的问题 当实体类中的私有属性，比如password，而在数据库中对应的字段名是pwd，倘若通过id查询，是不会获得对应的值的。 因为在Mapper.xml中对应的sql是这样写的： select * from mybatistest.user where id = #&#123;id&#125;; -- 实际上是： select id,name,pwd from mybatistest.user where id = #&#123;id&#125;; -- 目标就是，如何将查询到的pwd值给到password 解决方法 起别名 select id,name,pwd as password from mybatistest.user where id = #&#123;id&#125;; resultMap结果集映射，在Mapper.xml中写 &lt;resultMap id=\"UserMap\" type=\"User\"> &lt;!--column和property值一样，可省略--> &lt;!--column对应数据库的列--> &lt;!--property对应实体类的属性值--> &lt;result column=\"id\" property=\"id\" /> &lt;!--column和property值一样，可省略--> &lt;result column=\"name\" property=\"name\" /> &lt;result column=\"pwd\" property=\"password\" /> &lt;/resultMap> &lt;!--此时不需要resultType--> &lt;select id=\"getUserById\" resultMap=\"UserMap\" parameterType=\"int\"> select * from mybatistest.user where id = #&#123;id&#125;; &lt;/select> 7. 日志 7.1 日志工厂 如果一个数据库操作出现异常，需要排错，日志就是最好的助手。 在核心配置文件中配置logImpl，指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J LOG4J 【掌握】【需要导包】 LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING【掌握】【可以直接用】 NO_LOGGING &lt;settings> &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/> &lt;/settings> 7.2 LOG4J Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIXSyslog守护进程等； 可以控制每一条日志的输出格式 可以定义每一条日志信息的级别，能够更加细致地控制日志的生成过程 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 导入LOG4J包 &lt;dependency> &lt;groupId>log4j&lt;/groupId> &lt;artifactId>log4j&lt;/artifactId> &lt;version>1.2.17&lt;/version> &lt;/dependency> log4j.properties #将登记为DEBUG的日志信息输出到console和file两个目的地 log4j.rootLogger = debug,console,file #控制台输出的相关配置 log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.Threshold = DEBUG log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern = [%c]-%m%n #文件输出相关配置 log4j.appender.file = org.apache.log4j.RollingFileAppender log4j.appender.file.File = ./logs/log.log log4j.appender.file.MaxFileSize = 10mb ##输出DEBUG级别以上的日志 log4j.appender.file.Threshold = DEBUG log4j.appender.file.layout = org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n #日志输出级别 log4j.logger.org.mybatis = DEBUG log4j.logger.java.sql = DEBUG log4j.logger.java.sql.Statement = DEBUG log4j.logger.java.sql.ResultSet = DEBUG log4j.logger.java.sql.PrepareStatement= DEBUG 配置核心文件 &lt;settings &lt;setting name=\"logImpl\" value=\"LOG4J\"/> &lt;/settings> 8. 分页 8.1 limit分页 分页的原因：减少数据的处理量，提高效率 select * from 表 limit startIndex, pageSize; 接口 // 测试分页 List&lt;User> getUsers(Map&lt;String, Integer> map); Mapper.xml &lt;select id=\"getUsers\" resultMap=\"UserMap\" parameterType=\"map\"> select * from mybatistest.user limit #&#123;startIndex&#125;, #&#123;pageSize&#125;; &lt;/select> 测试 @Test public void testLimit() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); HashMap&lt;String, Integer> map = new HashMap&lt;String, Integer>(); map.put(\"startIndex\", 1); map.put(\"pageSize\", 2); List&lt;User> userList = userMapper.getUsers(map); for (User user : userList) &#123; logger.info(user); &#125; sqlSession.close(); &#125; 8.2 RowBounds分页 接口 // 使用RowBounds查询 List&lt;User> getUsersByRowBounds(); Mapper.xml &lt;select id=\"getUsers\" resultMap=\"UserMap\"> select * from mybatistest.user; &lt;/select> 测试 @Test public void testRoundBounds() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); // RowBounds实现 RowBounds rowBounds = new RowBounds(0, 3); // 通过java代码层面实现分页 List&lt;User> selectList = sqlSession.selectList(\"com.silverbeats.dao.UserMapper.getUsersByRowBounds\",null, rowBounds); for (User user : selectList) &#123; logger.info(user); &#125; sqlSession.close(); &#125; 8.3 分页插件 pagehelper 9. 使用注解 接口 @Select(\"select * from user\") List&lt;User> getUsers(); // 方法存在多个参数,所有参数前面必须要有@Param @Select(\"select * from user where id = #&#123;id&#125;\") User getUserById(@Param(\"id\") int id); // 插入用户 @Select(\"insert into mybatistest.user (id, name, pwd) values(#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;)\") void insertUser(@Param(\"id\") int id, @Param(\"name\") String name,@Param(\"pwd\") String password); @Select(\"insert into mybatistest.user (id, name, pwd) values(#&#123;id&#125;, #&#123;name&#125;, #&#123;password&#125;)\") void addUser(User user); // 更新 @Update(\"update user set name = #&#123;name&#125; where id = #&#123;id&#125;\") int updateUser(User user); // 删除 @Delete(\"delete from user where id = #&#123;id&#125;\") int deleteUser(@Param(\"id\") int id); @Param()注解 基本类型的参数或者String类型，需要加上注解 如果只有一个基本类型，可以忽略 引用类型不需要加 在sql引用的就是这里设定的属性名 核心配置xml &lt;!--绑定接口--> &lt;mappers> &lt;mapper class=\"com.silverbeats.dao.UserMapper\"/> &lt;/mappers> 10. Lombok Lombok项目是一个Java库，它会自动插入您的编辑器和构建工具中，从而使您的Java更加生动有趣。永远不要再写另一个getter或equals方法，带有一个注释的您的类有一个功能全面的生成器，自动执行记录变量等。 idea中安装插件 项目中导入lombok的jar包 @data: 可以添加无参构造、get、set、toString、hashCode、equals @ToString: 重写toString方法 @AllArgsConstructor: 添加有参构造 @NoArgsConstructor: 添加无参构造 @EqualsAndHashCode: 添加hashCode、equals方法 11. 复杂查询环境 搭建环境，创建学生表和老师表 CREATE TABLE `teacher` ( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO teacher(`id`, `name`) VALUES (1, '乌拉拉'); CREATE TABLE `student` ( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAULT NULL, `tid` INT(10) DEFAULT NULL, PRIMARY KEY (`id`), KEY `fktid` (`tid`), CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('1', '小明', '1'); INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('2', '小红', '1'); INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('3', '小张', '1'); INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('4', '小李', '1'); INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('5', '小王', '1'); 11.1 多对一 多个学生关联一个老师 @Data @AllArgsConstructor @NoArgsConstructor public class Student &#123; private int id; private String name; private Teacher teacher; &#125; @Data @AllArgsConstructor @NoArgsConstructor public class Teacher &#123; private int id; private String name; &#125; -- 在mybatis实现下面的sql select * from student s, teacher t where s.tid = t.id; ①先获取所有学生的信息 ②根据学生的tid获取对应老师的信息 按照查询嵌套 &lt;select id=\"getStudentInfo\" resultMap=\"studentTeacher\"> select * from student; &lt;/select> &lt;resultMap id=\"studentTeacher\" type=\"student\"> &lt;result column=\"id\" property=\"id\"/> &lt;result column=\"name\" property=\"name\"/> &lt;association column=\"tid\" property=\"teacher\" javaType=\"teacher\" select=\"getTeacher\"/> &lt;/resultMap> &lt;select id=\"getTeacher\" resultType=\"teacher\"> select * from teacher where id = #&#123;tid&#125;; &lt;/select> 按照结果嵌套 &lt;select id=\"getStudentInfo2\" resultMap=\"studentTeacher2\"> select s.id sid, s.name sname, t.name tname from student s, teacher t where s.tid = t.id; &lt;/select> &lt;resultMap id=\"studentTeacher2\" type=\"student\"> &lt;result property=\"id\" column=\"sid\"/> &lt;result property=\"name\" column=\"sname\"/> &lt;association property=\"teacher\" javaType=\"teacher\"> &lt;result property=\"name\" column=\"tname\"/> &lt;/association> &lt;/resultMap> 11.2 一对多 一个老师关联多个学生 @Data @AllArgsConstructor @NoArgsConstructor public class Student &#123; private int id; private String name; private int tid; &#125; @Data @AllArgsConstructor @NoArgsConstructor public class Teacher &#123; private int id; private String name; private List&lt;Student> students; &#125; // 获取指定老师下的学生信息和老师信息 Teacher getTeacherById(@Param(\"tid\") int id); 按照结果嵌套 &lt;!--获取指定老师下的学生信息和老师信息--> &lt;select id=\"getTeacherById\" resultMap=\"teacherStudent\"> select s.id sid, s.name sname, t.name tname, t.id tid from student s, teacher t where s.tid = tid and tid = #&#123;tid&#125; &lt;/select> &lt;resultMap id=\"teacherStudent\" type=\"teacher\"> &lt;result property=\"id\" column=\"tid\" /> &lt;result property=\"name\" column=\"tname\"/> &lt;collection property=\"students\" ofType=\"student\"> &lt;result property=\"id\" column=\"sid\"/> &lt;result property=\"name\" column=\"sname\"/> &lt;result property=\"tid\" column=\"tid\"/> &lt;/collection> &lt;/resultMap> 按照查询嵌套 &lt;select id=\"getTeacherById\" resultMap=\"teacherStudent\"> select * from teacher where id = #&#123;tid&#125;; &lt;/select> &lt;resultMap id=\"teacherStudent\" type=\"teacher\"> &lt;result property=\"id\" column=\"id\" /> &lt;result property=\"name\" column=\"name\"/> &lt;collection property=\"students\" javaType=\"ArrayList\" ofType=\"student\" select=\"getStudentsByTeacherId\" column=\"id\" /> &lt;/resultMap> &lt;select id=\"getStudentsByTeacherId\" resultType=\"student\"> select * from student where tid = #&#123;tid&#125; &lt;/select> 12. 动态sql 根据不同的条件生成不同的sql 环境 CREATE TABLE `blog`( `id` VARCHAR(50) NOT NULL COMMENT '博客id', `title` VARCHAR(100) NOT NULL COMMENT '博客标题', `author` VARCHAR(30) NOT NULL COMMENT '博客作者', `create_time` DATETIME NOT NULL COMMENT '创建时间', `views` INT(30) NOT NULL COMMENT '浏览量' )ENGINE=INNODB DEFAULT CHARSET=utf8 public void addBlog() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); Blog blog = new Blog(); blog.setId(IDUtils.getID()); blog.setTitle(\"Mybatis\"); blog.setAuthor(\"狂神说\"); blog.setCreateTime(new Date()); blog.setViews(9999); mapper.addBlog(blog); blog.setId(IDUtils.getID()); blog.setTitle(\"Java\"); mapper.addBlog(blog); blog.setId(IDUtils.getID()); blog.setTitle(\"Spring\"); mapper.addBlog(blog); blog.setId(IDUtils.getID()); blog.setTitle(\"微服务\"); mapper.addBlog(blog); sqlSession.close(); &#125; &lt;mapper namespace=\"com.silverbeats.dao.BlogMapper\"> &lt;insert id=\"addBlog\" parameterType=\"blog\"> insert into blog(id, title, author, create_time, views) values(#&#123;id&#125;,#&#123;title&#125;,#&#123;author&#125;,#&#123;createTime&#125;,#&#123;views&#125;); &lt;/insert> &lt;/mapper> 实体类 @Data @NoArgsConstructor @AllArgsConstructor public class Blog &#123; private String id; private String author; private String title; private Date createTime; private int view; &#125; 12.1 iF 接口 // 查询blog List&lt;Blog> queryBlogIF(Map map); Mapper.xml &lt;select id=\"queryBlogIF\" parameterType=\"map\" resultType=\"blog\"> select * from blog where 1=1 &lt;if test=\"title != null\"> and title = #&#123;title&#125; &lt;/if> &lt;if test=\"author != null\"> and author = #&#123;author&#125; &lt;/if> &lt;/select> 测试 @Test public void testIf() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); HashMap map = new HashMap(); map.put(\"title\", \"Spring\"); List&lt;Blog> blogs = mapper.queryBlogIF(map); for (Blog blog : blogs) &#123; System.out.println(blog); &#125; sqlSession.close(); &#125; 12.2 choose(when、otherwise) choose标签，当满足第一个when的条件就不会再往下走了 &lt;!--测试choose--> &lt;select id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"blog\"> select * from blog &lt;where> &lt;choose> &lt;when test=\"title != null\">title = #&#123;title&#125;&lt;/when> &lt;when test=\"author != null\">and author = #&#123;author&#125;&lt;/when> &lt;otherwise>and views = #&#123;views&#125;&lt;/otherwise> &lt;/choose> &lt;/where> &lt;/select> 12.3 trim（where、set） where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。 &lt;!--测试where--> &lt;select id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"blog\"> select * from blog &lt;where> &lt;if test=\"title != null\">title = #&#123;title&#125;&lt;/if> &lt;if test=\"author != null\">and author = #&#123;author&#125;&lt;/if> &lt;/where> &lt;/select> set 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。 &lt;!--测试set--> &lt;update id=\"updateBlog\" parameterType=\"map\"> update blog &lt;set> &lt;if test=\"title != null\">title = #&#123;title&#125;,&lt;/if> &lt;if test=\"author != null\">author = #&#123;author&#125;,&lt;/if> &lt;/set> where id = #&#123;id&#125;; &lt;/update> 12.4 foreach foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！ &lt;!--测试foreach--> &lt;select id=\"queryForeach\" parameterType=\"ArrayList\" resultType=\"blog\"> select * from blog where views in &lt;foreach item=\"item\" collection=\"list\" index=\"index\" open=\"(\" close=\")\" separator=\",\"> #&#123;item&#125; &lt;/foreach> &lt;/select> 实质：循环字符串拼接 collection：需要遍历的集合 item：被遍历集合的每个元素 index：被遍历元素的索引 open：开始的字符 close：结束的字符 separator：分隔符 // 测试foreach List&lt;Blog> queryForeach(@Param(\"list\") List&lt;Integer> list); /*----------------------------------------------------------*/ @Test public void TestForeach() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); ArrayList&lt;Integer> list = new ArrayList&lt;Integer>(); list.add(1000); list.add(2000); list.add(7000); List&lt;Blog> blogs = mapper.queryForeach(list); sqlSession.close(); &#125; 12.5 sql片段 有的时候，会将公共的部分抽取出来，方便反复使用 &lt;!--测试sql片段--> &lt;sql id=\"if_title_author\"> &lt;if test=\"title != null\"> and title = #&#123;title&#125; &lt;/if> &lt;if test=\"author != null\"> and author = #&#123;author&#125; &lt;/if> &lt;/sql> &lt;!--测试where--> &lt;select id=\"queryBlogWhere\" parameterType=\"map\" resultType=\"blog\"> select * from blog &lt;where> &lt;include refid=\"if_title_author\" /> &lt;/where> &lt;/select> 最好基于单表来定义sql片段 sql片段中不要存在where标签 13. 缓存 读写分离，主从复制 经常查询并且不经常改变的数据可以使用缓存 13.1 Mybatis的缓存 Mybatis包含了一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存，缓存可以极大地提升查询效率 Mybatis系统中默认定义了两级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启，（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存 为了提高扩展性，Mybatis定义了缓存接口Cache，可以通过实现Cache接口来自定义二级缓存 13.2 一级缓存 @Test public void test() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user1 = mapper.queryUserById(1); System.out.println(\"=================\"); User user2 = mapper.queryUserById(1); System.out.println(user1 == user2); sqlSession.close(); &#125; 可以看到，只有一次SQL查询，并且user1和user2是同一个对象 缓存失效的情况 查询不同的东西 增删改操作，可能会改编原来的数据，所以会刷新缓存 @Test public void test() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user1 = mapper.queryUserById(1); System.out.println(\"=================\"); System.out.println(\"更新id=2的用户\"); HashMap map = new HashMap(); map.put(\"id\", 2); map.put(\"name\", \"嗯哼2\"); mapper.updateUserById(map); System.out.println(\"=================\"); User user2 = mapper.queryUserById(1); System.out.println(user1 == user2); sqlSession.close(); &#125; 查询不同的Mapper.xml 手动清理缓存 @Test public void test() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user1 = mapper.queryUserById(1); System.out.println(\"=================\"); System.out.println(\"清理缓存\"); sqlSession.clearCache(); System.out.println(\"=================\"); User user2 = mapper.queryUserById(1); System.out.println(user1 == user2); sqlSession.close(); &#125; 13.3 二级缓存 二级缓存也称全局缓存，是基于namespace级别的缓存，一个名称空间对应一个二级缓存 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中 如果当前会话关闭了，这个会话对应的一级缓存就没了，但是目标是：一级缓存消失，会将其中的数据保存到二级缓存中 新的会话查询信息，就可以从二级缓存中获取内容 不同的mapper查出的数据可以放在自己对应的缓存（map）中 步骤： 开启全局缓存 &lt;settings> &lt;setting name=\"cacheEnabled\" value=\"true\"/> &lt;/settings> 在Mapper.xml中添加cache标签 &lt;cache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/> @Test public void test() &#123; SqlSession sqlSession1 = MybatisUtil.getSqlSession(); SqlSession sqlSession2 = MybatisUtil.getSqlSession(); UserMapper mapper1 = sqlSession1.getMapper(UserMapper.class); UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class); User user1 = mapper1.queryUserById(1); System.out.println(\"关闭sqlSession1\"); sqlSession1.close(); User user2 = mapper2.queryUserById(1); System.out.println(\"=================\"); System.out.println(user1); System.out.println(user2); System.out.println(user1 == user2); sqlSession2.close(); &#125; 这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。 可用的清除策略有： LRU – 最近最少使用：移除最长时间不被使用的对象。 FIFO – 先进先出：按对象进入缓存的顺序来移除它们。 SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。 WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。 默认的清除策略是 LRU。 flushInterval（刷新间隔）属性可以被设置为任意的正整数，设置的值应该是一个以毫秒为单位的合理时间量。 默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新。 size（引用数目）属性可以被设置为任意正整数，要注意欲缓存对象的大小和运行环境中可用的内存资源。默认值是 1024。 readOnly（只读）属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。 13.4 缓存原理 缓存顺序： 先找二级缓存 再找一级缓存 最后查询数据库","categories":[{"name":"java","slug":"java","permalink":"blog.silverbeats.cn/categories/java/"},{"name":"Mybatis","slug":"java/Mybatis","permalink":"blog.silverbeats.cn/categories/java/Mybatis/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"blog.silverbeats.cn/tags/Mybatis/"}],"author":"silverbeats"},{"title":"算法设计与分析-动态规划","slug":"算法设计与分析-动态规划","date":"2020-10-02T08:27:27.000Z","updated":"2020-10-21T06:24:07.258Z","comments":false,"path":"算法设计与分析-动态规划/","link":"","permalink":"blog.silverbeats.cn/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"动态规划和分治法类似，其基本思想也是将待求解问题分解成若干个子问题。不同点在于，适用于动态规划的问题，其子问题往往不是相互独立，倘若使用分治法，会进行大量的重复计算。比如斐波那契数列求解问题，当计算Fib(10)时，会需要用到Fib(9)和Fib(8)，而计算Fib(9)也需要用到Fib(8)，实际上Fib(8)只需要计算一次即可，倘若使用分治法会对其进行两次的计算。（然而实际上，计算斐波那契数列不会用到这种求解方式，可以使用迭代解决，或者直接使用通项公式求解） 动态规划通常可以按下面四个步骤设计： 找出最优解的性质，并刻画其结构特征 递归定义最优解 以自底向上的方式计算出最优解 根据计算最优时得到的信息，构造最优解 动态规划往往是利用空间换时间 1. 矩阵连乘 矩阵的乘法有结合律，不同的计算顺序所耗费的代价不同。比如： 矩阵1 矩阵2 矩阵3 A10×100 A100×5 A5×50 计算顺序1：（矩阵1×矩阵2）×矩阵3 所需要的乘法次数：10×5×100 + 10×50×5 = 7500次 所需要的加法次数：10×5×99 + 10×50×4 = 6950次 计算顺序2：矩阵1×（矩阵2×矩阵3） 所需要的乘法次数：100×50×5 + 10×50×100 = 750000次 所需要的加法次数：100×50×4 + 10×50×99 = 497000次 这里不做矩阵相乘的O(n3)写法，相关代码可以参考算法设计与分析——分治法Strassen矩阵乘法。 2. 最长公共子序列 3. 最大子段和 4. 凸多边形最优三角剖分 5. 多边形游戏 6. 图像压缩 7. 电路布线 8. 流水作业调度 9. 背包问题 10. 最优二叉搜索树","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"算法设计与分析","slug":"算法/算法设计与分析","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"}],"tags":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"blog.silverbeats.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"silverbeats"},{"title":"KMP","slug":"KMP","date":"2020-09-29T05:08:18.000Z","updated":"2020-10-22T12:20:40.722Z","comments":true,"path":"KMP/","link":"","permalink":"blog.silverbeats.cn/KMP/","excerpt":"","text":"1. KMP简介 KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n) 2. KMP图解 2.1 通览(编号从0开始) 2.1.1 情况一 以上述主串和模式串为例子，可知，i指针指向主串，j指针指向模式串 当主串i位置与模式串j位置字符一样，i，j向后移动一个位置 2.1.2 情况二 易知，当i=5，j=5时，主串与模式串发生不匹配，此时需要进行的操作就是KMP的精华所在。 找到不匹配位置之前的字符串的最大公共前后缀。易知，最长公共前后缀是{A,B}，长度是2 进行如上图下半部分的操作。将字符串向后挪动，让前缀处于后缀的位置 易知，此时指针i是不需要任何变动。 挪动后，i，j所指向的位置继续比较。 字符串是不可能挪动的，实际上改变的是指针j，易知，挪动后指针j指向模式串编号为2的位置 上图，指针j经过调整后，从模式串编号2开始，继续和主串进行比较，当j指向编号6时发生不匹配，进行上述提到的步骤，经过调整得到下图情况三。 2.1.3 情况三 每次移动指针j后，需要检查主串剩余长度是否≥模式串需要匹配的长度 2.1.4 综合 根据上面提到的情况进行汇总，也就是代码实现的需要用到的步骤 当主串i位置与模式串j位置字符一样，i，j向后移动一个位置 当出现不匹配时，需要寻找不匹配位置之前的串的最大公共前后缀长度，比如长度是n，并将j移动到编号为n的位置，这里需要结合next数组，详情见[Next数组](#3. Next数组) 移动指针j后，需要检查主串剩余长度是否≥模式串需要匹配的长度，不符合条件直接break，返回匹配失败 当j的位置超过了模式串的编号，说明匹配成功，返回模式串第一个字符在主串出现的位置 2.2 通览(编号从1开始) 整个过程与上面标号从0开始的过程大体一致，只有一个区别就是：调整指针j的值，指的位置是不匹配位置之前的字符串的最大公共前后缀长度+1 3. Next数组 通过上一节内容可以知道，KMP算法核心是指向模式串的指针j的移动，该指针的如何移动实际上与主串是什么无关，只与模式串有关。只需要将模式串研究明白，则可以对任意主串进行匹配。 因为要匹配任意主串，故很容易知道，模式串的每个位置都有可能和主串出现不匹配。这时，当模式串每个位置出现不匹配时，此时的指针j应该调整到哪个位置，需要研究。 模式串第一个位置不匹配，j应该重新指向模式串的哪个位置 模式串第二个位置不匹配，j应该重新指向模式串的哪个位置 …… 将j重新指向的位置整理记录下来，存储到数组中，就是Next数组，Next数组的下标代表着该模式串出现不匹配的位置，数组下标对应的值就是j重新指向的位置。 同时需要考虑另外一个问题，这个问题在上面的内容有所体现。就是模式串起始编号是0还是1。起始编号不同，Next数组不同，二者之间相差一个位置 在进行KMP算法之前，是需要先获取模式串的Next数组，以便使用。 3.1 起始位置：0 上图提供的示例不全，但足以说明当某个位置出现不匹配时，指针j重新定位的位置为：不匹配位置之前字符串的最大公共前后缀长度所对应的编号 首先，为什么首位是-1，因为模式串首位不匹配需要挪动的是指向主串的i指针，是特殊情况，这样在获取next数组值的时候发现是-1，就知道需要挪动i指针，然而在实现时，只需要判断j时候等于0即可，并不需要访问next[0]时候等于-1。 3.2 起始位置：1 4. NextVal数组 5. 代码 5.1 Next 5.1.1 模式串从0标号 代码实现所使用到的next数组并不是[上面](#3.1 起始位置：0)提到的next数组。这里的next数组是每一位的最长公共前后缀的长度。比如next[2]=2，表示模式串前三个包括第三个字符，它们的最长公共前后缀长度是2。所以，倘若是模式串j位置出现不匹配，那么j位置之前的字符的最长公共前后缀长度是next[j-1] 关于下面getNext方法，可以理解为自己匹配自己 // 获取该模式串每个位置的最大公共前后缀长度 private int[] getNext(char[] pattern) &#123; // 模式串长度 int len = pattern.length; int[] next = new int[len]; next[0] = 0; // i代表最长前后缀长度 int i = 0, j; for(j = 1; j &lt; len; j++) &#123; while(pattern[i] != pattern[j] &amp;&amp; i > 0) i = next[i - 1]; if(pattern[i] == pattern[j]) next[j] = ++i; else next[j] = 0; &#125; return next; &#125; // 模式串匹配kmp算法,匹配成功返回匹配的位置,失败则返回-1 public int kmp(char[] str, char[] pattern) &#123; // 这里的next数组是每个位置的最长公共前后缀的长度 // 比如next[2]表示0、1、2三个位置组成的字符串公共前后缀的最大长度 int[] next = getNext(pattern); // 主串的长度mainLen,i指向主串比较的位置,j指向模式串比较的位置 int mainLen = str.length, i = 0, j = 0; while(i &lt; mainLen) &#123; // 情况三: 主串不够长 if(mainLen - i &lt; pattern.length - j) break; // 情况一: 主串的字符与模式串字符相等 if(str[i] == pattern[j]) &#123; i++; j++; // 当j指向的位置已经超过模式串长度时,说明匹配成功,则返回模式串在主串中匹配成功的位置 if(j >= pattern.length) return i - pattern.length; &#125; else &#123; // 情况二: 出现不匹配 // 如果j是模式串0位置,特殊情况 if(j == 0) &#123; // 挪动主串指针i i++; &#125; else &#123; // 重定位到不匹配位置之前字符，最大公共前后缀长度 j = next[j - 1]; &#125; &#125; &#125; // 默认失败 return -1; &#125; 同时可以发现，倘若要得到上面提到的那种next数组，只需要将里面所有的元素后移一个位置，然后首位添-1即可。上图中最后面的1会被舍弃。 5.1.2 模式串从1标号 // 获取模式串的next数组 private int[] getNext(char[] pattern) &#123; // 模式串长度 int len = pattern.length; int[] next = new int[len]; next[1] = 0; // i代表最长前后缀长度 int i = 1, j; for(j = 2; j &lt; len; j++) &#123; while(pattern[i] != pattern[j] &amp;&amp; i > 1) i = next[i - 1]==0?1:next[i-1]; if(pattern[i] == pattern[j]) next[j] = i++; else next[j] = 0; &#125; // 倘若写上了这一步,下面的kmp中的最后一个else只需要写j = next[j]即可 // 倘若没有这一步,下面的kmp中的最后一个else需要写成j = next[j - 1] + 1 for(int k = next.length - 1; k > 1; k--) &#123; next[k] = next[k-1] + 1; &#125; return next; &#125; public int kmp(char[] str, char[] pattern) &#123; // 获取该模式串的next数组 int[] next = getNext2(pattern); // 主串的长度mainLen,i指向主串比较的位置,j指向模式串比较的位置 int mainLen = str.length, i = 0, j = 1; while(i &lt; mainLen) &#123; if(mainLen - i &lt; pattern.length - j) break; // 主串的字符与模式串字符相等 if(str[i] == pattern[j]) &#123; i++; j++; // 当j指向的位置已经超过模式串长度时,说明匹配成功,则返回模式串在主串中匹配成功的位置 if(j >= pattern.length) return i - pattern.length + 1; // 这里有变化 &#125; else &#123; // 如果模式串在j这个位置与主串i这个位置字符不相等,则需要通过next数组来重新定位指向模式串字符的j的值 if(j == 1) &#123; i++; &#125; else &#123; // 这里有变化,倘若getNext有最后一个for循环 j = next[j]; // 倘若getNext没有最后一个for循环需要下面这种写法 // j = next[j - 1] + 1; &#125; &#125; &#125; // 默认失败 return -1; &#125; 5.2 NextVal","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"串","slug":"串","permalink":"blog.silverbeats.cn/tags/%E4%B8%B2/"},{"name":"KMP","slug":"KMP","permalink":"blog.silverbeats.cn/tags/KMP/"}],"author":"silverbeats"},{"title":"算法设计与分析——分治法","slug":"算法设计与分析-分治法","date":"2020-09-19T23:48:47.000Z","updated":"2020-10-22T12:32:33.944Z","comments":false,"path":"算法设计与分析-分治法/","link":"","permalink":"blog.silverbeats.cn/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%88%86%E6%B2%BB%E6%B3%95/","excerpt":"","text":"分治法的基本思想是将一个规模为n的问题分解为k个规模较小的子问题，这些子问题互相独立且与原问题相同。递归的解决这些子问题，然后将各个子问题的解合并得到原问题。 1. 二分搜索法 最简单的想法是从头找到尾，进行遍历，时间复杂度为O(n)，而利用分治法思想，使用二分搜索法，可以将时间复杂度缩小为O(logn)，但是该方法有一个前提就是，这一个序列必须有序。 下面代码假设序列是非递减序列 递归写法 public int binarySearch(int[] arr, int from, int to, int target) &#123; // 这说明没有数字了,说明没找到,返回-1 if(to &lt; from) return -1; // 得到from至to中间位置的数字的下标 int midPos = (to + from) >> 1; // 如果找到了该数字,返回数组下标 if(arr[midPos] == target) &#123; return midPos; &#125; else if(arr[midPos] > target) &#123; // 如果中间的数字比目标值大,说明目标值值在中间值的左边 return binarySearch(arr, from, midPos - 1, target); &#125; else &#123; // 如果中间的数字比目标值大,说明目标值值在中间值的右边 return binarySearch(arr, midPos + 1, to, target); &#125; &#125; 非递归写法 public int binarySearch2(int[] arr, int target) &#123; // 两个指针指向target存在区域的左右边界,圈定范围 int left = 0, right = arr.length - 1; while(left &lt;= right) &#123; // 得到该范围的中间位置 int midPos = (right + left) >> 1; // 说明找到了 if(arr[midPos] == target) return midPos; // 如果中间值大,说明目标值在中间值左边,右边界right指针挪到midPos的前一个 else if(arr[midPos] > target) right = midPos - 1; // 如果中间值大,说明目标值在中间值左边,右边界left指针挪到midPos的后一个 else left = midPos + 1; &#125; // 找不到返回-1 return -1; &#125; 2. 大整数乘法 对于乘法，直接使用乘法的运算符会很方便，但是仅限于参加运算的整数能在计算机硬件对整数的表示范围内直接处理时才是合理的。当需要处理很大的整数时，无法在计算机硬件能直接表示的整数范围内进行处理，若用浮点数表示，只能得到近似值，计算结果中的有效位数也会受到限制。 同时，当XY分3块，4块乃至更多，只会越来越慢。当分两块时，初步版需要4次，改进版需要3次相乘；而分成3块，其初步版就需要9次，想要得到比分成2块改进版的3次更少的乘法次数是不可能的，更何况是16次乘法的分4块初步版。 同时下图所示的过程有前提条件： X,Y都是n位，且n是2的整数次幂，只有这样才能保证每次划分A,B,C,D四个部分位数保持一致 （A-B），(D-C)这个两个数也需要满足上面这一条要求。因为这两个数相乘也是需要递归使用同一个函数 然而前提条件很多，实际上在使用时，上面两个条件都很难达到。当落地时，是实现初步版，计算4次乘法。 这里进行说明，为什么X可以那样表示。 比如一个十进制数1234，一共4位，按照上面的样子进行划分成左右AB两部分，则1234 = 12 * 102 + 34，这里的10其实是进制 同理，案例中，XY都是二进制，如X = 1101，X = 11 * 22 + 01，1101的十进制是13，11的十进制是3，01的十进制是1，X = 3 * 4 + 1 = 13 2.1 O(n2)写法 // 因为数字很大,无法用某个整数数据类型表示,需要转换成整型数组,方便处理 public int[] NumToArr(String num) &#123; num = fliter(num); char[] temp = num.toCharArray(); int[] arr = new int[temp.length]; for (int i = 0; i &lt; temp.length; i++) &#123; arr[i] = Integer.parseInt(temp[i] + \"\"); &#125; return arr; &#125; // 倘若传进来的字符串num中有0开头,比如0123,,或者00123,需要将0去掉 public String fliter(String num) &#123; int pos0 = num.indexOf('0'); if(pos0 != 0) return num; StringBuilder sb = new StringBuilder(num); while(pos0 == 0) &#123; sb.deleteCharAt(pos0); pos0 = sb.indexOf('0' + \"\"); &#125; return sb.toString(); &#125; // O(n2)的大整数乘法 public String LargeIntegerMultiplication(int[] num1, int[] num2) &#123; int len1 = num1.length; int len2 = num2.length; int[] res = new int[len1 * len2]; int p = res.length - 1; for(int i = len1 - 1; i >= 0; i--) &#123; for(int j = len2 - 1; j >= 0; j--) &#123; res[p--] += num2[j] * num1[i]; &#125; p++; &#125; // 处理进制 for(int k = res.length - 1; k >= 0; k--) &#123; if(res[k] >= 10) &#123; res[k - 1] = res[k] / 10; res[k] %= 10; &#125; &#125; // 从后向前充填res数组，可能没有填满，导致前几位有0 StringBuilder sb = new StringBuilder(); // 从头向后遍历当遇到第一次非0数字后,flag为true boolean flag = false; for (int k = 0; k &lt; res.length; k++) &#123; if (res[k] != 0) flag = true; if(flag) sb.append(res[k]); &#125; return sb.toString(); &#125; 2.2 分治法版本的O(n2) 2.2.1 主体 这里使用字符串，方便截取获得ABCD // 大整数乘法 public String largeLongMultiply(String num1, String num2) &#123; // 存储num1乘num2的结果的数组 int[] res; // 只要有一个字符串数字长度为1,那么就可以直接相乘了 if (num1.length() == 1 || num2.length() == 1) &#123; // 相乘 res = mult(num1, num2); &#125; else &#123; // 因为num1和num2长度不一定相同,假设num1长度为a,num2长度为b,同样分成两部分 // num1 = A*10^(a/2) + B // num2 = C*10^(b/2) + D // num1*num2 = AC*10^(a/2+b/2) + BD + AD10^(a/2) + BC*10^(b/2) // 开始截取字符串,得到ABCD int halfNum1 = num1.length() >> 1; int halfNum2 = num2.length() >> 1; String A = num1.substring(0, halfNum1), B = num1.substring(halfNum1), C = num2.substring(0, halfNum2), D = num2.substring(halfNum2); // 开始相乘 String AC = largeLongMultiply(A, C), BD = largeLongMultiply(B, D), AD = largeLongMultiply(A, D), BC = largeLongMultiply(B, C); // 位移,相加并得到最终结果 res = arrAddArr( strNumToArr(BD), arrAddArr( arrAddArr( move(strNumToArr(AC), halfNum1 + halfNum2), move(strNumToArr(AD), halfNum1) ), move(strNumToArr(BC), halfNum2) ) ); &#125; // 处理进制 decimalism(res); // 处理首位0,并转成字符串返回 return arrToStr(filterZero(res)); &#125; 2.2.2 主体之外的函数 // 只有当str1或者str2的length为1时才会执行这里 private int[] mult(String str1, String str2) &#123; int[] a = new int[str1.length()]; int[] b = new int[str2.length()]; // 将两个字符串变为数组,并且每个元素都是int类型 for (int i = 0; i &lt; a.length; i++) a[i] = (int) str1.charAt(i) - 48; for (int i = 0; i &lt; b.length; i++) b[i] = (int) str2.charAt(i) - 48; int[] res = new int[Math.max(a.length, b.length) + 1]; // 二者进行相乘 if (a.length == 1) &#123; for (int i = 0; i &lt; b.length; i++) res[i] = b[i] * a[0]; &#125; else &#123; for (int i = 0; i &lt; a.length; i++) res[i] = a[i] * b[0]; &#125; // 返回乘积结果 return res; &#125; // 字符串数字变数组 public int[] strNumToArr(String str) &#123; int len = str.length(); int[] arr = new int[len]; for (int i = 0; i &lt; len; i++) arr[i] = (int) str.charAt(i) - 48; return arr; &#125; // 数组变字符串 private String arrToStr(int[] arr) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; arr.length; i++) &#123; sb.append(arr[i]); &#125; return sb.toString(); &#125; // arr数组所代表的数字扩大n位 private int[] move(int[] arr, int n) &#123; int len = arr.length; int[] res = new int[len + n]; System.arraycopy(arr, 0, res, 0, len); return res; &#125; // 两个数组相加 private int[] arrAddArr(int[] arr1, int[] arr2) &#123; int len1 = arr1.length, len2 = arr2.length;//123,12 // 这里还需要长度＋1是因为：900 + 900 = 1800类似这种情况 // 另外两个相加的数组的长度不一定一样 int[] res = new int[Math.max(len1, len2) + 1]; int p = res.length - 1; int dist = len1 - len2; if (dist &lt; 0) &#123; // arr1短 for (int i = len1 - 1; i >= 0; i--) &#123; res[p--] = arr1[i] + arr2[i - dist]; &#125; for (int i = -dist - 1; i >= 0; i--) &#123; res[p--] = arr2[i]; &#125; &#125; else if (dist > 0) &#123; // arr2短 for (int i = len2 - 1; i >= 0; i--) &#123; res[p--] = arr1[i + dist] + arr2[i]; &#125; for (int i = dist - 1; i >= 0; i--) &#123; res[p--] = arr1[i]; &#125; &#125; else &#123; for (int i = arr1.length - 1; i >= 0; i--) &#123; res[p--] = arr1[i] + arr2[i]; &#125; &#125; // 处理进制 decimalism(res); // 再次考虑,当res[0]为0的情况 return filterZero(res); &#125; // 进制处理 private void decimalism(int[] arr) &#123; // 处理进制 for (int k = arr.length - 1; k > 0; k--) &#123; if (arr[k] >= 10) &#123; arr[k - 1] += arr[k] / 10; arr[k] %= 10; &#125; &#125; &#125; // 处理数组arr首位为0的情况 private int[] filterZero(int[] arr) &#123; if (arr[0] != 0) return arr; // 从头遍历arr,当出现第一个不为0的数字后,会变成true boolean flag = false; // 用来统计非0数字前面,0的个数 int k = 0; for (int i = 0; i &lt; arr.length &amp;&amp; !flag; i++) &#123; if (arr[i] != 0) flag = true; // 倘若还没有遇到第一个不为0的数字,计数+1 if (!flag) k++; &#125; // 比如[0,0,1,2,3],经过统计k=2,那么最终的finalRes长度应该是3 = arr.length - k int[] finalRes = new int[arr.length - k]; // 开始拷贝的位置下标应该是k System.arraycopy(arr, k, finalRes, 0, finalRes.length); return finalRes; &#125; 3. Strassen矩阵乘法 矩阵乘法，线性代数常见，假设两个矩阵同型AB，都是n×n的矩阵，C = AB，则在计算矩阵C时，C中每个元素都需要进行n次乘法和n-1次加法，最终求出C，n2个元素需要的计算时间复杂度是O(n3) 3.1 O(n3)写法 // 矩阵m1,a行b列;矩阵m2,c行d列 public int[][] matrixMultiply(int[][] m1, int[][] m2) &#123; // m1的行数,m1的列数 int m1Col = m1.length, m1Row = m1[0].length; // m2的行数,m2的列数 int m2Col = m1.length, m2Row = m2[0].length; // 检查矩阵相乘的条件 if (m1Row != m2Col) throw new RuntimeException(\"矩阵无法相乘\"); // 新建一个存储结果的矩阵 int[][] res = new int[m1Col][m2Row]; // 遍历m1的第i行 for(int i = 0; i &lt; m1Col; i++) &#123; // 遍历m2的第j列 for(int j = 0; j &lt; m2Row; j++) &#123; // 遍历m2的第k行 for(int k = 0; k &lt; m2Col; k++) &#123; res[i][j] += m1[i][k] * m2[k][j]; &#125; &#125; &#125; return res; &#125; 3.2 分治思想 假设条件： 两个矩阵都是n×n n都是2的幂 4. 棋盘覆盖 5. 合并排序 其实就是归并排序，相关代码可以查看排序 6. 快速排序 相关代码可以查看排序 快速排序的运行时间与每次划分是否对称有关，划分的最坏情况就是一边1个元素，另一边n-1的元素，当每次都划分对称的时候，时间复杂度是O(nlogn)，当每次划分都最坏的时候，时间复杂度是O(n2)，在排序提到，对于快速排序来说，越有序越慢，因为越有序，每次划分出现最坏情况的可能性就越大。 为了尽可能每次划分都较为对称，可以采用随机选择策略的快速排序算法。快速排序对于基准的选择都是待排序序列的第一个元素，随机选择意思就是说，在进行快速排序之前，先从序列中随机挑一个元素与序列首位进行位置交换，这样快排时的基准就是随机的了。 // 实现随机选择基准 // (int)(Math.random()*(high - low + 1))范围：[0,high - low + 1) // (int)(Math.random()*(high - low + 1)) + low范围：[low,high + 1)，即[low, high] private int RandomizedPartition(int[] arr, int low, int high) &#123; // i是从low-high随机挑选出来的下标 int i = (int)(Math.random()*(high - low + 1)) + low; // 将i位置的元素与待排序范围的首位进行交换 int temp = arr[low]; arr[low] = arr[i]; arr[i] = temp; return QSort_Partition(arr, low, high); &#125; // 快速排序 public void QSort(int[] arr, int low, int high) &#123; if (low &lt; high) &#123; int piovtpos = RandomizedPartition(arr, low, high); // 排左边 QSort(arr, low, piovtpos - 1); // 排右边 QSort(arr, piovtpos + 1, high); &#125; &#125; // 一趟快速排序 // 参数1：数组,参数2：数组的起始位置,参数3：数组的终了位置,闭区间 private int QSort_Partition(int[] arr, int left, int right) &#123; // 指定基准 int base = arr[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; arr[right] >= base) right--; if (left &lt; right) arr[left] = arr[right]; while (left &lt; right &amp;&amp; arr[left] &lt; base) left++; if (left &lt; right) arr[right] = arr[left]; &#125; arr[left] = base; return left; &#125; 7. 线性时间选择 给定一串数字，从中选出第k小，时间复杂度要求是O(n)，即线性时间选择。 7.1 利用堆排序获得第k小 易知，倘若要知道第k小的关键字，那么只需要利用小根堆，进行k次堆调整，即可得到第k小的关键字。 其中adjustHeap函数的代码可见排序，其中adjustHeap函数是调整成大根堆，只需要将循环中两个if判断条件中的小于号改成大于号，即可实现调整为小根堆的功能 public int heapSortFindK(int[] arr, int k) &#123; // 存储arr,目的是堆排序过程中不改变原数组 int[] temp = arr.clone(); int len = temp.length; // 首先构建小根堆 for (int pos = len / 2 - 1; pos >= 0; --pos) &#123; //从第一个非叶子结点从下至上，从右至左调整结构 adjustHeap(temp, pos, len); &#125; // 经过上一步可以得到小根堆,现在开始排序 for (int j = len - 1; j >= len - k; --j) &#123; //将堆顶元素与末尾元素进行交换 swap(temp, 0, j); //重新对堆进行调整 adjustHeap(temp, 0, j); &#125; return temp[len - k]; &#125; 7.2 利用快速排序获得第k小 每一次快排都会选则一个基准，将其排到它的最终位置，而第k小在排好序的序列中排在第k位。所以，可以通过比较每次快排后基准的最终位置与k，来获取第k小 public int QSortFindK(int[] arr, int k, int start, int end) &#123; // 首先,一趟快速排序,确定一个关键字的最终位置 int piovtpos = QSort_Partition(arr, start, end); // 易知，为了使快速排序的效率变高，可以利用上述随机策略法。 // int piovtpos = RandomizedPartition(arr, start, end); if(piovtpos + 1 == k) // 倘若该数字正好是第k小 return arr[piovtpos]; else if(piovtpos + 1 > k) &#123; // 说明目标在该数字的左边 return QSortFindK(arr, k, start, piovtpos - 1); else return QSortFindK(arr, k, piovtpos + 1, end); &#125; 8. 最接近点对问题 平面中有n个点，求出哪两个点之间的距离是最短的。很容易想到O(n2)的写法，倘若利用分治法，可以将时间复杂度降低为O(nlog2n) 9. 循环赛日程表","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"算法设计与分析","slug":"算法/算法设计与分析","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"}],"tags":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"分治法","slug":"分治法","permalink":"blog.silverbeats.cn/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"}],"author":"silverbeats"},{"title":"最短路径","slug":"最短路径","date":"2020-09-19T01:53:19.000Z","updated":"2020-10-22T12:26:27.025Z","comments":false,"path":"最短路径/","link":"","permalink":"blog.silverbeats.cn/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/","excerpt":"","text":"1. 迪杰斯特拉Dijkstra算法详解 1.1 完整代码 public void Dijkstra(int[][] graph, int start) &#123; // 当起点无法达到该点时,路径长度是无穷大,这里用整型最大值代替 int MAXDIST = Integer.MAX_VALUE; int vertexNum = graph.length; /* * 1. Dijkstra算法需要三个辅助数组 **/ boolean[] isVisited = new boolean[vertexNum]; int[] path = new int[vertexNum]; int[] dist = new int[vertexNum]; /* * 2. 初始化 **/ for (int i = 0; i &lt; vertexNum; i++) &#123; dist[i] = graph[start][i]; if (graph[start][i] &lt; MAXDIST) &#123; path[i] = start; &#125; else &#123; path[i] = -1; &#125; &#125; // start起点默认已经被访问 isVisited[start] = true; // start没有前驱结点,因为它是开始的位置 path[start] = -1; /* * 3. 迪杰斯特拉算法核心 **/ for (int i = 0; i &lt; vertexNum - 1; i++) &#123; // 存储最短路径 int minPath = MAXDIST; // 存储距离最小的点的数组下标 // 倘若这里minIndex不赋初始值,在后面isVisited[minIndex] = true会报错 // 因为后面的循环找最小值可能找不到 int minIndex = start; // 这个循环目的是:从未访问的节点中找到路径最短的那个 for (int j = 0; j &lt; vertexNum; j++) &#123; // 倘若这个节点没有访问,并且该点小于最短路径 if (!isVisited[j] &amp;&amp; dist[j] &lt; minPath) &#123; minPath = dist[j]; minIndex = j; &#125; &#125; if (minIndex != start) isVisited[minIndex] = true; for (int j = 0; j &lt; vertexNum; j++) &#123; if (!isVisited[j] &amp;&amp; graph[minIndex][j] != MAXDIST &amp;&amp; dist[minIndex] + graph[minIndex][j] &lt; dist[j] &amp;&amp; minIndex != start) &#123; dist[j] = dist[minIndex] + graph[minIndex][j]; path[j] = minIndex; &#125; &#125; &#125; &#125; 1.2 分段解读 1.2.1 完整过程图示 1.2.2 辅助数组说明 // 用来记录每个节点是否被访问 boolean[] isVisited = new boolean[vertexNum]; // 用来存储到达某个点最短路径的前一个节点下标 // 比如上图第1次循环,到达顶点4的最短路径是0-2-4,那么path[4]存放下标2 // 这个数组的每个值会不断变动 int[] path = new int[vertexNum]; // 存放到某个顶点的最短路径长度 // 比如顶点4,dist[4]从8,最后修改成7,这个数组的每个值会不断变动 int[] dist = new int[vertexNum]; 1.2.3 初始化说明 for (int i = 0; i &lt; vertexNum; i++) &#123; dist[i] = graph[start][i]; // 这一步其实可以不用,声明boolean数组时默认就是false // isVisited[i] = false; // start点到i有路径,这里面包含了start自己到自己 // path[start]=start,这是不对的,start没有前驱节点,应该存-1,循环结束之后会做处理 if (graph[start][i] &lt; MAXDIST) &#123; path[i] = start; &#125; else &#123; // 没有前驱节点的意思,当前以start为起点,到不了i这个点 path[i] = -1; &#125; &#125; // start起点默认已经被访问 isVisited[start] = true; // start没有前驱结点,因为它是开始的位置 path[start] = -1; 1.2.4 算法核心说明 for (int i = 0; i &lt; vertexNum; i++) &#123; // 存储最短路径 int minPath = MAXDIST; // 存储距离最小的点的数组下标 // 倘若这里minIndex不赋初始值,在后面isVisited[minIndex] = true会报错 // 因为后面的循环找最小值可能找不到 int minIndex = start; // 这个循环目的是:从未访问的节点中找到路径最短的那个 for (int j = 0; j &lt; vertexNum - 1; j++) &#123; // 倘若这个节点没有访问,并且该点小于最短路径 if (!isVisited[j] &amp;&amp; dist[j] &lt; minPath) &#123; minPath = dist[j]; minIndex = j; &#125; &#125; if (minIndex != start) isVisited[minIndex] = true; for (int j = 0; j &lt; vertexNum; j++) &#123; if (!isVisited[j] &amp;&amp; graph[minIndex][j] != MAXDIST &amp;&amp; dist[minIndex] + graph[minIndex][j] &lt; dist[j] &amp;&amp; minIndex != start) &#123; dist[j] = dist[minIndex] + graph[minIndex][j]; path[j] = minIndex; &#125; &#125; &#125; 内层循环第一个for比较简单，目的是找到一个点，该点满足：①未被访问，②有路径能访问，③到达改点路径值最小 内层循环第二个详解见下图： ❥(^_-)Tip： 当你使用某个数据类型的最大值作为无穷大，表示无该路径时，需要注意dist[minIndex] + graph[minIndex][j] &lt; dist[j]，倘若graph[minIndex][j]是无穷大，再加上一个数字后，会超出该类型的表示范围，变成一个负数，从而达成这个判断条件，执行if代码块中语句。这并不是我们想要的。所以需要在if中需要添加graph[minIndex][j] != MAXDIST这句话，避免上述情况发生 1.3 思考 首先，迪杰斯特拉算法能解决单源并且没有负权值边的最短路径问题，那么倘若出现负权值边，该算法不能求解出最短路径的原因是什么 1.3.1 尝试一下 当把1-&gt;2的权值改为-3后，继续走一遍之前的代码，就可以发现问题。 当i = 1时，即第二次循环，此时的minIndex为1，当j = 2时，根据if条件，因为isVisited[2]是之前访问过的点，所以不会执行if语句块中的代码，即便dist[minIndex] + graph[minIndex][j] &lt; dist[j]，5 + (-3) &lt; 3 那么倘若if中没有!isVisited[j]这个判断是否就可以了呢？ 根据上图，可以看到path数组是没有问题的，但是问题出在了dist[4]上。dist[4]应该为6，但却是7，这里是因为什么原因导致的？ 手动模拟一遍过程后不难发现，i=0的第一次循环修改了dist[4]和path[4]；在i=1的第二次循环，到达节点2的最短路径发生变化，但是没有任何的机会去修改以2为前驱的点的dist数组。 所以在第二个for循环中再添加一个循环，倘若某个点x的最短路径发生变化，去找以x为前驱的其他点y，看看y这个点的最短路径有没有因为x的变化而缩短。 for (int j = 0; j &lt; vertexNum; j++) &#123; if (graph[minIndex][j] != MAXDIST &amp;&amp; dist[minIndex] + graph[minIndex][j] &lt; dist[j] &amp;&amp; minIndex != start) &#123; dist[j] = dist[minIndex] + graph[minIndex][j]; path[j] = minIndex; // 在遍历一遍path数组 for(int k = 0; k &lt; vertexNum; k++) &#123; // 如果path数组的某个点的前驱节点正好是修改长度的点的话 if(path[k] == j &amp;&amp; dist[k] > dist[j] + graph[j][k]) &#123; dist[k] = dist[j] + graph[j][k]; &#125; &#125; &#125; &#125; 之后的结果就没有问题了： 2. 弗洛伊德Floyd算法详解 其实倘若涉及到负权值，会选择用Floyd算法，而且，更为强大的是，Floyd能够求出各个顶点到其他点的最短距离。 我不能呼吸了……= = 2.1 完整代码 public void Floyd(int[][] graph) &#123; int vertexNum = graph.length; // path数组,用来存储路径 int[][] path = new int[vertexNum][vertexNum]; // 初始化 for (int i = 0; i &lt; vertexNum; i++) &#123; for(int j = 0; j &lt; vertexNum; j++) path[i][j] = -1; &#125; for(int i = 0; i &lt; vertexNum; i++) &#123; for(int j = 0; j &lt; vertexNum; j++) &#123; for(int k = 0; k &lt; vertexNum; k++) &#123; if(graph[j][i] == Integer.MAX_VALUE || graph[i][k] == Integer.MAX_VALUE) continue; int temp = graph[j][i] + graph[i][k]; if(graph[j][k] > temp) graph[j][k] = temp; &#125; &#125; &#125; &#125; 举例：顶点0到4的最短路径 graph(0,4)的数字是6，说明最短路径长度是6，那么该怎么走呢。这是需要看path数组 path(0,4)为2，说明想要到顶点4需要经过顶点2，路径0-&gt;2-&gt;4，此时再看path(0,2)为1，说明想要从0到2需要经过顶点1，路径变为0-&gt;1-&gt;2-&gt;4 关于代码的详细描述过程，见文章：Floyd-傻子也能看懂的弗洛伊德算法（转）","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"最短路径","slug":"最短路径","permalink":"blog.silverbeats.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"blog.silverbeats.cn/tags/Dijkstra/"},{"name":"Floyd","slug":"Floyd","permalink":"blog.silverbeats.cn/tags/Floyd/"}],"author":"silverbeats"},{"title":"hexo相关命令语法","slug":"hexo相关命令语法","date":"2020-09-17T04:44:15.000Z","updated":"2020-10-21T06:24:35.698Z","comments":false,"path":"hexo相关命令语法/","link":"","permalink":"blog.silverbeats.cn/hexo%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E8%AF%AD%E6%B3%95/","excerpt":"","text":"1. 相关命令 #初始化一个hexo博客 hexo init blog #创建新页面 hexo new page 页面名 #清理之前生成的旧文件 hexo clean #重新生成静态文件 下面是简写 hexo generate hexo g #本地预览 下面是简写 hexo server hexo s #合并写法 hexo clean | hexo g | hexo s #通过git提交到仓库,需要配置hexo项目的_config.yml文件 hexo deploy hexo d #当安装七牛云同步插件后,可以通过如下命令将hexo根目录下的static文件夹同步到七牛云 hexo qiniu sync #或者 hexo qiniu s #或者 hexo qiniu sync2 #或者 hexo qiniu s2 2. 引用站内文章 &#123;% post_link 文章文件名（不要后缀） 文章标题（可选） %&#125; 3. 引用图片 3.1 引用七牛云图片 &#123;% qnimg 图片.格式 alt:这是图片 title:这是图片 %&#125; 不过这种方式引用图片，还是相当于本地存储，之后引用的图片会出现在需要上传的public目录中，还是会占用空间。 3.2 引用本地图片 倘若hexo项目的配置文件中将post_asset_folder设置为true，可以通过以下方式来引入图片，需要将example放入source/_post下的文章同名文件夹下。 &#123;% asset_path slug %&#125; &#123;% asset_img slug [title] %&#125; &#123;% asset_link slug [title] %&#125; &#123;% asset_img example.jpg This is an example image %&#125;","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"blog.silverbeats.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"blog.silverbeats.cn/tags/hexo/"}],"author":"silverbeats"},{"title":"排序","slug":"排序","date":"2020-09-16T14:17:31.000Z","updated":"2020-10-22T12:23:42.653Z","comments":true,"path":"排序/","link":"","permalink":"blog.silverbeats.cn/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"1. 插入排序 1.1 直接插入排序 直接插入排序，思想较为简单。 可以类比平常打扑克抓牌的过程。每次抓一张牌时，都会将这张牌与之前手里的牌（之前手里的牌是有序的）进行比较（从左向右比，或者从右向左比），得到一个最终的插入位置，然后插入。 // 直接插入排序, 假定前面是有序的，从乱序的后面取一个数插入有序的前面 public void insertSort(int[] arr) &#123; int len = arr.length; if (len == 0 || len == 1) return; // 进行插入排序 for (int i = 1; i &lt; len; i++) &#123; for (int j = i; j > 0; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; swap(arr, j, j - 1); &#125; &#125; &#125; &#125; // 交换 private void swap(int[] arr, int a, int b) &#123; int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125; 上面的代码可以再简化一下： // 直接插入排序, 假定前面是有序的，从乱序的后面取一个数插入有序的前面 public void insertSort(int[] arr) &#123; int len = arr.length; if (len == 0 || len == 1) return; // 进行插入排序 for (int i = 1; i &lt; len; i++) &#123; for (int j = i; j > 0 &amp;&amp; arr[j] &lt; arr[j - 1]; j--) swap(arr, j, j - 1); &#125; &#125; 1.2 折半插入排序 直接插入排序确定位置是通过将待排序的元素，与前面有序的序列一个个比较过去，从而得到最终的插入位置。那么，因为是顺序存储，利用数组实现排序，可以对前面的有序序列使用折半查找来确定最终插入位置。 public void binaryInsertSort(int[] arr) &#123; int len = arr.length; if (len == 0 || len == 1) return; // low high mid用于折半查找 int low, high, mid; for (int i = 1; i &lt; arr.length; i++) &#123; low = 0; high = i - 1; while (low &lt;= high) &#123; // (high+low)/2 这样的写法可能会超出int的表示范围 mid = low + ((high - low) >> 1); if (arr[mid] &lt; arr[i]) low = mid + 1; else high = mid - 1; &#125; // high + 1就是插入的位置 int temp = arr[i]; // 找到插入位置后,对元素进行挪动 for (int j = i - 1; j > high; j--) arr[j + 1] = arr[j]; // 将待排序的元素插入找到的位置 arr[high + 1] = temp; &#125; &#125; 1.3 希尔排序 希尔排序又称为缩小增量排序，当增量为1时，其实就是直接插入排序。增量的选取一般两种方案： 希尔提出，对数组长度不断折半。比如数组长度是32，则增量dk分别是：16,8,4,2,1 帕佩尔诺夫和斯塔舍维奇提出，dk = 2k + 1，dk &lt; 数组长度，k ≥ 0。比如数组长度是32，此时k 只能从4开始，则k = 4，dk = 17；k = 3，dk = 9；k = 2，dk = 5；k = 1，dk = 3；此时还需要额外添加dk = 1，算是一个兜底作用。 // 希尔排序 public int[] shellSort(int[] arr) &#123; int len = arr.length; if (len == 0 || len == 1) return arr; int dk = len >> 1; while (dk != 0) &#123; shell_InsertSort(arr, dk); // shell_BinaryInsertSort(arr, dk); dk = dk >> 1; &#125; return arr; &#125; /** * @Title: shell_InsertSort * @Description: 希尔排序，直接插入法进行排序 * @param ar: 数组 * @param dk: 间隔 * @return: void */ private void shell_InsertSort(int[] arr, int dk) &#123; int len = arr.length; int i, j; for (i = dk; i &lt; len; i++) &#123; int temp = arr[i]; for (j = i - dk; j >= 0 &amp;&amp; arr[j] > temp; j -= dk) &#123; arr[j + dk] = arr[j]; arr[j] = temp; &#125; &#125; &#125; /** * @Title: shell_BinaryInsertSort * @Description: 希尔排序，折半插入法进行排序 * @param arr: 数组 * @param dk: 间隔 * @return: void */ private void shell_BinaryInsertSort(int[] arr, int dk) &#123; int i, j, high, low, mid, temp; for (i = dk; i &lt; arr.length; i++) &#123; low = i % dk; high = i - dk; while (low &lt;= high) &#123; mid = low + (high - low) / 2; if (arr[mid] &lt; arr[i]) low = mid + dk; else high = mid - dk; &#125; temp = arr[i]; // high + dk 即为插入的位置 for (j = i - dk; j > high; j -= dk) arr[j + dk] = arr[j]; arr[high + dk] = temp; &#125; &#125; 后面那个通过折半插入法进行排序纯属练手，效率远远不及直接插入法希尔排序 前者，规模1W，20次，19ms 前者，规模10W，20次，187ms 后者，规模1W，20次，129ms 后者，规模10W，20次，10761ms 估计是在dk较小的时候，序列基本有序，折半插入的话是不管有没有序都得比较那么多次，而直接插入是越有序越快。 2. 选择排序 2.1 堆排序 堆又分大根堆和小根堆，倘若要升序，选择大根堆，倘若要降序，选择小根堆。 大根堆：根节点的数字不小于左右孩子的值 小根堆：根节点的值不大于左右孩子的值 堆排序是把一个数组，看做是一颗完全二叉树，排序步骤： 先对乱序的数组建立大根堆，可以得到数组的第一个元素（看做完全二叉树的话就是根节点）就是最大的 将其与数组最后面的那个值交换，然后重新调整，变为大根堆 依次类推 // 堆排序 public void heapSort(int[] arr) &#123; // 首先构建大根堆 for(int pos = arr.length/2 - 1; pos >= 0; --pos) &#123; //从第一个非叶子结点从下至上，从右至左调整结构 adjustHeap(arr, pos, arr.length); &#125; // 经过上一步可以得到大根堆,现在开始排序 for(int j = arr.length - 1; j > 0; --j) &#123; //将堆顶元素与末尾元素进行交换 swap(arr,0, j); //重新对堆进行调整 adjustHeap(arr,0, j); &#125; &#125; // 调整为大根堆 // arr是要调整的数组, i是要调整的数组下标, length是调整的范围 private void adjustHeap(int[] arr, int pos, int length) &#123; // 临时存储被调整的数组数据 int temp = arr[pos]; // pos是被调整元素的数组下标, 2*pos+1 是其左孩子 2*pos + 2是其右孩子 for(int i = pos*2 + 1; i &lt; length; i = i*2 + 1) &#123; /* 前面的判断条件保证它的右孩子是无序的, 在堆排序过程中会将最大值不断放到后面, length就是限制条件,可以通过这个条件让有序的右孩子不被波及 这个if保证i的下标对应的值是两个孩子中最大的那一个 */ if(i + 1 &lt; length &amp;&amp; arr[i] &lt; arr[i + 1]) &#123; i++; &#125; // 如果根节点小于它的孩子,则交换 if(temp &lt; arr[i]) &#123; // 交换根节点和它孩子的值 swap(arr, pos, i); // 因为经过了调整,当被调整的节点挪了位置,可能会导致后面的序列出问题,所以需要让pos定到i这个位置 pos = i; &#125; else &#123; break; &#125; &#125; &#125; 2.2 简单选择排序 思路简单：每次选择最大排到后面，或者每次选择最小的排到最前面 public void selectSort(int[] arr) &#123; // 每次过滤一遍数组将最小值放到前面 int i, j, min; for (i = 0; i &lt; arr.length - 1; i++) &#123; min = i; // 假定第i个位置最小 for (j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) min = j; &#125; if (i != min) swap(arr, i, min); &#125; &#125; 下面是另外一种做法，是每次将最小的放到最前面，最大的放到最后面 public void selectSort_2(int[] arr) &#123; // 每次过滤一遍数组将最小值放到前面 // 将最大的数字放到最后面 int i, j, min, max, lastPos; for (i = 0; i &lt;= arr.length >> 1; i++) &#123; min = max = i; lastPos = arr.length - i - 1; for (j = i + 1; j &lt;= lastPos; j++) &#123; if (arr[j] &lt; arr[min]) min = j; if (arr[j] > arr[max]) max = j; &#125; if (i != min) swap(arr, i, min); if (lastPos != max) swap(arr, max, lastPos); &#125; &#125; 前者，规模10W，20次，54408ms，2720ms/次 后者，规模10W，20次，53938ms，2697ms/次 呵呵…… 简单选择排序有两个版本，一种是如同上面的两种写法一样，将最大值（最小值）与序列最后（第一）个进行调换位置，这个版本成为交换版 另一种版本是将最大值（最小值）插入到序列的最后（最前）面，成为插入版。 区别在于： 交换版不稳定，插入版稳定 倘若序列顺序存储，插入版会涉及到大批量的元素挪动，不如交换版来的划算 倘若序列是链式存储，插入版会划算一些 3. 交换排序 3.1 冒泡排序 冒泡排序很经典，每次排序都能讲最大的数字排到最后，或者将最小的数字排到最前面 听说冒泡是毒瘤，比较次数和交换次数超级多 public int[] bubbleSort(int[] arr) &#123; int len = arr.length; if (len == 0 || len == 1) return arr; for (int i = 0; i &lt; len; i++) &#123; // 倘若内循环没有进行交换,则整个序列有序,会直接终止整个排序,是一个优化的地方 boolean flag = false; for (int j = 0; j &lt; len - i - 1; j++) &#123; if (arr[j] > arr[j + 1]) &#123; swap(arr, j, j + 1); flag = true; &#125; &#125; if (!flag) break; &#125; return arr; &#125; 继续发挥，双向冒泡 // 双向冒泡 public void bubble2Ways(int[] arr) &#123; int left = 0, right = arr.length - 1; boolean flag; while(left &lt; right) &#123; flag = false; // 从左往右将最大的数字挪到最右边 for(int i = left; i &lt; right; ++i) &#123; if(arr[i] > arr[i + 1])&#123; swap(arr, i, i + 1); flag = true; &#125; &#125; // 挪到结束后right-- --right; // 从右往左将最小的数字挪到最左边 for(int j = right; j > 0; --j) &#123; if(arr[j] &lt; arr[j - 1])&#123; swap(arr, j, j - 1); flag = true; &#125; &#125; ++left; if(!flag)break; &#125; &#125; 前者，规模1W，20次，1362ms，68ms/次 后者，规模1W，20次，1445ms，72ms/次 前者，规模10W，20次，303042ms，5min，15152ms/次 后者，规模10W，20次，202945ms，3min23s，10147ms/次 ……还是有点提高的 3.2 快速排序 利用分而治之的思想。每一次快速排序会实现这样的结果： 该数字的左边都比它小 该数字的右边都不小于它 每一次排序都会确定一个数的最终位置 // 快速排序 public void QSort(int[] arr, int low, int high) &#123; if (low &lt; high) &#123; int piovtpos = this.QSort_Partition(arr, low, high); // 排左边 QSort(arr, low, piovtpos - 1); // 排右边 QSort(arr, piovtpos + 1, high); &#125; &#125; // 一趟快速排序 // 参数1：数组,参数2：数组的起始位置,参数3：数组的终了位置,闭区间 private int QSort_Partition(int[] arr, int left, int right) &#123; // 指定基准 int base = arr[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; arr[right] >= base) right--; if (left &lt; right) arr[left] = arr[right]; while (left &lt; right &amp;&amp; arr[left] &lt; base) left++; if (left &lt; right) arr[right] = arr[left]; &#125; arr[left] = base; return left; &#125; 平均时间复杂度为nlogn的算法中，如：堆排序，快速排序，希尔排序，归并排序中，快速排序前面系数最小 规模1W，20次，15ms 规模10W，20次，359ms 快速排序有其特点：越有序越慢，越无序越快 4. 二路归并排序 /** * @Title: mergeSort * @Description: 归并排序 * @param arr: int类型数组 * @return: void */ public void mergeSort(int[] arr, int leftStart, int rightBound) &#123; if(leftStart == rightBound)return; if(leftStart > rightBound || leftStart &lt; 0 || rightBound &lt; 0)throw new RuntimeException(\"error\"); int mid = leftStart + ((rightBound - leftStart) >> 1); mergeSort(arr,leftStart,mid); mergeSort(arr,mid+1,rightBound); merge(arr, leftStart, mid+1, rightBound); &#125; /** * @Title: merge * @Description:一次归并,将两个有序的数组合并，仍有序 * @param arr 数组 * @param leftStart 第一个数组的左边界开始的位置 * @param rightStart 第二个数组的左边界开始的位置 * @param rightBound 第二个数组的右边界结束的位置 * @return: void */ private void merge(int[] arr, int leftStart, int rightStart, int rightBound) &#123; // 合并思想：新建一个数组，每次将小的数字放到新建的数组中 int i = leftStart, j = rightStart, k = 0; int[] tempArr = new int[rightBound - leftStart + 1]; while(i &lt; rightStart &amp;&amp; j&lt;= rightBound) tempArr[k++] = arr[i] &lt;= arr[j]?arr[i++]:arr[j++]; // 倘若还有剩余 while(i &lt; rightStart) tempArr[k++] = arr[i++]; while(j &lt;= rightBound) tempArr[k++] = arr[j++]; // 此时tempArr就是合并好有序的数组，对原始数组进行覆盖 for(int p = leftStart; p &lt;= rightBound; p++) arr[p] = tempArr[p - leftStart]; // 对原数组进行覆盖可以使用System.arraycopy,可以提高效率 /* if (i &lt; rightStart) &#123; System.arraycopy(arr, i, tempArr, k, rightStart - i); k += (rightStart - i); &#125; if (j &lt;= rightBound) &#123; System.arraycopy(arr, j, tempArr, k, rightBound - j + 1); &#125; System.arraycopy(tempArr, 0, arr, leftStart, tempArr.length); */ &#125; 规模1W，20次，32ms 规模10W，20次，241ms 5. 桶排序 5.1 基数排序 5.1.1 完整代码（只适用于非负数） // 基数排序 public void radixSort(int[] arr) &#123; int len = arr.length; int arrMax = getMinMax(arr)[1]; // 从个位开始,对数组进行排序 // exp = 1, 按照个位 // exp = 10, 按照十位 // exp = 100, 按照百位 for (int exp = 1; arrMax / exp > 0; exp *= 10) &#123; int i; // 存储被排序数组的临时数组 int[] output = new int[arr.length]; // 桶,因为不管是什么数字,个数十位不管是哪一位,都是0-9，所以桶数组的长度是10 int[] buckets = new int[10]; // 将数据出现的次数进行统计 for (i = 0; i &lt; len; i++) &#123; buckets[(arr[i] / exp) % 10]++; &#125; // 转为累加数组。目的是让更改后的buckets[i]的值，是该数据在output中的位置 for (i = 1; i &lt; 10; i++) &#123; buckets[i] += buckets[i - 1]; &#125; // 将数据存储到临时数组output中 for (i = len - 1; i >= 0; i--) &#123; output[buckets[(arr[i] / exp) % 10] - 1] = arr[i]; buckets[(arr[i] / exp) % 10]--; &#125; // 将排序好的数组赋值给arr for (i = 0; i &lt; len; i++) arr[i] = output[i]; &#125; &#125; 5.1.2 分段说明 分段说明举例说明的乱序数组为：{53, 3, 542, 748, 14, 214, 154, 63, 616}，为了更好的说明过程，for循环的说明将会以个位排序，演示整个过程 5.1.2.1 外层循环 arrMax是整个数组中最大的数字，同时也是位数最多的那个数字，比如arrMax是748，那么需要进行3次循环，分别对整个数组的个位，十位，百位来进行排序，故，外层循环的次数是由arrMax的位数来决定的。 for (int exp = 1; arrMax / exp > 0; exp *= 10) &#123; …… &#125; exp = 1，arrMax = 748/1 = 748&gt; 0，对个位进行排序 exp = 10，arrMax = 748/10 = 74 &gt; 0，对十位进行排序 exp = 100，arrMax = 748/100 = 8 &gt; 0，对百位进行排序 exp = 1000，arrMax = 748/1000 = 0 &gt; 0，false，中止外层循环 5.1.2.2 内部循环两个辅助数组的作用 首先，先来看一下，我们熟知的基数排序的过程： 很清楚能知道，其中一个辅助数组为buckets长度为10，即为上面的桶。但问题是，模拟的时候，是将每个数字放入桶中，然后取出的顺序是放入的先后顺序一致，颇有一种每个桶里面放的都是一个队列，先进先出，这样想倒是很符合，很自然，可以声明一个Object[]数组，之后每个位置存储一个队列，队列不需要自己实现，可以使用java.util包下的Queue实现类，之后操作就比较简单了，完全就和手动模拟的过程是一致的。（倘若用C语言，这样想能恶心死你= =） 但上面这种考虑虽然简单，但空间复杂度肯定是小不了的，这里给出的是另外一种比较巧妙的解决方案。可见后面更为详细的过程图。 // 存储被排序数组的临时数组 int[] output = new int[arr.length]; // 桶,因为不管是什么数字,个数十位不管是哪一位,都是0-9，所以桶数组的长度是10 int[] buckets = new int[10]; 5.1.2.3 内部四for第一for: 将数据出现的次数进行统计 (arr[i]/exp)%10的目的是要获得目标位置的数字。 首先，将需要的那一位变为个位，比如214，想要取得十位1，此时的exp = 10，先要除exp，得到21，这样想要的十位数字1就挪到了个位，之后让21 % 10，即可得到想要的十位数字1 这里的for循环其实目的是统计每个数字的exp位（exp = 1 表示每个数字的个位，exp = 10 表示每个数字的十位……）出现的次数。 for (i = 0; i &lt; len; i++) &#123; buckets[(arr[i] / exp) % 10]++; &#125; 以个排序演示完整过程，出现次数：为待排序数组，每个数字的个位出现的次数 5.1.2.4 内部四for第二for: 转为累加数组 // 转为累加数组。目的是让更改后的buckets[i]的值，是该数据在output中的位置 for (i = 1; i &lt; 10; i++) &#123; buckets[i] += buckets[i - 1]; &#125; 这个累加数组中的值，就代表了每个数字最终应该存储的位置。比如53这个数字，当按照个位排完序，应该在哪里？ 首先，我们应该能想到应该要遍历待排序数组，然后按照某种规则放入用来临时存储的output数组中。那么问题来了，应该正向遍历，还是逆向遍历？ 假设是正向遍历，遍历到每个数字都需要考虑一些问题： 有多少个数字在我前面 和我拥有相同的个位，有多少个，还有多少个没有被安排进临时数组 比如，第一个数字53，首先，获取53的个位数字3，对应到buckets数组中发现buckets[3] = 4，说明最后一个个位为3的数字应该排在第四个。通过buckets[2] = 1，说明能排在个位3前面的数字只有1个，能推出，在最后的排序结果中，以3为个位的数字应该排在序列的第2,3,4位置。问题来了，如何确定到底是那个位置，同时还要保证相同个位的数字之间相对位置不变。 假设是逆序，它天然就能保证在最终结果序列中，相同个位之间相对顺序不变。比如063。 buckets[3] = 4，让063排第4位，buckets[3] = 3 buckets[3] = 3，让003排第3位，buckets[3] = 2 buckets[2] = 2，让053排第2位，buckets[3] = 1 这个逻辑写起来就会很轻松。 5.1.2.5 内部四for第三for: 将数据存储到临时数组output中 这里是整个排序中最不好懂的一部分。但是当你看到上面的说明，这里就会比较容易去理解。为了方便理解，将源代码中的两行代码拆分。 // 将数据存储到临时数组output中 for (i = len - 1; i >= 0; i--) &#123; // 获取这个数字的exp位 int pos = (arr[i] / exp) % 10; // 对应到buckets数组 int b = buckets[pos]; // 数组下标从0开始,需要减1,才是arr[i]应该存储的地方 output[--b] = arr[i]; // 让桶的数字自减 buckets[pos]--; //output[buckets[(arr[i] / exp) % 10] - 1] = arr[i]; //buckets[(arr[i] / exp) % 10]--; &#125; 第1次：616，获取个位6，buckets[6] = 8，需要减1才是存放处，output[8 - 1] = 616，桶的数字减1，buckets[6] = 7 第2次：063，获取个位3，buckets[3] = 4，需要减1才是存放处，output[4 - 1] = 063，桶的数字减1，buckets[3] = 3 第3次：154，获取个位4，buckets[4] = 7，需要减1才是存放处，output[7 - 1] = 154，桶的数字减1，buckets[4] = 6 第4次：214，获取个位4，buckets[4] = 6，需要减1才是存放处，output[6 - 1] = 124，桶的数字减1，buckets[4] = 5 第5次：014，获取个位4，buckets[4] = 5，需要减1才是存放处，output[5 - 1] = 014，桶的数字减1，buckets[4] = 4 第6次：748，获取个位8，buckets[8] = 9，需要减1才是存放处，output[9 - 1] = 748，桶的数字减1，buckets[8] = 8 第7次：542，获取个位2，buckets[2] = 1，需要减1才是存放处，output[1 - 1] = 542，桶的数字减1，buckets[2] = 0 第8次：003，获取个位3，buckets[3] = 3，需要减1才是存放处，output[3 - 1] = 003，桶的数字减1，buckets[3] = 2 第9次：053，获取个位3，buckets[3] = 2，需要减1才是存放处，output[2 - 1] = 053，桶的数字减1，buckets[3] = 1 5.1.3 完整代码（适用于负数） public void radixSort(int[] arr) &#123; int len = arr.length; if(len == 1 ||len == 0) return; int[] temp = getMinMax(arr); // 应该是位数最多的那一个 int arrMax = Math.max(Math.abs(temp[0]), Math.abs(temp[1])); for (int exp = 1; arrMax / exp != 0; exp *= 10) &#123; int i; // 存储被排序数组的临时数组 int[] output = new int[len]; // 桶,因为要考虑负数,桶编号从-9~9,，所以桶数组的长度是19 int[] buckets = new int[19]; // 将数据出现的次数进行统计,其中buckets数组下标0-8代表-9~-1,下标9代表0,10-18代表1-9 for (i = 0; i &lt; len; i++) &#123; //获取这一位 int bit = arr[i]/exp % 10; buckets[bit + 9]++; &#125; // 转为累加数组。目的是让更改后的buckets[i]的值，是该数据在output中的位置 for (i = 1; i &lt; buckets.length; i++) &#123; buckets[i] += buckets[i - 1]; &#125; // 将数据存储到临时数组output中 for (i = len - 1; i >= 0; i--) &#123; output[buckets[(arr[i] / exp) % 10 + 9] - 1] = arr[i]; buckets[(arr[i] / exp) % 10 + 9]--; &#125; // 将排序好的数组赋值给arr for (i = 0; i &lt; len; i++) arr[i] = output[i]; &#125; &#125; 首先和上面不包含负数的基数排序相比，变动的地方如下： arrMax int[] temp = getMinMax(arr); int arrMax = Math.max(Math.abs(temp[0]), Math.abs(temp[1])); 实际上，arrMax的意义其实没有变化，都指的是这一串数字当中位数最多的那个数字，至于是正的还是负的，这无所谓，只要它位数最多。 所以，倘若这串数字包含负数，在获取位数最多的那个数字，可以这样获取。 其中getMinMax是获取arr中的最小值和最大值，返回值{min，max} 桶数组大小变动 int[] buckets = new int[19]; // 将数据出现的次数进行统计,其中buckets数组下标0-8代表-9~-1,下标9代表0,10-18代表1-9 for (i = 0; i &lt; len; i++) &#123; //获取这一位 int bit = arr[i]/exp % 10; buckets[bit + 9]++; &#125; …… // 将数据存储到临时数组output中 for (i = len - 1; i >= 0; i--) &#123; output[buckets[(arr[i] / exp) % 10 + 9] - 1] = arr[i]; buckets[(arr[i] / exp) % 10 + 9]--; &#125; 因为要考虑到负数，应该有：-9，-8，-7，-6，……，0，1，2，……，9共计19个桶 因为数组下标是从0开始的，所以在第一个计数的for循环，当在得到该数字的某一位时，需要+9 同时在第三个for循环，在获取某个桶的值的时候，也需要+9 5.2 计数排序 利用桶，空间换时间，在面对在一定范围内的大量重复数字的场景下，很适用。 比如一个省的高考成绩排名，可以声明一个长度为751的计数数组，其数组下标为0-750，代表每个分数。之后遍历整个省的所有人，统计每个分数的出现的次数，然后再遍历计数数组，即可实现有序。 /** * @Title: countSort * @Description:计数排序,适用于数字的范围小，排序量大的数组 * @param arr 数组 * @param min 该数组中的最小值 * @param max 该数组中的最大值 * @return: int[] */ public void countSort(int[] arr, int min, int max) &#123; // arr的最小值到最大值之间的数字，即为countArr的下标 int[] countArr = new int[max - min + 1]; // 统计arr中每个数字出现的次数 for (int j = 0; j &lt; arr.length; j++) countArr[arr[j] - min]++; int[] res = new int[arr.length]; // 将countArr变为累加数组,这一步主要是实现算法稳定 for (int m = 1; m &lt; countArr.length; m++) countArr[m] += countArr[m - 1]; // 这一步参见基数排序的过程示意图 for(int k = arr.length - 1; k >= 0; k--) res[--countArr[arr[k] - min]] = arr[k]; // 将排序好的数组赋值给arr for(int i = 0; i &lt; arr.length; i++) &#123; arr[i] = res[i]; &#125; &#125; 6. 排序比较 排序 英文 平均 最坏 最好 空间 稳定性 插入排序 Insertion n2 n2 n 1 稳 折半插入 n2 n2 nlog2n 1 稳 希尔排序 Shell n1.3 n2 n 1 不稳 堆排序 Heap nlog2n nlog2n nlog2n 1 不稳 选择排序 Selection n2 n2 n2 1 不稳 冒泡排序 Bubble n2 n2 n 1 稳 快速排序 Quick nlog2n n2 nlog2n log2n 不稳 归并排序 Merge nlog2n nlog2n nlog2n n 稳 桶排序 Bucket n+k n2 n n+k 稳 计数排序 Counting n+k n+k n+k n+k 稳 基数排序 Radix n*k n*k n*k n+k 稳 经过一趟排序能够使某个关键字到达最终位置的排序：交换类排序（冒泡，快速排序）、选择类排序（简单选择，堆排序） 排序算法的关键字比较次数和原始序列无关：简单选择排序和折半插入排序 排序算法的排序趟数和原始序列有关：交换类排序（冒泡，快速排序）","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"blog.silverbeats.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"排序","slug":"排序","permalink":"blog.silverbeats.cn/tags/%E6%8E%92%E5%BA%8F/"}],"author":"silverbeats"},{"title":"hexo之yelee主题配置","slug":"hexo之yelee主题配置","date":"2020-09-13T11:53:59.000Z","updated":"2020-10-21T06:23:55.889Z","comments":true,"path":"hexo之yelee主题配置/","link":"","permalink":"blog.silverbeats.cn/hexo%E4%B9%8Byelee%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/","excerpt":"","text":"参考文章： 使用Github搭建Hexo技术博客托管在GitHub Pages上–安装教程 博客系统hexo yelee搭建历程 hexo在文章中添加图片 Hexo七牛插件安装与使用 hexo相关命令语法 1. 前期准备 github账号、安装git nodejs notepad++或者editplus，记事本也可以 typora（后期写md格式文章用的软件） 可选内容 修改node.js源 &#x2F;&#x2F; 设置 淘宝镜像源 npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org &#x2F;&#x2F; 查看使用的镜像源 npm config get registry &#x2F;&#x2F; 安装淘宝镜像源 npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org 2. 实操 2.1 安装Hexo框架 npm install -g hexo-cli &#x2F;&#x2F; 或者 cnpm install -g hexo-cli 2.2 创建Hexo项目 在本地，选择要创建项目的目录 打开Git Bash（或者cmd命令行，或者powershell），并进入该目录 输入并运行hexo init blog之后，会在当前目录下创建blog文件夹，并初始化相关文件 cd blog进入创建的项目，运行npm install下载相关依赖包 2.3 相关命令 #清理之前生成的旧文件 hexo clean #重新生成静态文件 下面是简写 hexo generate hexo g #本地预览 下面是简写 hexo server hexo s #合并写法 hexo clean | hexo g | hexo s #通过git提交到仓库,需要配置,见后文 hexo deploy hexo d 2.4 下载yelee主题 在当前目录下，输入命令git clone https://github.com/MOxFIVE/hexo-theme-yelee themes/yelee，倘若下载速度是龟速，不如直接用迅雷下zip压缩包来的快…… Hexo主题压缩包，百度云，密码abcd 下载完成之后，需要修改项目目录下的_config.yml文件，找到theme主题字样，将后面的默认主题landscape修改为yelee。倘若之后想要更换主题也是如此。 2.5 修改yelee主题_config.yml文件 2.5.1 首页不显示文章列表 启动后会发现左侧导航栏，点击主页后不显示文章列表 进入yelee模板页的 _config.yml search: on: true onload: true ## true: get search.xml file when the page has loaded ## false: get the file when search box gets focus 2.5.2 相关链接无法跳转 在themes/yelee/_config.yml中类似如下的内容。实际上当预览的时候会发现有相关的链接没有配置路由。 ## About Page: &#96;hexo new page about&#96; ## Tags Cloud Page: &#96;hexo new page tags&#96; menu: 主页: &#x2F; 所有文章: &#x2F;archives&#x2F; 随笔: &#x2F;note&#x2F; 标签云: &#x2F;tags&#x2F; 关于我: &#x2F;about&#x2F; 因为随笔、标签云、关于我这种链接，在此项目中是没有的，需要去创建。留意上方注释，已经说明如何创建。 #在项目根目录下操作, 根据需要创建系统页 hexo new page tags hexo new page about hexo new page categories 2.5.3 添加文章的字数统计和大概看完的时间 #项目根路径下操作 npm i --save hexo-wordcount 文件配置： 在yelee/layout/_partial/post/word.ejs下创建word.ejs文件： &lt;!--倘若出现tag标签和统计字数的文件有布局上的问题，可以对上下外边距进行调整--> &lt;div style=\"margin-top:10px;margin-bottom: 30px\"> &lt;span class=\"post-time\"> &lt;span class=\"post-meta-item-icon\"> &lt;i class=\"fa fa-keyboard-o\">&lt;/i> &lt;span class=\"post-meta-item-text\"> 字数统计: &lt;/span> &lt;span class=\"post-count\">&lt;%= wordcount(post.content) %>字&lt;/span> &lt;/span> &lt;/span> &lt;span class=\"post-time\"> &amp;nbsp; | &amp;nbsp; &lt;span class=\"post-meta-item-icon\"> &lt;i class=\"fa fa-hourglass-half\">&lt;/i> &lt;span class=\"post-meta-item-text\"> 阅读时长: &lt;/span> &lt;span class=\"post-count\">&lt;%= min2read(post.content) %>分&lt;/span> &lt;/span> &lt;/span> &lt;/div> 然后在 themes/yelee/layout/_partial/article.ejs中添加 &lt;div class=\"article-inner\"> &lt;% if (theme.fancybox)&#123; %> &lt;input type=\"hidden\" class=\"isFancy\" /> &lt;% &#125; %> &lt;% if (post.link || post.title)&#123; %> &lt;header class=\"article-header\"> &lt;%- partial('post/title', &#123;class_name: 'article-title'&#125;) %> &lt;!-- 开始添加字数统计,这里才是添加的东西--> &lt;% if(theme.word_count &amp;&amp; !post.no_word_count)&#123;%> &lt;%- partial('post/word') %> &lt;% &#125; %> &lt;!-- 添加完成 --> &lt;/header> 开启功能 在yelee主题的_config.yml中添加： word_count: true 2.5.4 配置本地搜索 # 项目根目录运行 npm install hexo-generator-search --save 然后配置文件themes/yelee/_config.yml中修改为： search: on: true onload: true ## true: get search.xml file when the page has loaded ## false: get the file when search box gets focus 2.5.5 添加网站运行时间 \\themes\\yelee\\layout\\_partial路径下找到footer.ejs添加如下代码： &lt;footer id=\"footer\"> &lt;div class=\"outer\"> &lt;div id=\"footer-info\"> &lt;div class=\"footer-left\"> &lt;/div> &lt;!--添加代码的位置,以及要添加的代码 &lt;span id=\"timeDate\">载入天数...&lt;/span>&lt;span id=\"times\">载入时分秒...&lt;/span> &lt;script> var now = new Date(); function createtime() &#123; var grt = new Date(\"09/13/2020 12:49:00\");//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime() + 250); days = (now - grt) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if (String(hnum).length == 1) &#123; hnum = \"0\" + hnum; &#125; minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if (String(mnum).length == 1) &#123; mnum = \"0\" + mnum; &#125; seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if (String(snum).length == 1) &#123; snum = \"0\" + snum; &#125; document.getElementById(\"timeDate\").innerHTML = \"本站已安全运行 \" + dnum + \" 天 \"; document.getElementById(\"times\").innerHTML = hnum + \" 小时 \" + mnum + \" 分 \" + snum + \" 秒\"; &#125; setInterval(\"createtime()\", 250); &lt;/script> --> &lt;div class=\"footer-right\">&lt;/div> &lt;/div> …… &lt;/footer> 2.5.6 文章底部不显示作者 倘若出现了这种情况，可以在主题的配置文件中添加： author: 作者名字 2.5.7 添加点击爱心效果 下载js文件，链接地址,密码bcde 在theme/yelee/source下创建resources目录并将js文件拷贝到此目录下 在/themes/yelee/layout/_partial/after-footer.ejs下添加代码 &lt;script type=\"text/javascript\" src=\"/resources/float.js\">&lt;/script> &lt;script type=\"text/javascript\" src=\"/resources/love.js\">&lt;/script> &lt;script type=\"text/javascript\" color=0,104,183 opacity=1 zindex=-1 count=50 src=\"/resources/particle.js\">&lt;/script> &lt;script type=\"text/javascript\" src=\"/resources/typewriter.js\">&lt;/script> 2.5.11 其它 主题文件的_config.yml还可以配置什么： 网站的ico图标 自己的头像 导航栏链接 背景图片 是否开启分享 是否需要评论、以及是否显示评论数量 文章的标题风格、字体大小 …… 2.6 修改hexo的_config.yml 2.6.1 Url持久化 可以发现 hexo 默认生成的文章地址路径是 【网站名称／年／月／日／文章名称】。 这种链接对搜索爬虫是很不友好的，它的 url 结构超过了三层，太深了。 安装 hexo-abbrlink 插件： npm install hexo-abbrlink --save 然后配置根目录的_config.yml permalink: :title&#x2F; #permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F; 2.6.2 添加二次元虚拟人物 获取： npm install --save hexo-helper-live2d 下载人物模型，官方： npm install live2d-widget-model-shizuku # 对应use: live2d-widget-model-unitychan npm install live2d-widget-model-hibiki # 对应use: live2d-widget-model-hibiki 配置： live2d: enable: true scriptFrom: local model: #只需要修改unitychan就可以更换虚拟人物 use: live2d-widget-model-unitychan display: position: right width: 150 height: 300 mobile: show: true 2.6.3 当文章中有图片时 图片在博文中十分常见，因博客部署在GitHub上，空间有限，推荐将图片、音频、视频等文件存放在七牛云这样的地方。 2.6.3.1 使用七牛云同步插件 注册账号登录，点击对象存储，创建存储空间，并绑定域名，绑定域名参考官网提供的说明 hexo安装七牛云同步插件：npm install hexo-qiniu-sync --save hexo的配置文件中进行七牛云配置 #plugins: # - hexo-qiniu-sync qiniu: offline: true # 离线,true会省流量 sync: true bucket: #这里需要填写第一步创建的存储空间的名字 # 这里将其注释掉，不注释，执行hexo g报错 # secret_file: sec&#x2F;qn.json or C: #登录自己的七牛云账号，点击右上角的投降，选择密钥管理，可以获得 access_key: your access_key secret_key: your secret_key #上传的资源子目录前缀.如设置，需与urlPrefix同步 dirPrefix: static #外链前缀，第一步绑定的加速域名 urlPrefix: http:&#x2F;&#x2F;自己的加速域名&#x2F;static #使用默认配置即可 up_host: http:&#x2F;&#x2F;upload.qiniu.com &#x2F;&#x2F;本地目录 local_dir: static #是否更新已经上传过的文件(仅文件大小不同或在上次上传后进行更新的才会重新上传) update_exist: true image: folder: images extend: js: folder: js css: folder: css 在hexo根目录下创建如下目录结构，之后将对应的想要存放到七牛云的文件放到对应的文件夹即可 static - images - js - css 在文章中插入图片 &#123;% qnimg 图片.图片格式 title: alt: &#39;class:&#39; extend:?imageView2&#x2F;2&#x2F;w&#x2F;450 %&#125; 将本地static目录下的文件同步到七牛云 hexo qiniu sync #或者 hexo qiniu s #或者 hexo qiniu sync2 #或者 hexo qiniu s2 2.6.3.2 使用picGo工具 同步插件在使用过程中发现，在文章使用过程中看不到预览，并且在生成过程中还是会把图片放到public目录，所以会推荐使用picGo，提取码cdef工具来上传，成功后会返回外链地址，方便使用。 3. 把本地的博客内容同步到 Github 上 因为博客托管在GitHub上，所以在建立博客仓库时，仓库的名字需要命名为：用户名.github.io这样就可以通过用户名.github.io来访问该站点了。 创建好仓库后，需要本地生成SSH秘钥，方便通过git来进行提交 命令行输入：ssh-keygen -t rsa -C &quot;你的邮箱地址&quot;,之后不停的回车，期间，留意秘钥保存的路径，一般是：C:\\Users\\你的计算机用户名\\.ssh，会生成两个文件： 私钥：id_rsa 公钥：id_rsa.pub 访问自己GitHub账户的setting/SSH keys，将公钥的内容复制粘贴到Key的位置（主义末尾不要留有空行），title内容随意。 安装两个跟部署相关的 hexo 插件 npm install hexo -server --save npm install hexo-deployer-git --save 编辑全局的hexo配置文件：_config.xml # Hexo Configuration ## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;configuration.html ## Source: https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo&#x2F; # Site 这一块区域主要是设置博客的主要说明，需要注意的是：每个冒号后面都是有一个空格，然后再书写自己的内容的s title: LearnFoever #网站标题 subtitle: #网站副标题 description: #描述 author: silverbeats email: 418116014@qq.com language: zh-CN timezone: #网站时区。Hexo 默认使用您电脑的时区 # URL 这一块一般可以设置的是 url 这个参数，比如我要设置绑定域名的，这里就需要填写我的域名信息 ## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39; url: http:&#x2F;&#x2F;silverbeats.github.io #倘若已经购买了域名的话可以填买的域名 root: &#x2F; #这里配置的url持久化 permalink: :title&#x2F; #:year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F; permalink_defaults: # Directory source_dir: source #源文件夹，这个文件夹用来存放内容。 public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件 tag_dir: tags #标签文件夹 archive_dir: archives #归档文件夹 category_dir: categories #分类文件夹 code_dir: downloads&#x2F;code #nclude code 文件夹 i18n_dir: :lang #国际化（i18n）文件夹 skip_render: #跳过指定文件的渲染，可使用 glob 表达式来匹配路径 # Writing new_post_name: :title.md #新建文章默认文件名 default_layout: post # 默认布局 titlecase: false # Transform title into titlecase external_link: true # 在新标签中打开一个外部链接，默认为true filename_case: 0 render_drafts: false #是否渲染_drafts目录下的文章，默认为false post_asset_folder: true #启动 Asset 文件夹 relative_link: false #把链接改为与根目录的相对位址，默认false future: true #显示未来的文章，默认false highlight: #代码块的设置 enable: true line_number: true auto_detect: false tab_replace: &#39;&#39; wrap: true hljs: false prismjs: enable: false preprocess: true line_number: true tab_replace: &#39;&#39; # Home page setting # path: Root path for your blogs index page. (default &#x3D; &#39;&#39;) # per_page: Posts displayed per page. (0 &#x3D; disable pagination) # order_by: Posts order. (Order by date descending by default) index_generator: path: &#39;&#39; per_page: 10 order_by: -date # Category &amp; Tag #分类和标签的设置 default_category: uncategorized #默认分类 category_map: tag_map: # Metadata elements ## https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;HTML&#x2F;Element&#x2F;meta meta_generator: true # Date &#x2F; Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http:&#x2F;&#x2F;momentjs.com&#x2F;docs&#x2F;#&#x2F;displaying&#x2F;format&#x2F; date_format: YYYY-MM-DD time_format: HH:mm:ss ## updated_option supports &#39;mtime&#39;, &#39;date&#39;, &#39;empty&#39; updated_option: &#39;mtime&#39; # Pagination ## Set per_page to 0 to disable pagination per_page: 10 pagination_dir: page # Include &#x2F; Exclude file(s) ## include:&#x2F;exclude: options only apply to the &#39;source&#x2F;&#39; folder include: exclude: ignore: # Extensions ## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F; ## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F; theme: yelee # next yelee search: path: search.xml field: all # Deployment ## 这里是重点，这里是修改发布地址，因为我们前面已经加了 SSH 密钥信息在 Github 设置里面了，所以只要我们电脑里面持有那两个密钥文件就可以无需密码地跟 Github 做同步。 ## 需要注意的是这里的 repo 采用的是 ssh 的地址，而不是 https 的。分支我们默认采用 master 分支，以后熟悉了要换其他也无所谓。 ## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html deploy: type: git repo: github: git@github.com:SilverBeats&#x2F;SilverBeats.github.io.git,master # hexo-neat 对静态文件进行压缩 neat_enable: true neat_html: enable: true exclude: neat_css: enable: true exclude: - &#39;*.min.css&#39; neat_js: enable: true mangle: true output: compress: exclude: - &#39;*.min.js&#39; #萌妹子 live2d: enable: true scriptFrom: local model: use: live2d-widget-model-hibiki display: position: right width: 150 height: 300 mobile: show: true","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"blog.silverbeats.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"blog.silverbeats.cn/tags/hexo/"},{"name":"git","slug":"git","permalink":"blog.silverbeats.cn/tags/git/"},{"name":"github","slug":"github","permalink":"blog.silverbeats.cn/tags/github/"},{"name":"nodejs","slug":"nodejs","permalink":"blog.silverbeats.cn/tags/nodejs/"}],"author":"silverbeats"}],"categories":[{"name":"书籍","slug":"书籍","permalink":"blog.silverbeats.cn/categories/%E4%B9%A6%E7%B1%8D/"},{"name":"java","slug":"java","permalink":"blog.silverbeats.cn/categories/java/"},{"name":"设计模式","slug":"java/设计模式","permalink":"blog.silverbeats.cn/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Mybatis","slug":"java/Mybatis","permalink":"blog.silverbeats.cn/categories/java/Mybatis/"},{"name":"算法设计与分析","slug":"算法/算法设计与分析","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"博客搭建","slug":"博客搭建","permalink":"blog.silverbeats.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"书籍","slug":"书籍","permalink":"blog.silverbeats.cn/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"java","slug":"java","permalink":"blog.silverbeats.cn/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"blog.silverbeats.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"数据结构","slug":"数据结构","permalink":"blog.silverbeats.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法设计题目","slug":"算法设计题目","permalink":"blog.silverbeats.cn/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE/"},{"name":"Mybatis","slug":"Mybatis","permalink":"blog.silverbeats.cn/tags/Mybatis/"},{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"blog.silverbeats.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"串","slug":"串","permalink":"blog.silverbeats.cn/tags/%E4%B8%B2/"},{"name":"KMP","slug":"KMP","permalink":"blog.silverbeats.cn/tags/KMP/"},{"name":"分治法","slug":"分治法","permalink":"blog.silverbeats.cn/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"},{"name":"最短路径","slug":"最短路径","permalink":"blog.silverbeats.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"blog.silverbeats.cn/tags/Dijkstra/"},{"name":"Floyd","slug":"Floyd","permalink":"blog.silverbeats.cn/tags/Floyd/"},{"name":"hexo","slug":"hexo","permalink":"blog.silverbeats.cn/tags/hexo/"},{"name":"排序","slug":"排序","permalink":"blog.silverbeats.cn/tags/%E6%8E%92%E5%BA%8F/"},{"name":"git","slug":"git","permalink":"blog.silverbeats.cn/tags/git/"},{"name":"github","slug":"github","permalink":"blog.silverbeats.cn/tags/github/"},{"name":"nodejs","slug":"nodejs","permalink":"blog.silverbeats.cn/tags/nodejs/"}]}