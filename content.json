{"meta":{"title":"LearnForever","subtitle":"","description":"坚持学习每一天","author":"silverbeats","url":"blog.silverbeats.cn","root":"/"},"pages":[{"title":"schedule","date":"2020-09-15T10:47:30.000Z","updated":"2020-09-15T11:38:33.448Z","comments":false,"path":"schedule/index.html","permalink":"blog.silverbeats.cn/schedule/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-09-15T10:32:54.000Z","updated":"2020-09-15T11:38:48.370Z","comments":false,"path":"categories/index.html","permalink":"blog.silverbeats.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-09-15T10:33:05.000Z","updated":"2020-09-15T11:38:04.782Z","comments":false,"path":"tags/index.html","permalink":"blog.silverbeats.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java基础","slug":"java基础","date":"2020-10-26T23:53:31.000Z","updated":"2020-10-27T13:29:34.519Z","comments":false,"path":"java基础/","link":"","permalink":"blog.silverbeats.cn/java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1 简介 1.1 Java应用程序的运行机制 计算机高级语言有编译型和解释型两种，Java是二者结合。 Java源文件后缀名是**.java**； 再利用编译器javac将源程序编译成字节码文件，字节码文件后缀名为**.class**； 最后利用虚拟机JVM解释执行 1.2 JVM、JRE和JDK Jvm是java虚拟机，用于执行字节码的虚拟计算机 jre是java运行时环境，包含了java虚拟机，库函数，运行java应用程序所必须的文件 jdk，包含了jre，以及增加了编译器和调试器等用于程序开发的文件 1.3 注释 单行注释：&#x2F;&#x2F; 多行注释：&#x2F;**&#x2F; 文档注释：&#x2F;***&#x2F; 可以自动生成API文档 1.4 变量和常量 变量的本质是代表一个“可操作的存储空间”，空间的位置是确定的，但是里面的值不确定。可以通过变量名来访问“对应的存储空间”，从而操作存储空间的值。 标识符必须以字母，下划线，$符号开头，也就是数字不能开头 大小写敏感 不能是关键字 表示类名的时候，首字母大写 驼峰写法 变量的分类： 局部变量：方法或语句块内部定义的变量，生命周期是从声明位置开始到方法或语句块执行完毕为止。 局部变量的使用一定要初始化。 成员变量(实例变量 member variable)：方法外部、类的内部定义的变量。 从属于对象、生命周期伴随对象的终止。成员变量会自动初始化。 静态变量(类变量)：使用static定义。 从属于类、生命周期伴随始终，从类加载到卸载。 常量： final int MAX = 123; 修饰常量的时候，常量不可修改 修饰方法的时候，该方法不可被子类继承重写，但是可以被重载 修饰类的时候，修饰的类不能被继承 String类就是用final修饰的 2 基本数据类型 2.1 数值型 整数类型(默认int) 大小 范围 标识符 byte 1字节 -128-127 无 short 2字节 -32768~32767 无 int 4字节 -2147483648~2147483647 无 long 8字节 -9223372036854775808~9223372036854775807 L 浮点类型(默认double) float(4字节) double(8字节) 浮点数不精确，最好不要用于比较，或者使用java.math下两个类来比较，BigDecimal(比较浮点数),BigInteger(比较整型) 2.2 char字符型(2个字节) // 给定ASCII码对应的字符 char temp1 = 97; // 直接给字符,使用单引号 char temp2 = 'a'; // 使用Unicode char temp3 = '\\u0000'; 2.3 布尔型 在Java中定义的八种基本数据类型中，除了其它七种类型都有明确的内存占用字节数外，就boolean类型没有给出具体的占用字节数，因为对虚拟机来说根本就不存在 boolean 这个类型，boolean类型在编译后会使用其他数据类型来表示。 具体有以下三种说法： ① 1个bit—理由是boolean类型的值true和false被编译后会使用0和1来表示。0和1仅需要用1位（bit）来存储。 ② 1个字节—理由是虽然编译后1和0只需要占用1位空间，1个字节是8位，实际的存储空间是：用一个字节的的最低位存储，其他七位用0填补。如果值是true的话则存储的二进制为：0000 0001，如果是false的话则存储的二进制为：0000 0000。 ③ 单独使用是4个字节，在数组当中是占1个字节–理由来源是《Java虚拟机规范》一书中的描述：“虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位”。 2.4 类型的转化 红线：自动转换，无精度损失 蓝色：自动转换，存在精度损失 double x = 1.0; // 强转 int y = (int)x; 3 运算符 3.1 优先级 运算符 优先级 结合性 （）[] 1 左至右 ! +(正号) -(负号) ~ ++ – 2 右至左 * / % 3 左至右 + - 4 左至右 &gt;&gt; &lt;&lt; &gt;&gt;&gt; 5 左至右 &gt; &gt;= &lt; &lt;= instanceof 6 左至右 == != 7 左至右 &amp;(按位与) 8 左至右 ^ 9 左至右 | 10 左至右 &amp;&amp; 11 左至右 || 12 左至右 ?: 13 右至左 += *= /= %= -= = &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= ~= |= &amp;= ^= 14 右至左 如果两个操作数有一个为Long，则结果也为Long 没有Long时，结果为int，即便操作数全为short、byte结果也是int 如果两个操作数有一个为double，则结果为double 只有两个操作数都是float，结果才是float 运算符 说明 逻辑与&amp; 两个操作数为true，结果才为true 逻辑或| 两个操作数有一个是true，结果就是true 短路与&amp;&amp; 只要有一个false，结果就是false 短路或|| 只要有一个true，结果就是true 逻辑非！ 取反 逻辑异或^ 相同false，不同true 3.2 短路与和逻辑与的区别 //1>2已经是false，后面的比较就不看了，可以提高效率 boolean c = 1>2 &amp;&amp; 2>(3/0); //1>2已经是false，但后面的表达式还会看 boolean c = 1>2 &amp; 2>(3/0); 3.3 位运算 int a = 3 >> 1; //a = 3/2 右移想当于除 int a = 3 &lt;&lt; 1; //a = 3*2 左移相当于乘 int a = 3; int b = 4; /* a&amp;b = 0 0011 &amp; 0100 = 0000 = 0 a|b = 7 0011 | 0100 = 0111 = 7 a^b = 7 0011 ^ 0100 = 0111 = 7 */ 4 流程控制语句 4.1 if条件分支语句 if(条件) &#123; &#125; else if(条件)&#123; &#125; else if(条件)&#123; &#125; …… else &#123; &#125; 4.2 循环语句 4.2.1 while while(条件)&#123; // 循环体 &#125; do &#123; //循环体 &#125; while(条件); 4.2.2 for /* 1. i = 0 2. i &lt; 10 成立 3. 打印i 4. i++变成了1 5. 1 &lt; 10成立 6. 打印i …… */ for(int i = 0; i &lt; 10; i++) &#123; System.out.println(i); &#125; int j = 0; for(;j &lt; 10; j++) &#123; System.out.println(j); &#125; int k = 0; for(;k&lt;10;) &#123; System.out.println(k++); &#125; int[] array = &#123;1,4,2,3&#125;; for(int v : array) &#123; System.out.println(v); &#125; 5 方法的定义 /* [修饰符1 修饰符2...] 返回值类型 方法名(形式参数列表)&#123; &#125; */ void add(int a, int b, int c) &#123; int sum = a + b + c; System.out.printIn(sum); &#125; 形式参数：在方法声明时用于接收外界传入的数据 实参：调用方法时实际传给方法的数据 返回值 返回值类型：无返回值必须指定为void 6 面向对象 6.1 面向对象和面向过程的区别 面向过程：首先思考“怎么按步骤实现”，并将步骤对应成方法，一步步最终完成。适合简单任务，不需要过多的协作。微观操作。 面向对象：首先思考的是“怎么设计”，宏观把控 6.2 对象和类 类可以看作对象的模板，叫做class 对象：叫做Object或者instance实例，以后说某个类的对象，其实是一个意思 类里面有属性/变量，和方法 public class Stu &#123; int age; //构造方法，用于创建这个类的对象，无参的构造方法可以由系统自动创建，用于对象的初始化 Stu() &#123;&#125; public static void Eat() &#123; System.out.print(\"我在吃\"); &#125; //程序的入口文件，必须要有 public static void main(String[] args) &#123; // 创建一个对象 Stu stu = new Stu(); // 调用对象的方法 stu.Eat(); &#125; &#125; 6.2.1 构造器要点 通过new关键字调用 构造器虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能在构造器里面使用return返回某个值 如果没有定义构造器，编译器会自动定义一个无参数的构造函数。如果自己定义了，则编译器不会自动添加 构造器的方法名必须与类名一致 6.2.2 对象创建过程 分配对象空间，并将对象成员变量初始化为0或者null 执行属性值的显式初始化 执行构造方法 返回对象的地址给相关的变量 6.3 面向对象的特点 封装：内部的操作对外部而言不可见；当内部的操作都不可直接使用，才是安全的； 继承：在已有的结构基础上继续进行功能的扩充 多态：在继承的基础上扩充而来的概念，指的是类型的转换处理 OOA：面向对象分析 OOD：面向对象设计 OOP：面向对象编程 6.3.1 封装 优点： 提高代码的安全性 高内聚：封装细节，便于修改内部代码，提高可维护性 低耦合：简化外部调用，便于调用者使用，便于扩展和协作 访问控制符： 修饰符 同一个类 同一个包中 子类 不同包所有类 private √ default √ √ protected √ √ √ public √ √ √ √ private: 只能被自己的类使用，子类虽然继承父类私有属性，但是是用不了 default : 表示没有修饰符，只能同一个包的类能访问 protected: 表示可以被同一个包的类以及其他包中的子类访问 public: 表示可以被该项目的所有包中的所有类访问 示例： public class Person &#123; private int id; private String name; private int age; private boolean man; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return this.name; &#125; &#125; 6.3.2 继承 Java只有一个直接父类，Java的接口可以多实现 Java可以继承父类所有的属性和方法(构造方法除外)，私有属性也不能使用 可以提高代码的复用性 instanceof是二元运算符，左边是对象，右边是类，当对象是右面的类或子类创建的对象时，返回true，否则返回false。用来判断该实例是否是该类 示例： public class textExtends &#123; public static void main(String[] args) &#123; Student stu = new Student(); stu.name = \"星期一\"; stu.major = \"coding\"; stu.height = 173; System.out.println(stu instanceof Person);//true System.out.println(stu instanceof Student);//true &#125; &#125; class Person &#123; String name; int height; public void rest () &#123; System.out.println(\"rest\"); &#125; &#125; class Student extends Person&#123; String major; public void study() &#123; System.out.println(\"study\"); &#125; public Student (String name, int height, String major)&#123; this.name = name; this.height = height; this.major = major; &#125; public Student ()&#123;&#125; &#125; 重写父类方法： 子类通过重写父类的方法，可以用自身的行为替换父类的行为。 class Vehicle &#123; public void run() &#123; System.out.println(\"run...\"); &#125; public void stop() &#123; System.out.println(\"stop...\"); &#125; &#125; class Horse extends Vehicle &#123; public void run() &#123; System.out.println(\"horse run\"); &#125; &#125; 方法的重写需要符合三个要点： 方法名，形参列表相同 返回值类型和声明异常类型，子类小于等于父类 访问权限，子类大于等于父类 引用父类的方法： super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性 class Father &#123; String food; public void eat() &#123; food = \"面条\"; System.out.println(\"父类喜欢\" + food); &#125; &#125; class Child extends Father &#123; String food; public void eat() &#123; super.eat(); food = \"西瓜\"; System.out.println(\"子类喜欢\" + food); System.out.println(super.food); &#125; &#125; 继承树追溯问题： public class MyClass1 extends Object&#123; public static void main(String[] args) &#123; new Child(); &#125; &#125; class Father &#123; public Father() &#123; super();//编译器自动加的，默认会执行 System.out.println(\"开始创建Father类\"); &#125; &#125; class Child extends Father &#123; public Child() &#123; super();//编译器自动加的，默认会执行 System.out.println(\"开始创建Child类\"); &#125; &#125; 开始创建Father类 开始创建Child类 6.3.3 多态 多态是指同一个方法调用，由于对象不同可能会有不同的行为。现实生活中，同一个方法，具体实现会完全不同。 多态是方法的多态，不是属性的多态(多态与属性无关)。 多态的存在要有三个必要条件：继承、方法重写、父类引用指向子类对象 父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了 示例： public class DuoTai &#123; public static void main(String[] args) &#123; Animal a = new Animal(); animalCry(a); Dog d = new Dog(); animalCry(d); &#125; static void animalCry(Animal a) &#123; a.shut(); &#125; &#125; class Animal &#123; public void shut() &#123; System.out.println(\"叫一声\"); &#125; &#125; class Dog extends Animal &#123; public void shut() &#123; System.out.println(\"旺一声\"); &#125; &#125; class Cat extends Animal &#123; public void shut() &#123; System.out.println(\"喵一声\"); &#125; &#125; 对象的转型 向上自动转型，向下强制转型 Animal d = new Dog();//向上自动转型 //d是Animal,如果想用Dog的方法，必须要强制转型 Dog d1 = (Dog)d Animal c = new Cat(); Dog d3 = (Dog)c;//将猫c强制转化成狗 d3.seeDoor();//这是Dog类里面的方法 /* 这么写，编译通过，但是运行会报错：ClassCastException错误，类型转化错误 */ 7 内存分析 Java虚拟机的内存可以分为三个区域：栈、堆、方法区域 栈 栈描述的是方法执行的内存模型，每个方法被调用都会创建一个栈帧(存储局部变量，操作数，方法出口等) JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数，局部变量等) 栈属于线程私有，不能实现线程间的共享 栈由系统自动分配，速度快，栈是一个连续的内存空间 堆heap 用于存储创建好的对象和数组 JVM只有一个堆，被所有线程共享 堆是一个不连续的内存空间，灵活 方法区域 JVM只有一个方法区域，被所有线程共享 方法区实际也是堆，用于存储类、常量相关信息 用来程序中永远不变的或唯一的内容(类信息、静态变量、字符串常量) 7.1 垃圾回收机制 发现无用对象 引用计数法 缺点：“循环引用的无用对象”无法识别 引用可达法(根搜索算法) 回收无用对象 7.2 分代垃圾回收机制 JVM将堆内存划分为Eden、Survivor、Old 年轻代Eden 所有新生对象首先都是放在Eden区，年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。对应的是Minor GC，每次Minor GC会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，会浪费内存空间。当“年轻代”区域存放满对象后，就将对象存放到”年老代“区域 年老代Old 在年轻代中经历了N(默认15)次垃圾回收后仍然存活的对象，就会被放倒年老代中。因此，可以认为年老代中存放的都是一些生命周期比较长的对象。年老代对象越来越多，就需要启动Major GC和Full GC(全量回收)，进行一次大清扫，全面清除年轻代区域和年老代区域。 持久代 用于存放静态文件，如java类、方法等。持久代堆垃圾收回没有显著影响 7.3 Full GC 当年老代满后，会触发 持久代满，会触发 System.gc()，程序建议GC启动，不是调用GC 上一次GC之后，heap的各区域分配策略动态变化 8 数组 8.1 声明 // 声明一个长度5的数组 int[] arr = new int[5]; // 声明一个长度4的数组,并初始化,静态初始化 int[] arr = &#123;1,2,3,4&#125;; int[] arr = new int[]&#123;1,2,3,4&#125;; // 声明一个宽5高6的5×6二维数组 int[][] arr = new int[5][6]; // 静态初始化二维数组 int[][] arr = new int[][] &#123; &#123;1,2,3,4&#125;, &#123;5,6,7,8&#125; &#125; 8.2 数组的拷贝 static void arraycopy(object src, int scrPos, object dest, int destPos, int length) src 数组 srcPos 开始位置，从src数组的第几个元素开始拷贝 dest 数组 destPos 拷贝到dest数组的哪个位置 length 指定src数组的多少个元素赋给dest数组的元素 String[] s1 = &#123;\"aa\",\"bb\",\"cc\",\"dd\",\"ee\"&#125;; String[] s2 = new String[10]; System.arraycopy(s1, 2, s2, 6, 3); System.out.print(Arrays.toString(s2)); 9 String类 String类又称作不可变字符序列，因为String类被final修饰 String类位于java.lang包中，Java程序默认导入java.lang包下所有的类 java字符串就是Unicode字符序列 Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义的类String，每个用双引号括起来的字符串都是String类的一个实例 字符串会被放到常量池中String pool 9.1 常用方法 String类常用方法 解释 返回值 str.charAt(index) 返回指定位置的字符，index为索引下标 String str1.equals(str2) 比较两个字符串值是否相等 boolean str1.equalsIgnoreCase(str2) 比较两个字符串，忽略大小写 boolean str1.indexOf(str2) 字符串str1中是否包含str2 boolean str1.replace(“ ”，“&amp;”) 将str1中的“ ”替换为&amp; String str1.startsWith(str2) str1是否以str2为开头 boolean str1.endWith(str2) str1是否以str2为结尾 boolean str1.substring(beginIndex) 提取字符串，从beginIndex到结尾 返回截取之后的字符串 str1.substring(beginIndex,endIndex) 提取字符串，左闭右开 String str.toLowerCase() 转小写 String str1.toUpperCase() 转大写 String str1.trim() 去除收尾的空格 String 9.2 字符串的拼接 String str = \"\"; for(int i = 0; i&lt; 5000; i++) &#123; str = str + i; &#125; /* 这段代码，循环5000次，相当于创建10000个对象。 一次循环： int i ——> 变成string i；str+i 产生新的string对象 很耗费时间与空间 */ // 使用StringBuilder进行优化 StringBuilder str1 = new StringBuilder(); for(int i = 0; i&lt; 5000;i++) &#123; str1.append(i); &#125; 10 注解 JDK 1.5之后提出的一个新的开发技术结构，利用Annotation可以有效的减少程序配置的代码，可以利用注解进行一些结构化定义。Annotation是以一种注解的形式实现程序的开发。 如果想要清除Annotation产生的意义，需要了解程序开发结构的历史。 过程一：在程序定义时，将所有可能用到的资源都定义在程序代码中； 缺点：需要修改源代码，维护不方便 过程二：引入配置文件，将配置写在配置文件中 缺点：①在配置项不多的时候，非常好用，但如果所有的项目都是采用这种结构开发会导致配置文件暴多；②所以的操作需要通过配置文件完成，开发难度上升 过程三：将配置信息重新写回程序中，利用一些特殊的标记与程序代码进行分离，这就是注解提出的基本依据 缺点：全用注解开发，难度太高，现在是配置文件+注解的形式开发 内置注解 说明 @Override 定义在java.lang.Override，此注释只适用于修饰方法，表示一个方法声明打算重写超类中的另一个方法声明 @Deprecated 定义在java.lang.Deprecated中，此注释可以用于修饰方法、属性、类表示被废弃 @SuppressWarnings 定义在java.lang.SupressWarnings，用来抑制编译时的警告信息 10.1 自定义注解，元注解 元注解的作用就是负责注解其他注解，Java定义了4个标准的meta-annotation类型，它们被用来提供对其他annotation类型做说明 这些类型和它们所支持的类在java.lang.annotation包 @Target：描述注解的使用范围（即被描述的注解可以用在什么地方） value 说明 TYPE Class, interface (including annotation type), or enum declaration FIELD Field declaration (includes enum constants) METHOD Method declaration PARAMETER Formal parameter declaration CONSTRUCTOR onstructor declaration LOCAL_VARIABLE Local variable declaration ANNOTATION_TYPE Annotation type declaration PACKAGE Package declaration TYPE_PARAMETER Type parameter declaration since 1.8 TYPE_USE Use of a type since 1.8 @Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期 value 说明 RUNTIME Annotations are to be recorded in the class file by the compiler and retained by the VM at run time, so they may be read reflectively. CLASS Annotations are to be recorded in the class file by the compiler but need not be retained by the VM at run time. This is the default behavior. SOURCE Annotations are to be discarded by the compiler @Documented：说明该注解将包含在javadoc中 @Inherited：说明之类可以继承父类中的该注解 @MyAnnotation public class Test &#123; @MyAnnotation public static void main(String[] args) &#123;&#125; &#125; // 表示注解能够用来哪些地方 @Target(value = &#123;ElementType.METHOD, ElementType.TYPE&#125;) // 表示注解在哪才有效 @Retention(value = RetentionPolicy.RUNTIME) @Documented @Inherited // 自定义注解 @interface MyAnnotation &#123;&#125; 10.2 自定义注解示例 **示例：**使用@interface自定义注解时，自动继承java.lang.annotation.Annotation接口 public class Test &#123; @MyAnnotation(name = \"给注解赋值\", schools = &#123;\"石河子大学\"&#125;) public void test()&#123;&#125; @MyAnnotation2(\"name\") public void test2() &#123;&#125; &#125; @Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;) @Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation &#123; // 注解的参数：参数类型+ 参数名 () String name(); // 给注解的参数设置默认值 int age() default 0; // 如果默认值-1代表不存在 int id() default -1; String[] schools(); &#125; @Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;) @Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation2 &#123; // 倘若只有一个注解参数，必须使用value作为参数名,此时在使用注解时，可以省略value直接复制 String value(); &#125; 11 抽象类 抽象方法 使用abstract修饰的方法，没有方法体，只有声明，定义的是一种规范，就是告诉子类必须要给抽象方法提供具体的实现 抽象类 包含抽象方法的类就是抽象类；不能被实例化；只能被子类继承；抽象方法必须被子类实现 public abstract class Animal &#123; abstract public void shout(); &#125; class Dog extends Animal &#123; @Override public void shout() &#123; System.out.print(\"ssas\"); &#125; &#125; 12 接口 12.1 概述 接口就是比抽象类还要抽象的抽象类，可以更加规范的对子类进行约束。全面专业的实现了：规范和具体实现的分离。 接口作用：解耦 抽象类中还提供了某些具体实现，但是接口不具有任何实现，接口中的方法都是抽象方法，接口是完全面向规范的，规定了一批类具有的公共方法规范。 [访问修饰符] interface 接口名 [extends 父接口1, 父接口2] &#123; 常量定义; 方法定义; &#125; 访问修饰符只能是public或者default默认 接口名：和类名采用相同命名机制 extends：接口可以多继承 常量：接口中的属性只能是常量，总是：public static final修饰，不写也是 方法：接口中的方法只能是public abstract，省略的话也是public abstract 子类通过implement来实现接口中的规范 接口不能创建实例，但是可以用于什么引用变量类型 一个类实现了接口，必须实现接口中所有的方法，并且方法都必须是public JDK1.7之前，接口中只能包含静态常量、抽象方法、不能有普遍属性，构造方法、普通方法 JDK1.8之后，接口中包含普通的静态方法 12.2 使用 public interface MyInterface &#123; /*public final static*/ int MAX_AGE = 100; /*public abstract*/ void shout(); &#125; class MyClass implements MyInterface &#123; @Override public void shout() &#123; System.out.print(MAX_AGE); &#125; &#125; 12.3 接口的继承 interface A &#123; void testA(); &#125; interface B &#123; void testB(); &#125; interface C extends A,B &#123; void testC(); &#125; class Test implements C &#123; public void testC()&#123;&#125; public void testA()&#123;&#125; public void testB()&#123;&#125; &#125; 12.4 接口和抽象类的区别 属性 方法 构造 继承 抽象类 没有要求 无要求 有构造(为子类实例化所用) 单继承 接口 必须是public static final的常量 都是抽象方法，在1.8之后可以由静态方法 没有构造 多继承、多实现 13 包装类 数据类型 包装类 char Character int Integer boolean Boolean double Double short Short long Long float Float byte Byte //基本数据类型 ——> 包装类对象 Integer a = new Integer(1); //包装类对象 ——> 基本数据类型 int b = a.intValue(); //字符串 ——> 包装类对象 Integer e = new Integer(\"999\"); Integer f = Integer.parseInt(\"999\"); //包装类对象 ——> 字符串 String str = f.toString(); 13.1 自动装箱和拆箱 自动装箱和拆箱就是将基本数据类型和包装类之间进行自动的互相转换。JDk1.5之后，Java引入自动装箱autoboxing和拆箱unboxing 基本类型的数据处于需要对象的环境中时，会自动转为“对象”。JVM替我们执行了Integer i = Integer.valueOf(5)这样的操作，这就是Java的自动装箱。 //jdk1.5之前 Integer a = new Integer(1); //jdk1.5之后，简单实现基本数据类型——>包装类 Integer a = 1; int b = a; //实际上是编译器会调用执行，过程又名拆箱 int b = a.intValue(); 13.2 包装类的缓存问题 Integer a = 1234; Integer b = 1234; System.out.println(a == b);//false System.out.println(a.equals(b));//true Integer a = -128; Integer b = -128; System.out.println(a == b);//true System.out.println(a.equals(b));//true public static Integer valueOf(int i) &#123; if(i >= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i) &#125; //Integer.class源码文件中定义low = -128，high = 127 //在启动的时候，就会生成cache数组，将[-128，127]对应的包装类对象放入其中，要是在这个范围之中，就会直接取，如果没有就new一个新对象 14 泛型 泛型从JDK1.5之后追加到Java中，目的是为了解决ClassCastException问题，在对象进行向下转型时，都可能存在安全隐患，而java希望通过泛型可以慢慢解决这样的问题。 比如现在的一个需求是：定义一个Point类，并且这个类之中允许开发者保存三种不同的点表达 整型数据：x=10，y= 20； 浮点型数据：x=10.1，y=20.9 字符串型数据：x=东经120度，y=北纬30度 于是在设计Point类时需要考虑具体的xy的属性类型，这个类型要求最简单的做法是定义成Object类，因为Object可以接受所有类型，但正因为如此会导致安全隐患。 public class Point&lt;T> &#123; private T x; private T y; // setter、getter、构造器略 &#125; 14.1 泛型通配符&lt;?&gt; class Message&lt;T> &#123; private T msg; // get、set略 &#125; class Test &#123; public static void main(String[] args) &#123; Message&lt;String> msg1 = new Message(); msg.setMsg(\"lala\"); Message&lt;Integer> msg2 = new Message(); msg.setMsg(12); Test.fun(msg); &#125; // 当不确定Message里面的属性的类型时,可以使用？作为替代，实现fun代码复用 public static void fun(Message&lt;?> msg) &#123; System.out.println(msg.getMsg()); &#125; &#125; 在？这个通配符的基础上，实际上还提供了两类小的通配符： ?extends 类：设置泛型的上限 // 该泛型类型只允许设置Number类型或者Number之类 public static void fun(Message&lt;? extends Number> msg) &#123; System.out.println(msg.getMsg()); &#125; ?super 类：设置泛型的下限 // 只能传递String或者String的父类的Message public static void fun(Message&lt;? super String> msg) &#123; System.out.println(msg.getMsg()); &#125; 14.2 泛型接口 interface Message&lt;T> &#123; public String echo(T t); &#125; 实现类写法一 class MessageImpl&lt;T> implement Message&lt;T> &#123; public String echo(T t) &#123; System.out.println(\"echo:\" + t); &#125; &#125; 实现类写法二 class MessageImpl implements Message&lt;String> &#123; public String echo(String t) &#123; System.out.println(\"echo:\" + t); &#125; &#125; 14.3 泛型方法 将泛型写到方法上，就是泛型方法，但是需要注意的是，泛型方法不一定非要出现在泛型类中。 public &lt;T> T[] fun(T ... args) &#123; return args; &#125; 15 枚举 很多编程语言都会提供枚举的概念，但是java一直到JDK1.5之后才提出了枚举。枚举的主要作用用于定义有限个数对象的一种结构。 enum Season &#123; SPRING,SUMMER,AUTUMN,WINTER; // 实例化对象 &#125; public class test &#123; public static void main(String[] args) &#123; Season s = Season.SPRING; System.out.println(s); // 打印SPRING for(Season season : Season.values()) &#123; System.out.println(season); // 获取所有的值打印 &#125; &#125; &#125; 15.1 枚举类 所有枚举类型隐性的继承自java.lang.Enum这个抽象类。枚举实质上还是类，而每个被枚举的成员实质就是一个枚举类型的实例，他们默认都是**public final static**修饰的。可以直接通过枚举类型名使用他们。枚举类实现单例模式可以防止序列化和反射破坏单例 enum和Enum区别： enum：是JDK1.5之后提供的关键字，用来定义枚举类 Enum：是一个抽象类，所有使用enum关键字定义的类默认继承此类 enum EnumClass &#123; // 枚举对象要写在第一行 Obj1(\"lala1\"),Obj2(\"lala2\"); // 实例化对象 private String name; // 定义属性 EnumClass(String name) &#123; this.name = name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125; &#125; 上面的代码相当于干了什么？ class Obj1 &#123; private String name; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; Obj1(String name) &#123; this.name = name; &#125; &#125; class Obj2 &#123; private String name; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; Obj1(String name) &#123; this.name = name; &#125; &#125; // 然后，创建两个对象，将这两个对象放入枚举类中 Obj1 Obj1 = new Obj1(\"lala2\"); Obj2 Obj2 = new Obj2(\"lala1\"); // 可以通过如下方式获取 EnumClass obj1 = EnumClass.Obj1; EnumClass obj2 = EnumClass.Obj2; //Obj10lala1 System.out.println(obj1.name() + obj.ordinal() + obj1.getName()); obj1.setName(\"呼啦啦\"); // Obj10呼啦啦,打印对象的名字，序号和对象的name属性值 System.out.println(obj1.name() + obj1.ordinal() + obj1.getName()); 15.2 枚举实现接口 interface IMessage &#123; public String getMessage(String str); &#125; enum Season implements IMessage&#123; // 枚举对象要写在第一行 SPRING(\"春天\"),SUMMER(\"夏天\"),AUTUMN(\"秋天\"),WINTER(\"冬天\"); // 实例化对象 private String title; // 定义属性 private Seanson(String title) &#123; this.title = title; &#125; public String getTitle() &#123; return this.title; &#125; public String getMessage() &#123; return this.title; &#125; &#125; 15.3 枚举类中直接定义抽象方法 枚举类中直接定义抽象方法，并且要求每一个枚举对象都要独立覆写此抽象方法 enum EnumClass &#123; Obj1(\"lala1\") &#123; @Override public String getMessage() &#123; return \"lala1的getMessage\"; &#125; &#125;,Obj2(\"lala2\") &#123; @Override public String getMessage() &#123; return this.toString(); &#125; @Override public String toString() &#123; return \"$classname&#123;\" + \"name='\" + this.getName() + '\\'' + '&#125;'; &#125; &#125;; private String name; EnumClass(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public abstract String getMessage(); &#125; 16 异常 Java是采用面向对象的方式来处理异常。处理过程 抛出异常：在执行一个方法时，如果发生异常，则这个方法生成代表该异常的对象，停止当前执行路径，并把异常提交给jre 捕获异常：JRE得到异常后，寻找相应的代码来处理异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码为止。 16.1 自定义异常 public class CopyArray &#123; public static void main(String[] args) throws IOException &#123; Person p = new Person(); p.setAge(-10); &#125; &#125; class Person &#123; private int age; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; if(age &lt; 0) &#123; throw new IllegalAgeException(\"年龄不能为负数\"); &#125; this.age = age; &#125; &#125; class IllegalAgeException extends RuntimeException/Exception &#123; public IllegalAgeException() &#123;&#125; public IllegalAgeException(String msg) &#123; super(msg); &#125; &#125; 要避免使用异常处理代替错误处理，这样会降低程序的清晰性，并且效率低下 处理异常不可以代替简单测试，只在异常情况下使用异常机制 不要进行小粒度的异常处理，应该将整个任务包装在try语句块中 异常往往在高层处理 16.2 异常抛出 throw：写在方法内部 throws：写在方法上 17 内部类 在java中内部类主要分为成员内部类(静态内部类、非静态内部类)、匿名内部类、局部内部类。成员内部类可以使用private、default、protected、public任意进行修饰。 17.1 成员内部类 内部类最大的缺陷是破坏了程序的结构，但也有一定的好处：可以访问外部类的私有属性 17.1.1 非静态内部类 非静态内部类必须寄存在一个外部类对象里。因此，如果有一个非静态内部类对象，那么一定存在对应的外部类对象，非静态内部类对象单独属于外部类的某个对象 非静态内部类可以直接访问外部外部类的成员，但是外部类不能直接访问非静态内部类成员 非静态内部类不能有静态方法、静态属性和静态初始化块 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量，创建实例 成员变量访问要点 内部类里方法的局部变量：变量名 内部类属性：this.变量名 外部类属性：外部类名.this.变量名 public class Outer &#123; private String name = \"Outer外部类的name\"; private void outerPrint() &#123; // 访问outer的私有属性 System.out.println(name); // 访问outer的私有属性 System.out.println(this.name); // 创建一个内部类对象 Inner inner = new Inner(); // 访问内部类inner的私有属性 System.out.println(inner.name); // 调用内部类的私有方法 inner.innerPrint(); &#125; class Inner &#123; private String name = \"Inner内部类的name\"; private void innerPrint() &#123; // 访问inner的私有属性 System.out.println(name); // 访问inner的私有属性 System.out.println(this.name); // 访问outer的私有属性 System.out.println(Outer.this.name); &#125; &#125; &#125; 内部类本身也属于一个类，虽然大部分的情况下内部类往往是被外部类包裹的，但是外部依然可以产生内部类实例化对象，格式如下： 外部类.内部类 变量名 = new 外部类().new 内部类(); Outer.Inner in = new Outer().new Inner(); System.out.println(in.name); in.innerPrint(); 通过javac编译后，上面的例子会生成一个Outer&amp;Inner.class类文件，其中这个&quot;$“符号，到程序中就是”.&quot;，故内部类的全称就是&quot;外部类.内部类&quot;。因为内部类存在于外部类，故必须先有外部类，才能有内部类。 如果Inner类只能有Outer来使用，可以给该内部类设置private 17.1.3 static内部类 class Outer &#123; private static final MSG = \"haha\"; static class Inner &#123; public void print() &#123; System.out.println(Outer.MSG); &#125; &#125; public static void main(String[] args) &#123; Outer.Inner in = new Outer.Inner(); in.print(); &#125; &#125; 此时，这个Inner类是一个独立的类，如果此时想要实例化Inner类对象，需要“外部类.内部类”格式，要与上面不加static的内部类实例化进行对比。 17.2 匿名内部类 比较适合只需要用一次的类。比如：键盘监听操作等 new 父类构造器(实参列表)\\实现接口 () &#123; //匿名内部类类体 &#125; 匿名内部类没有访问修饰符 匿名内部类没有构造方法。 public class TestClass &#123; public static void main(String[] args) &#123; TestClass.test(new AA() &#123; @Override public void aa() &#123; System.out.println(\"ssas\"); &#125; &#125;); &#125; public static void test(AA a) &#123; a.aa(); &#125; &#125; interface AA &#123; void aa(); &#125; 17.3 方法中的内部类 class Outer &#123; private String msg = \"haha\"; public void fun(long time) &#123; String info = \"12\"; class Inner &#123; public void print() &#123; System.out.println(Outer.this.msg); System.out.println(time); System.out.println(info); &#125; &#125; // 方法中直接实例化内部类对象 new Inner().print(); &#125; &#125; 上述，想要内部类Inner直接访问参数time、方法的局部变量info，必须是JDK1.8之后才支持，因为有了Lambda表达式。而在之前需要在info、和time前添加final关键字。 public void fun(final long time) &#123; final String info = \"12\"; class Inner &#123; public void print() &#123; System.out.println(Outer.this.msg); System.out.println(time); System.out.println(info); &#125; &#125; 17.4 内部接口 interface Channal&#123; public void sendChannal(Message msg); interface Message&#123; public String sendMessage(); &#125; &#125; public class ChannalImpl implements Channal&#123; @Override public void sendChannal(Message msg) &#123; System.out.println(\"hello\" + msg.sendMessage()); &#125; class MessageImpl implements Message &#123; @Override public String sendMessage() &#123; return \"呼啦啦\"; &#125; &#125; public static void main(String[] args) &#123; Channal c = new ChannalImpl(); c.sendChannal(((ChannalImpl)c).new MessageImpl()); &#125; &#125; 17.5 内部抽象类 内部抽象类可以定义在普通类、抽象类、接口内部都是可以的 interface Channal&#123; public void send(); abstract class AbstractMessage &#123; public abstract String getContent(); &#125; &#125; public class ChannalImpl implements Channal&#123; @Override public void send() &#123; AbstractMessage message = new MessageImpl(); System.out.println(message.getContent()); &#125; class MessageImpl extends AbstractMessage &#123; @Override public String getContent() &#123; return \"哗啦啦\"; &#125; &#125; public static void main(String[] args) &#123; Channal channal = new ChannalImpl(); channal.send(); &#125; &#125; 17.6 接口内部类实现 如果定义了一个接口，可以在内部利用类实现接口，在JDK1,8之后，接口中可以写static方法，不受实例化对象的控制 interface IChannal&#123; public void send(); class ChannalImpl implements IChannal &#123; @Override public void send() &#123; System.out.println(\"哗啦啦\"); &#125; &#125; public static IChannal getInstance() &#123; return new ChannalImpl(); &#125; &#125; public class ChannalImpl&#123; public static void main(String[] args) &#123; IChannal channal = IChannal.getInstance(); channal.send(); &#125; &#125; 18 Lambda 在JDK1.8之后，为了简化使用者进行代码的开发，专门提供了Lambda函数式编程。对于函数式编程较为出名的是Haskell、Scala，利用函数式编程可以避免掉面向对象编程中一些繁琐的处理问题。 以前的写法 interface Message &#123; public void send(String msg); &#125; public class Test&#123; public static void main(String[] args) &#123; Message msg = new Message() &#123; @Override public void send(String str) &#123; System.out.println(str); &#125; &#125;; msg.send(\"haha\"); &#125; &#125; 可以发现，核心语句只有一行，但还是要按照面向对象设计结构进行开发。 Lambda写法 interface Message &#123; public void send(String msg); &#125; public class Test&#123; public static void main(String[] args) &#123; Message msg = (str)->System.out.println(str); msg.send(\"haha\"); &#125; &#125; 要求：SAM（Single Abstract Method），在Message接口中**只能有一个抽象方法**，像这样的接口被称为函数式接口。 写法： ()-&gt;{}; (参数1,参数2)-&gt;{}; 只有一行语句，(参数1,参数2)-&gt;语句; 18.1 方法的引用 JDK1.8之后，提供方法引用，即，不同的方法名称可以描述同一个方法。 引用静态方法：类名称 :: static 方法名称; // p描述参数、R描述返回值 interface IFunction&lt;P, R> &#123; public R change(P p); &#125; public class Test&#123; public static void main(String[] args) &#123; IFunction&lt;Integer, String> fun = String::valueOf; String str = fun.change(100); System.out.println(str.length()); &#125; &#125; 引用某个示例对象的方法：实例化对象:: 普通方法 interface IFunction&lt;R> &#123; public R upper(); &#125; public class Test&#123; public static void main(String[] args) &#123; IFunction&lt;String> fun = \"haha\"::toUpperCase; String str = fun.upper(); System.out.println(str); &#125; &#125; 引用特定类型的方法：特定类::普通方法 interface IFunction&lt;P> &#123; public int compare(P p1, P p2); &#125; public class Test&#123; public static void main(String[] args) &#123; IFunction&lt;String> fun = String::compareTo; System.out.println(fun.compare(\"A\", \"a\")); &#125; &#125; 引用构造方法：类名称 :: new class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age='\" + age + '\\'' + '&#125;'; &#125; &#125; @FunctionalInterface interface IFunction&lt;R> &#123; public R create(String name, int age); &#125; public class Test &#123; public static void main(String[] args) &#123; IFunction&lt;Person> fun = Person :: new; System.out.println(fun.create(\"张三\", 20)); &#125; &#125; 18.2 内建函数式接口 java.util.funtion开发包，里面可以直接使用函数式接口，在这个包下面有几个核心接口可供使用。 功能性函数式接口：Function&lt;T,R&gt; @FunctionalInterface public interface Function&lt;T,R> &#123; public R apply(T t); &#125; public class Test &#123; public static void main(String[] args) &#123; Function&lt;String,Boolean> fun = \"**hello\"::startsWith; System.out.println(fun.apply(\"**\")); &#125; &#125; 消费型函数式接口，Consumer&lt;T&gt;：只能进行数据的处理操作，而没有任何的返回 @FunctionalInterface public interface Consumer&lt;T> &#123; void accept(T t); &#125; 供给型函数式接口：Supplier&lt;T&gt;，该方法没有接受参数，但是有返回值 @FunctionalInterface public interface Supplier&lt;T> &#123; T get(); &#125; 断言型函数式接口：进行判断处理 @FunctionalInterface public interface Predicate&lt;T> &#123; boolean test(T t); &#125; 19 UML UML是统一建模语言，本质就是利用图形化的形式来实现程序类关系的描述。 具体详情参考：UML各种图总结-精华 - 春风十里的情 - 博客园 19.1 类图 一般描述一个类结构描述，万网可以使用三层的结构来表示。 第一层：类名 第二层：属性 第三层：方法 如果要是一个普通类的名称，往往直接编写即可，如果是抽象类，使用斜体，但为了避免正体斜体部分，会在抽象类上加abstract 对于类中属性，可以使用&quot;访问权限 属性名称 ：属性类型&quot;，而对访问权限，通常考虑public（+），private（-），protected（#） 对于类中的方法采用的格式&quot;访问权限 方法名称() ： 返回值&quot;结构来描述，一般的方法都是public（+） 子类实现接口使用的是：三角和虚线 类的继承使用的是：三角和实线 实际使用的时候手画类图是无意义的，会先写代码，然后通过转换引擎将代码转为类图显示。 19.2 时序图 通过图形来表示程序的执行流程 19.3 用例图 描述程序的执行和分配，例如：现在如果是系统管理员可能拥有系统初始化、系统备份、公告发布的功能，而公告管理员只负责公告的管理，可以在设计书上写上一些用例图加以说明。","categories":[{"name":"java","slug":"java","permalink":"blog.silverbeats.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"blog.silverbeats.cn/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"blog.silverbeats.cn/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"silverbeats"},{"title":"外部排序","slug":"外部排序","date":"2020-10-25T12:50:37.000Z","updated":"2020-10-27T00:06:34.421Z","comments":false,"path":"外部排序/","link":"","permalink":"blog.silverbeats.cn/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/","excerpt":"","text":"1 内部排序 点击这里查看内部排序十大排序详情 2 外部排序 指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求，不断的在内存外存之间进行移动 2.1 磁盘文件排序 通常采用归并排序。 首先根据缓冲区的大小将外存上含有n个记录的文件分成若干长度为h的子文件，一次读入内存并利用有限的内部排序算法对它们进行排序，并将排序后得到的有序子文件重新写回外存，通常称这些有序子文件为归并段或顺串 然后对这些归并段进行逐趟归并，使归并段组逐渐由小到大至得到整个有序文件 外部排序的总时间 = 内部排序所需时间 +外存信息读写时间 + 内部归并所需时间 tES = r*tIS +d*tIO + S（n-1）tmg r：初始化划分归并段个数 tIS：每个归并段需要的时间 d：磁盘读写的次数 tIO：磁盘读写每次的时间 S：归并的趟数 tmg： 归并趟数 = ⌈logmr⌉ m为归并的路数，r为初始划分归并段的个数 2.1.1 多路平衡归并排序算法—败者树 通过增加归并路数，来减少操作磁盘的次数 败者树是树形选择排序的一种变形，本身是一棵完全二叉树。 在树形选择排序一节中，对于无序表&#123;49，38，65，97，76，13，27，49&#125;创建的完全二叉树如 图1 所示，构建此树的目的是选出无序表中的最小值。 这棵树与败者树正好相反，是一棵“胜者树”。因为树中每个非终端结点（除叶子结点之外的其它结点）中的值都表示的是左右孩子相比较后的较小值（谁最小即为胜者）。例如叶子结点 49 和 38 相对比，由于 38 更小，所以其双亲结点中的值保留的是胜者 38。然后用 38 去继续同上层去比较，一直比较到树的根结点。 而败者树恰好相反，其双亲结点存储的是左右孩子比较之后的失败者，而胜利者则继续同其它的胜者去比较。 例如还是图 1 中，叶子结点 49 和 38 比较，38 更小，所以 38 是胜利者，49 为失败者，但由于是败者树，所以其双亲结点存储的应该是 49；同样，叶子结点 65 和 97 比较，其双亲结点中存储的是 97 ，而 65 则用来同 38 进行比较，65 会存储到 97 和 49 的双亲结点的位置，38 继续做后续的胜者比较，依次类推。 胜者树和败者树的区别就是：胜者树中的非终端结点中存储的是胜利的一方；而败者树中的非终端结点存储的是失败的一方。而在比较过程中，都是拿胜者去比较。 如图 2 所示为一棵 5-路归并的败者树，其中 b0—b4 为树的叶子结点，分别为 5 个归并段中存储的记录的关键字。 ls 为一维数组，表示的是非终端结点，其中存储的数值表示第几归并段（例如 b0 为第 0 个归并段）。ls[0] 中存储的为最终的胜者，表示当前第 3 归并段中的关键字最小。 当最终胜者判断完成后，只需要更新叶子结点 b3 的值，即导入关键字 15，然后让该结点不断同其双亲结点所表示的关键字进行比较，败者留在双亲结点中，胜者继续向上比较。 例如，叶子结点 15 先同其双亲结点 ls[4] 中表示的 b4 中的 12 进行比较，12 为胜利者，则 ls[4] 改为 3，然后 12 继续同 ls[2] 中表示的 10 做比较，10 为胜者，然后 10 继续同其双亲结点 ls[1] 表示的 b1（关键字 9）作比较，最终 9 为胜者。整个过程如下图所示： 注意：为了防止在归并过程中某个归并段变为空，处理的办法为：可以在每个归并段最后附加一个关键字为最大值的记录。这样当某一时刻选出的冠军为最大值时，表明 5 个归并段已全部归并完成。（因为只要还有记录，最终的胜者就不可能是附加的最大值） 2.1.2 置换选择排序 上面介绍了增加 k-路归并排序中的 k 值来提高外部排序效率的方法，而除此之外，还有另外一条路可走，即减少初始归并段的个数m 初始归并段的个数m = ⌈n/l⌉（n 表示为外部文件中的记录数，l 表示初始归并段中包含的记录数） 如果要想减小 m 的值，在外部文件总的记录数 n 值一定的情况下，只能增加每个归并段中所包含的记录数 l。而对于初始归并段的形成，就不能再采用上一章所介绍的内部排序的算法，因为所有的内部排序算法正常运行的前提是所有的记录都存在于内存中，而内存的可使用空间是一定的，如果增加 l 的值，内存是盛不下的。 所以要另想它法，探索一种新的排序方法：置换—选择排序]算法。 例如已知初始文件中总共有 24 个记录，假设内存工作区最多可容纳 6 个记录，按照之前的选择排序算法最少也只能分为 4 个初始归并段。而如果使用置换—选择排序，可以实现将 24 个记录分为 3 个初始归并段，如图1 所示： 置换—选择排序算法的具体操作过程为： 首先从初始文件中输入 6 个记录到内存工作区中； 从内存工作区中选出关键字最小的记录，将其记为 MINIMAX 记录； 然后将 MINIMAX 记录输出到归并段文件中； 此时内存工作区中还剩余 5 个记录，若初始文件不为空，则从初始文件中输入下一个记录到内存工作区中； 从内存工作区中的所有比 MINIMAX 值大的记录中选出值最小的关键字的记录，作为新的 MINIMAX 记录； 重复过程 3—5，直至在内存工作区中选不出新的 MINIMAX 记录为止，由此就得到了一个初始归并段； 重复 2—6，直至内存工作为空，由此就可以得到全部的初始归并段。 拿图 1 中的初始文件为例，首先输入前 6 个记录到内存工作区，其中关键字最小的为 29，所以选其为 MINIMAX 记录，同时将其输出到归并段文件中，如下图所示： 此时初始文件不为空，所以从中输入下一个记录 14 到内存工作区中，然后从内存工作区中的比 29 大的记录中，选择一个最小值作为新的 MINIMAX 值输出到 归并段文件中，如下图所示： 初始文件还不为空，所以继续输入 61 到内存工作区中，从内存工作区中的所有关键字比 38 大的记录中，选择一个最小值作为新的 MINIMAX 值输出到归并段文件中，如下图所示： 如此重复性进行，直至选不出 MINIMAX 值为止，如下图所示： 当选不出 MINIMAX 值时，表示一个归并段已经生成，则开始下一个归并段的创建，创建过程同第一个归并段一样，这里不再赘述。 在上述创建初始段文件的过程中，需要不断地在内存工作区中选择新的 MINIMAX 记录，即选择不小于旧的 MINIMAX 记录的最小值，此过程需要利用“败者树”来实现。 同之前所用到的败者树不同的是，在不断选择新的 MINIMAX 记录时，为了防止新加入的关键字值小的影响，每个叶子结点附加一个序号位，当进行关键字的比较时，先比较序号，序号小的为胜者；序号相同的关键字值小的为胜者。 在初期创建败者树时也可以通过不断调整败者树的方式，其中所有记录的序号均设为 0 ，然后从初始文件中逐个输入记录到内存工作区中，自下而上调整败者树。过程如下： 首先创建一个空的败者树，如下图所示： 提示：败者树根结点上方的方框内表示的为最终的胜者所处的位置。 2、从初始文件中读入关键字为 51 的记录，自下往上调整败者树，如下图所示： 提示：序号 1 默认为比 0 小，为败者。 3、从初始文件中读入关键字为 49 的记录，调整败者树如下图所示： 4、从初始文件依次读入关键字为 39、46、38、29 的记录，调整败者树如下图所示： 由败者树得知，其最终胜者为 29，设为 MINIMAX 值，将其输出到初始归并文件中，同时再读入下一个记录 14，调整败者树，如下图所示： 注意：当读入新的记录时，如果其值比 MINIMAX 大，其序号则仍为 1；反之则为 2 ，比较时序号 1 比序号 2的记录大。 通过不断地向败者树中读入记录，会产生多个 MINIMAX，直到最终所有叶子结点中的序号都为 2，此时产生的新的 MINIMAX 值的序号 2，表明此归并段生成完成，而此新的 MINIMAX 值就是下一个归并段中的第一个记录。 通过置换选择排序算法得到的初始归并段，其长度并不会受内存容量的限制，且通过证明得知使用该方法所获得的归并段的平均长度为内存工作区大小的两倍。 证明此结论的方法是 E.F.Moore（人名）在 1961 年从置换—选择排序和扫雪机的类比中得出的 若不计输入输出的时间，通过置换选择排序生成初始归并段的所需时间为O(nlogw)（其中 n 为记录数，w 为内存工作区的大小）。 2.1.3 最佳归并树 （9+30+12+18+3+17+2+6+24）22=484（上图中涉及到了两次归并，对外存的读和写各进行 2 次） 通过上面例子得到的归并树，得到的总IO次数不是最佳的，可以通过构造哈夫曼树来得到最小的IO次数 (23+33+63+92+122+172+182+242+30)*2=446 【补充构造哈夫曼树】 对于如何判断是否需要增加虚段，以及增加多少虚段的问题，有以下结论直接套用即可： 在一般情况下，对于 k–路平衡归并来说，若u= (m-1)MOD(k-1)=0，则不需要增加虚段；否则需附加 k-u-1 个虚段。 比如：初始归并段数量为9，3-路平衡归并， (9-1)MOD(3-1)=0 比如：初始归并段数量为8，3-路平衡归并， (8-1)MOD(3-1)=1≠0 需要附加3-1-1 = 1个虚段 2.2 磁带文件排序","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"blog.silverbeats.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"silverbeats"},{"title":"查找","slug":"查找","date":"2020-10-25T12:49:57.000Z","updated":"2020-10-27T00:29:51.642Z","comments":false,"path":"查找/","link":"","permalink":"blog.silverbeats.cn/%E6%9F%A5%E6%89%BE/","excerpt":"","text":"术语 说明 查找 在数据集合中寻找满足某种条件的数据元素的过程 查找表 用于查找的数据集合，由同一种数据类型(或记录)组成，可以是一个数组或者链表等数据类型。操作：①查询某个特定的数据元素是否在查找表中②检索满足条件的某个特定的数据元素的各种属性③在查找表中插入一个数据元素④从查找表中删除一个元素 静态查找表 只有上述①②操作，称为静态查找表 动态查找表 上述操作①—④都有 关键字 数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果唯一 平均查找长度ASL 查找时，关键字比较次数的平均值 1 顺序查找 顺序查找：又称为线性查找，主要用于在线性表中进行查找 静态查找表用顺序存储结构表示时，顺序查找的查找过程为：从表中的最后一个数据元素开始，逐个同记录的关键字做比较，如果匹配成功，则查找成功；反之，如果直到表中第一个关键字查找完也没有成功匹配，则查找失败。 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; #define KeyType int #define MAX_SIZE 10 &#x2F;&#x2F; 元素类型结构体 struct ElemType &#123; KeyType keyword; &#125;; &#x2F;&#x2F; 顺序表结构体 struct SSTable &#123; ElemType *elem; &#x2F;&#x2F; 顺序表中的数据量 int length; &#125;; SSTable * initSSTable() &#123; SSTable *table &#x3D; new SSTable(); table-&gt;length &#x3D; MAX_SIZE; table-&gt;elem &#x3D; (ElemType *)malloc(MAX_SIZE*sizeof(ElemType)); for(int i &#x3D; 0; i &lt; MAX_SIZE; i++) &#123; table-&gt;elem[i].keyword &#x3D; (32+i*5)&#x2F;4; &#125; return table; &#125; int Search_Seq(SSTable *table, KeyType key) &#123; for(int i &#x3D; 0; i &lt; table-&gt;length; i++) &#123; printf(&quot;当前查找的顺序表key为%d\\n&quot;,table-&gt;elem[i].keyword); if(key &#x3D;&#x3D; table-&gt;elem[i].keyword)&#123; printf(&quot;key为%d的下标是%d\\n&quot;,key,i); return i; &#125; &#x2F;&#x2F; 当为有序的查找表时，可以加上这两行代码，减少查找失败时，耗费的查找次数 if(key &lt; table-&gt;elem[i].keyword) break; &#125; cout &lt;&lt; &quot;没有找到key为&quot;&lt;&lt;key&lt;&lt;&quot;的元素&quot; &lt;&lt; endl; return -1; &#125; void display(SSTable *table) &#123; for(int i &#x3D; 0; i &lt; table-&gt;length; i++) &#123; printf(&quot;下标：%d——key：%d\\n&quot;,i,table-&gt;elem[i].keyword); &#125; &#125; int main() &#123; SSTable *s &#x3D; initSSTable(); cout &lt;&lt; &quot;打印表：&quot;&lt;&lt; endl; display(s); Search_Seq(s, 14); return 0; &#125; 当查找表无序时 一共n个元素，从头找。 要找的正好在第一个：一次比较 要找的正好在第二个：二次比较 …… 要找的正好在第n个：n次比较 一共需要比较：(1+n)n/2 假设查找每个位置的概率相等，都为1/n ASL成功 = 1/n * (1+n)n/2 = (n+1)/2 ASL失败 = n（倘若有哨兵，则n+1次） 有序的查找表 2 折半查找 类比1-100猜数字，每次猜中间，给你“大了”，“小了”快速缩小答案范围，最多猜log2n + 1次即可得到答案 折半查找：又称二分查找，仅适用于有序的顺序表 int Search_Seq(SSTable *table, KeyType key) &#123; int low &#x3D; 0, high &#x3D; table-&gt;length-1; while(low &lt;&#x3D; high) &#123; int mid &#x3D; (low + high) &gt;&gt; 1; printf(&quot;当前查找的顺序表key为%d\\n&quot;,table-&gt;elem[mid].keyword); if(table-&gt;elem[mid].keyword &#x3D;&#x3D; key) &#123; printf(&quot;key为%d的下标是%d\\n&quot;,key,mid); return mid; &#125; else if (table-&gt;elem[mid].keyword &gt; key) &#123; high &#x3D; mid -1; &#125; else &#123; low &#x3D; mid + 1; &#125; &#125; cout &lt;&lt; &quot;没有找到key为&quot;&lt;&lt;key&lt;&lt;&quot;的元素&quot; &lt;&lt; endl; return -1; &#125; 3 分块查找 分块查找：又称索引顺序查找，汲取顺序查找和折半查找各自的优点，既有动态结构，又适合快速查找 将查找表分为若干子块，块内的元素可以无序，但块间是有序的，即对于所有块有第i块的最大关键字小于第i+1块的所记录的关键字 上图中，查找表中共 18 个查找关键字，将其平均分为 3 个子表，对每个子表建立一个索引，索引中包含中两部分内容：该子表部分中最大的关键字以及第一个关键字在总表中的位置，即该子表的起始位置。 建立的索引表要求按照关键字进行升序排序，查找表要么整体有序，要么分块有序。 分块有序指的是第二个子表中所有关键字都要大于第一个子表中的最大关键字，第三个子表的所有关键字都要大于第二个子表中的最大关键字，依次类推。 块（子表）中各关键字的具体顺序，根据各自可能会被查找到的概率而定。如果各关键字被查找到的概率是相等的，那么可以随机存放；否则可按照被查找概率进行降序排序，以提高算法运行效率。 【查找过程】 以上图中的查找表为例，假设要查找关键字 38 的具体位置。首先将 38 依次和索引表中各最大关键字进行比较，因为 22 &lt; 38 &lt; 48，所以可以确定 38 如果存在，肯定在第二个子表中。 由于索引表中显示第二子表的起始位置在查找表的第 7 的位置上，所以从该位置开始进行顺序查找，一直查找到该子表最后一个关键字（一般将查找表进行等分，具体子表个数根据实际情况而定）。结果在第 10 的位置上确定该关键字即为所找。 提示：在第一步确定块（子表）时，由于索引表中按照关键字有序，所有可以采用折半查找。而在第二步中，由于各子表中关键字没有严格要求有序，所以只能采用顺序查找的方式。 【ASL】 设长度为n个查找表被均分层b块，每块s条记录 索引表和块内都是顺序查找 ASL成功 = (b+1)/2 + (s+1)/2 = (s2+2s+n)/2 索引表用二分查找，块内用顺序查找 ALS成功 = log2b + 1 + (s+1)/2 分块查找算法的运行效率受两部分影响：查找块的操作和块内查找的操作。查找块的操作可以采用顺序查找，也可以采用折半查找（更优）；块内查找的操作采用顺序查找的方式。相比于折半查找，分块查找时间效率上更低一些；相比于顺序查找，由于在子表中进行，比较的子表个数会不同程度的减少，所有分块查找算法会更优。 总体来说，分块查找算法的效率介于顺序查找和折半查找之间。 4 B(B-)树 B-树，有时又写为B_树（其中的“-”或者“_”只是连字符，并不读作“B减树”），又称多路平衡查找树，一颗 m 阶（所有结点的孩子结点数的最大值称为B树的阶）的 B-树，或者本身是空树，否则必须满足以下特性： 树中每个结点至多有 m 棵子树（即最多含有m-1个关键字）； 若根结点不是叶子结点，则至少有两棵子树； 除根之外的所有非终端结点至少有⌈m/2⌉棵子树； 所有的非终端结点中包含下列信息数据：（n，A0，K1，A1，K2，A2，…，Kn，An）； n 表示结点中包含的关键字的个数，取值范围是：⌈m/2⌉-1≤ n ≤m-1。Ki （i 从 1 到 n）为关键字，且 Ki &lt; Ki+1 ；Ai 代表指向子树根结点的指针，且指针 Ai-1 所指的子树中所有结点的关键字都小于 Ki，An 所指子树中所有的结点的关键字都大于 Kn。 如图 1 所示，当前结点中有 4 个关键字，之间的关系为：K1&lt;K2&lt;k3&lt;K4。同时对于 A0 指针指向的子树中的所有关键字来说，其值都要比 K1 小；而 A1 指向的子树中的所有的关键字的值，都比 K1 大，但是都要比 K2 小。 所有的叶子结点都出现在同一层次，实际上这些结点都不存在，指向这些结点的指针都为 NULL； 例如图 2 所示就是一棵 4 阶的 B-树，这棵树的深度为 4 ： 在使用 B-树进行查找操作时，例如在如图 2 所示的 B-树中查找关键字 47 的过程为： 从整棵树的根结点开始，由于根结点只有一个关键字 35，且 35 &lt; 47 ，所以如果 47 存在于这棵树中，肯定位于 A1 指针指向的右子树中； 然后顺着指针找到存有关键字 43 和 78 的结点，由于 43 &lt; 47 &lt; 78，所以如果 47 存在，肯定位于 A1 所指的子树中； 然后找到存有 47、53 和 64 三个关键字的结点，最终找到 47 ，查找操作结束； 以图 2 中的 B-树为例，若查找到深度为 3 的结点还没结束，则会进入叶子结点，但是由于叶子结点本身不存储任何信息，全部为 NULL，所以查找失败。 n个关键字，阶数为m，高度为h的B树 logm(n+1) ≤ h ≤ log⌈m/2⌉((n+1)/2) + 1 在具体实现上，在B树中找结点，是在磁盘上查找，在结点中找关键字，是在内存中进行 4.1 B-树中插入关键字（构建B-树） B-树也是从空树开始，通过不断地插入新的数据元素构建的。但是 B-树构建的过程同二叉排序树和平衡二叉树不同，B-树在插入新的数据元素时并不是每次都向树中插入新的结点。 因为对于 m 阶的 B-树来说，在定义中规定所有的非终端结点（终端结点即叶子结点，其关键字个数为 0）中包含关键字的个数的范围是[⌈m/2⌉-1,m-1]，所以在插入新的数据元素时，首先向最底层的某个非终端结点中添加，如果该结点中的关键字个数没有超过 m-1，则直接插入成功，否则还需要继续对该结点进行处理。 假设现在图 3 的基础上插入 4 个关键字 30、26、85 和 7： 插入关键字 30 ：从根结点开始，由于 30 &lt; 45，所以要插入到以 b 结点为根结点的子树中，再由于 24 &lt; 30，插入到以 d 结点为根结点的子树中，由于 d 结点中的关键字个数小于 m-1=2，所以可以将关键字 30 直接插入到 d 结点中。结果如下图所示： 插入关键字 26：从根结点开始，经过逐个比较，最终判定 26 还是插入到 d 结点中，但是由于 d 结点中关键字的个数超过了 2，所以需要做如下操作： 关键字 37 及其左右两个指针存储到新的结点中，假设为 d’ 结点； 关键字 30 存储到其双亲结点 b 中，同时设置关键字 30 右侧的指针指向 d’； 经过以上操作后，插入 26 后的B-树为： 插入关键字 85：从根结点开始，经过逐个比较，最终判定插入到 g 结点中，同样需要对 g 做分裂操作： 关键字 85 及其左右两个指针存储到新的结点中，假设为 g’ 结点； 关键字 70 存储到其双亲结点 e 中，同时设置 70 的右侧指针指向 g’ ； 经过以上操作后，插入 85 后的结果图为： 图 6 中，由于关键字 70 调整到其双亲结点中，使得其 e 结点中的关键字个数超过了 2，所以还需进一步调整： 将 90 及其左右指针存储到一个新的结点中，假设为 e’ 结点； 关键字 70 存储到其双亲结点 a 中，同时其右侧指针指向 e’ ; 最终插入关键字 85 后的 B-树为： 插入关键字 7：从根结点开始依次做判断，最终判定在 c 结点中添加，添加后发现 c 结点需要分裂，分裂规则同上面的方式一样，结果导致关键字 7 存储到其双亲结点 b 中；后 b 结点分裂，关键字 24 存储到结点 a 中；结点 a 同样需要做分裂操作，最终 B-树为： 通过上边的例子，可以总结出一下结论：在构建 B-树的过程中，假设 p 结点中已经有 m-1 个关键字，当再插入一个关键字之后，此结点分裂为两个结点，如下图所示： 提示：如图 9所示，结点分裂为两个结点的同时，还分裂出来一个关键字 K⌈m/2⌉，存储到其双亲结点中。 4.2 B-树中删除关键字 在 B-树种删除关键字时，首先前提是找到该关键字所在结点，在做删除操作的时候分为两种情况，一种情况是删除结点为 B-树的非终端结点（不处在最后一层）；另一种情况是删除结点为 B-树最后一层的非终端结点。 1）直接删除 倘若被删除的关键字所在的结点关键字总数＞⌈m/2⌉ - 1，表明删除后仍然满足B树定义，可以直接删除 2）兄弟够借 倘若将该关键字删除后，其所在结点的关键字数量不符合B树的定义（关键字数量至少是⌈m/2⌉-1），那么需要从兄弟结点借关键字。 从左兄弟借。选择被删除关键字结点与左兄弟结点中间夹着的双亲结点关键字A，将A挪动到被删除结点中，并用左兄弟结点中最大的关键字代替A。详情见下文具体操作。 从右兄弟借。选择被删除关键字结点与右兄弟结点中间夹着的双亲结点关键字A，将A挪动到被删除结点中，并用左兄弟结点中最小的关键字代替A。详情见下文具体操作。 3）兄弟不够借 例如图 3 来说，关键字 24、45、53、90属于不处在最后一层的非终端结点，关键字 3、12、37等同属于最后一层的非终端结点。 如果该结点为非终端结点且不处在最后一层，假设用 Ki 表示，则只需要找到指针 Ai 所指子树中最小的一个关键字代替 Ki，同时将该最小的关键字删除即可。 例如图 3 中，如果要删除关键字 45 ，只需要使用关键字 50 代替 45 ，同时删除 f 结点中的 50 即可。 如果该结点为最后一层的非终端结点，有下列 3 种可能： 被删关键字所在结点中的关键字数目不小于⌈m/2⌉，则只需从该结点删除该关键字 Ki 以及相应的指针 Ai 。 例如，在图 3 中，删除关键字 12 ，只需要删除该关键字 12以及右侧指向 NULL 指针即可。 被删关键字所在结点中的关键字数目等于⌈m/2⌉-1，而与该结点相邻的右兄弟结点（或者左兄弟）结点中的关键字数目大于⌈m/2⌉-1，只需将该兄弟结点中的最小（或者最大）的关键字上移到双亲结点中，然后将双亲结点中小于（或者大于）且紧靠该上移关键字的关键字移动到被删关键字所在的结点中。 例如在图 3 中删除关键字 50，其右兄弟结点 g 中的关键字大于2，所以需要将结点 g 中最小的关键字 61 上移到其双亲结点 e 中（由此 e 中结点有：53，61，90），然后将小于 61 且紧靠 61 的关键字 53 下移到结点 f 中，最终删除后的 B-树如图 10 所示。 被删除关键字所在的结点如果和其相邻的兄弟结点中的关键字数目都正好等于⌈m/2⌉-1，假设其有右兄弟结点，且其右兄弟结点是由双亲结点中的指针 Ai 所指，则需要在删除该关键字的同时，将剩余的关键字和指针连同双亲结点中的 Ki 一起合并到右兄弟结点中。 例如，在图 10 中 B-树中删除关键字 53，由于其有右兄弟，且右兄弟结点中只有 1 个关键字。在删除关键字 53 后，结点 f 中只剩指向叶子结点的空指针，连同双亲结点中的 61（因为 61 右侧指针指向的兄弟结点 g）一同合并到结点 g 中，最终删除 53 后的 B-树为： 在合并的同时，由于从双亲结点中删除一个关键字，若导致双亲结点中关键字数目小于⌈m/2⌉-1，则继续按照该规律进行合并。例如在图 11 中 B-树的情况下删除关键字 12 时，结点 c 中只有一个关键字，然后做删除关键字 37 的操作。此时在删除关键字 37 的同时，结点 d 中的剩余信息（空指针）同双亲结点中的关键字 24 一同合并到结点 c 中，效果图为： 由于结点 b 中一个关键字也没有，所以破坏了B-树的结构，继续整合。在删除结点 b 的同时，由于 b 中仅剩指向结点 c 的指针，所以连同其双亲结点中的 45 一同合并到其兄弟结点 e 中，最终的B-树为： 5 B+树 一棵m阶B+树满足如下特性： 每个分支结点最多有m棵子树（子结点） 若根节点不是终端结点，则至少有两棵子树 除根节点外的所有非叶结点至少有⌈m/2⌉棵子树，子树和关键字个数相等 所有叶结点包含全部关键字及指向响应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻结点按大小顺序连接起来 所有分支结点（可视为索引的索引）中仅包含它的各个子结点（下一级索引）中关键字的最大值及指向其子结点的指针 B树 B+树 具有n个关键字的结点含有n+1棵子树 n个关键字的结点有n棵子树 叶结点包含信息，所有非叶结点仅起到索引的作用。非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树关键字的指针，不含有该关键字对应记录的存储地址 叶结点包含的关键字和其他结点包含的关键字是不重复的 叶结点包含全部的关键字，即在非叶结点中出现的关键字也会出现在叶结点中 6 散列表 散列函数：把查找表中的关键字映射成该关键字对应的地址的函数 散列表：根据关键字而直接进行访问的数据结构，它建立了关键字与存储地址之间的一种直接映射关系 6.1 散列函数的构造 Hash(key) = Addr 1）散列函数的定义域必须包含全部需要存储的关键字，而值域的 范围依赖于散列表的大小或地址范围 2）散列函数计算出来的地址应该能等概率、均匀分布在整个地址空间中，从而减少冲突的发生 3）散列函数应尽量简单，能够在较短的时间内计算出任一关键字对应的散列地址 6.1.1 直接定值法 Hash(key) = a*key + b 方法简单，不会产生冲突，但是若关键字分布不连续，则会浪费空间 6.1.2 除留取余法 Hash(key) = key % p 选好p是关键，可以减少冲突的可能 【p的选择】 假定散列表表长为m，取一个不大于m但最接近或等于m的质数p 6.1.3 数字分析法 6.1.4 平方取中法 6.1.5 折叠法 6.2 冲突处理 6.2.1 开放定址法 开放定址法：是指可以存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。 Hi = (H(key) + di) % m，i = 0,1,2……,k(k ≤ m-1)，m为散列表表长（4k+3），di为增量 【计算di】 线性探测法 di = 0,1,2,3,4……,m-1 平方探测法 di = 02，12，-12，22，-22……，k2，-k2（k≤m/2） 可以避免堆积问题，缺点是不能探测到散列表上的所有单元 再散列法 di = i * Hash2(key) 伪随机序列法 di = 伪随机序列 在开放定址法不能随便删除某个元素 6.2.2 拉链法 把所有同义词存放在一个线性表中，这个线性链表由地址唯一标识，即散列表中每个单元存放该链表的表头指针 拉链法适用于经常进行插入和删除的情况 6.3 散列表查找效率 查找效率和散列函数、处理冲突的方法和填装因子相关。 填装因子一般记为α = 表中记录n数/散列表长度m，表示表的装满程度","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"blog.silverbeats.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"silverbeats"},{"title":"图","slug":"图","date":"2020-10-25T12:49:47.000Z","updated":"2020-10-25T13:38:56.056Z","comments":false,"path":"图/","link":"","permalink":"blog.silverbeats.cn/%E5%9B%BE/","excerpt":"","text":"1 逻辑结构 1.1 图的定义 图G由顶点集V和边集E组成，记为G=（V，E），其中V(G)表示图G中顶点的有限非空集，E(G)表示图G中顶点之间的关系（边）集合。|V|表示图G中顶点的个数，也称图G的阶；|E|表示图G中边的条数 1.2 相关概念 术语 说明 无向图&amp;有向图 图的边是否有方向。无向图的边没有方向，用括号表示如：(v,w)有向图的边区分起始点和终止点，有向图的边又称弧，用尖括号表示，如&lt;v,w&gt; 简单图 无重复边，不存在结点到自身的边 多重图 非简单图 无向完全图 任意两个顶点之间都存在边。n个顶点有n(n-1)/2条边 有向完全图 任意两个顶点之间都存在方向相反的弧，n个顶点有n(n-1)条弧 子图 设有两个图G=（V，E），G’’=（V’’，E’’），若V’'是V的子集，E’'是E的子集，则成G’'是G的子图 连通 针对无向图。若从顶点v到顶点w有路径存在，称v和w是连通的 连通图 任意两个结点之间都是连通的。n个顶点的连通图最少有n-1条边。 强连通 针对有向图。顶点v到w，以及顶点w到v都有路径，则称v与w强连通。 强连通图 任意两个结点之间都是强连通的。n个顶点的强连通图最少有n条边 连通分量&amp;&amp;强连通分量 极大（强）连通子图。对于G的一个（强）连通子图G’，如果不存在G的另一个（强）连通子图G’‘，使得G’⊂G’’，则称G’为G的（强）连通分量。（强）连通图，（强）连通分量与原图一致，非（强）连通图，则有多个（强）连通分量 极小连通子图 满足连通图的情况下，且包含的边最少的子图 生成树 连通图，且包含全部顶点的一个极小连通子图。不唯一，n个顶点图的生成树有n-1条边 生成森林 非连通图所有连通分量的生成树组成生成森林 顶底的度 ①无向图中，某顶点的度即为和此顶点相连边的数目。n个顶点，e条边的无向图中的度总数为2e②有向图中，顶点的度 = 入度 + 出度，n个顶点，e条边的有向图中出度 = 入度 = e 网 给图中的每条边增加一个权重 稠密图&amp;&amp;稀疏图 稠不稠密，看边多不多。|E| &lt; |V|log|V| 有向树 一个顶点的入度为0，其余顶点的入度为1的有向图 路径 图中顶点v到w的顶点序列，序列中顶点不重复的路径称为简单路径 路径长度 路径上边的 数目，若该路径最短则称距离 回路 第一个顶点和最后一个顶点相同的路径 倘若回路中除起点终点之外的所有点不重复，则称简单回路 2 存储结构及操作 2.1 邻接矩阵 存储图，无非是存储点集（一位数组存储）和边集（二维数组存储）。 #define MaxVertexNum 100 typedef char VertexType; typedef in EdgeType; typedef struct &#123; VertexType Vex[MaxVertexNum]; EdgeType Edge[MaxVertexNum][MaxVertexNum]; int vexnum,arcnum; &#125;MGraph; 【性质】 邻接矩阵的空间复杂度O(n2) 无向图的邻接矩阵为对称矩阵 无向图中第i行（或第j列）非0元素（非正无穷）的个数为第i个顶点的度 有向图中第i行（或第j列）非0元素（非正无穷）的个数为第i个顶点的出度（入度） 设图G的邻接矩阵为A，矩阵An的含义 2.2 邻接表法 为每个顶点建立一个单链表存放与它相邻的边。 顶点表 采用顺序存储，每个数组元素存放顶点的数据和边表的头指针 边表 采用链式存储，单链表中存放与一个顶点相邻的所有边，一个链表结点表示一条从该顶点到链表结点顶点的边 #define MaxVertexNum 100 &#x2F;&#x2F; 边表结点 typedef struct ArcNode&#123; int adjvex; struct ArcNode *next; &#x2F;&#x2F; InfoType info; 边的权重 &#125;ArcNode; &#x2F;&#x2F; 顶点表 typedef struct VNode &#123; VertexType data; ArcNode *first; &#125;VNode,AdjList[MaxVertexNum]; &#x2F;&#x2F; 邻接表 typedef struct &#123; AdjList vetices; int vexnum,arcnum; &#125;ALGraph; 【性质】 若G为无向图，存储空间为O（|V| + 2|E|） 若G为有向图，存储空间为O（|V| + |E|） 邻接表适合存储稀疏图 若G为无向图，则结点的度为该结点边表的长度 若G为有向图，则结点的出度为该结点边表的长度，计算入度则要遍历整个邻接表 邻接表不唯一，边表结点的顺序根据算法和输入的不同可能会不同 邻接矩阵和邻接表比较 2.3 邻接多重表 无向图的一种链式存储 字段 说明 data 存放数据 firstedge 边表单链表头指针 ivex 该边的第一个端点 ilink 与第一个端点相邻的下一个边表结点指针 jvex 第二点端点 jlink 与第二个端点相邻的下一个边表结点指针 info 非必须 mark 非必须 #define MaxVertexNum 100 &#x2F;&#x2F; 边表 typedef struct ArcNode&#123; int ivex,jvex; struct ArcNode *ilink,*jlink; &#x2F;&#x2F; infoType info; &#x2F;&#x2F; bool mark; &#125;ArchNode; &#x2F;&#x2F; 顶点表 typedef struct VNode &#123; VertexType data; ArcNode *firstedge; &#125;VNode; &#x2F;&#x2F; 邻接多重表 typedef struct &#123; VNode adjmulist[MaxVertexNum]; int vexnum, arcnum; &#125;AMLGraph; 2.4 十字链表 有向图的一种链式存储结构，邻接表容易找到顶点的出度，但是不容易找该顶点的入度，因此有十字链表来解决这个问题。 说明 data 数据域。存放数据。 firstin 入边单链表第一个结点的头指针 firstout 出边单链表第一个结点的头指针 tailvex 尾域。存放该弧，弧尾的结点指针 headvex 头域。存放该弧，弧头的结点指针 hlink 指针域。下一个弧头相同的结点指针 tlink 指针域。下一个弧尾相同的结点指针 info 存放该边数据，比如权重。 #define MaxVertexNum 100 &#x2F;&#x2F; 边表结点 typedef struct ArcNode&#123; int tailvex,headvex; struct ArcNode *hlink, *tlink; &#x2F;&#x2F; InfoType info; 边的权重 &#125;ArcNode; &#x2F;&#x2F; 顶点表 typedef struct VNode&#123; VertexType data; ArcNode *firstin, *firstout; &#125;VNode,AdjList[MaxVertexNum]; &#x2F;&#x2F; 十字接表 typedef struct &#123; VNode xlist[MaxVertexNum]; int vexnum,arcnum; &#125;GLGraph; 2.5 十字链表VS邻接多重表 十字链表：解决邻接表存储有向图时，得入度难的问题 邻接多重表：解决邻接表存无向图时，重复存储边的问题 3 图的遍历 从图中某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次 3.1 广度优先遍历 空间复杂度：O(|V|) 时间复杂度： - 邻接矩阵：O(|V|^2^) - 邻接表法：O(|V| + |E|) bool visited[MAX_TREE_SIZE]; void BFSTraverse(Graph G) &#123; for(int i &#x3D; 0; i &lt; G.vexnum; i++) &#123; visited[i] &#x3D; false; &#125; InitQueue(Q); for(int i; i &lt; G.vexnum; i++) &#123; if(!visited[i]) BFS(G,i); &#125; &#125; void BFS(Graph G, int v) &#123; visit(v); visited[v] &#x3D; true; EnQueue(Q,v); while(!isEmpty(Q)) &#123; DeQueue(Q,v); for(w &#x3D; FirstNeighbor(G,v);w&gt;&#x3D;0;w &#x3D; NextNeighbor(G,v,w)) &#123; if(!visited[w])&#123; visit[w]; visited[w] &#x3D; true; EnQueue(Q,w); &#125; &#125; &#125; &#125; 【无权图单源最短路径问题】 定义从顶点u到顶点v经过边数最少的路径称为最短路径d(u,v)。如若u到v没有路径，则d(u,v) = ∞ void BFS_MIN_Distance(Graph G, int u) &#123; &#x2F;&#x2F; d为距离数组，数组长度为顶点的数量，每个位置初始化置为最大值 for(int i &#x3D; 0; i &lt; G.vexnum; i++) d[i] &#x3D; MAX; &#x2F;&#x2F; u结点访问标识位置为true visited[u] &#x3D; true; d[u] &#x3D; 0; &#x2F;&#x2F; u结点入队列 EnQueue(Q,u); &#x2F;&#x2F; 队列不为空，至少有u结点 while(!isEmpty(Q)) &#123; &#x2F;&#x2F; 将结点u出队列，另u为该结点的数组下标，哪个结点出队列，u就为出队列的结点所在数组下标 DeQueue(Q,u); &#x2F;&#x2F; w为与u结点第一个邻接点 for(w &#x3D; FirstNeighbor(G,u); w &gt;&#x3D; 0; w &#x3D; NextNeighbor(G,u,w)) &#123; if(!visit[w]) &#123; visited[w] &#x3D; true; d[w] &#x3D; d[u] + 1; EnQuene(Q,w); &#125; &#125; &#125; &#125; 【广度优先生成树】 在广度遍历过程中，可以得到一颗遍历树，称为广度优先生成树（生成森林） 结点1入队列，队列Q={1} 结点1出队列，结点2,3入队列，队列Q={2,3} 结点2出队列，结点4,5入队列，队列Q={3,4,5} 结点3出队列，结点6入队列，队列Q={4,5,6} 结点4入队列，结点7入队列，队列Q={5,6,7} 结点5出队列 结点6出队列 结点7出队列 在广度优先遍历的过程中存在一个数组，用以标识每个结点是否被访问，放置重复遍历（比如结点4出队列后，结点5和7是要入队列的，此时就不满足每个结点只遍历一次这个要求，所以每个结点需要一个标识位用以判断是否被访问，判断在入队列前） 3.2 深度优先遍历 空间复杂度：O(|V|) 时间复杂度： 邻接矩阵法：O(|V|2) 邻接表法：O(|V| + |E|) 【搜索过程】 首先访问起始顶点v 接着由v出发访问v的任意一个邻接但未被访问的邻接顶点wi 然后再访问与wi邻接且未被访问的任意顶点yi 若wi没有邻接且未被访问的顶点时，退回到它的上一层顶点v 重复 bool visited[MAX_TREE_SIZE]; void DFSTraverse(Graph G) &#123; for(int i &#x3D; 0; i &lt; G.vexnuml i++) visited[i] &#x3D; false; for(int i &#x3D;0; i &lt; G.vexnum; i++) if(!visited[i])DFS(G,i); &#125; void DFS(Graph G, int v) &#123; visit(v); visited[v] &#x3D; true; for(w &#x3D; FirstNeighbor(G,v); w &gt;&#x3D; 0; w &#x3D; NextNeighbor(G,v,w)) &#123; if(!visited[w]) DFS(G,w); &#125; &#125; 邻接矩阵法的DFS(BFS)序列是唯一的，邻接表法的不唯一 3.3 遍历与连通性 无向图 在任意结点调用BFS或者DFS，倘若能访问所有的结点，说明是连通的 调用遍历函数（BFS或者DFS）次数为连通分量的个数。（这里的次数是指主函数中使用BFS或者DFS次数，BFS或DFS内部递归调用不算） 4 应用 4.1 最小生成树 对于带权的无向连通图G，G中所有生成树中边权值之和最小的生成树称为最小生成树(MST) 【性质】 最小生成树不一定唯一，可以有多个。 满足下列条件，MST唯一 各边权重不同 原图本身只有n-1条边，最小生成树是其本身 最小生成树无论有多少个，它们的权重之和是唯一的 最小生成树的边数 = n- 1 4.1.1 Prim算法 普里姆算法在找最小生成树时，将顶点分为两类，一类是在查找的过程中已经包含在树中的（假设为 A 类），剩下的是另一类（假设为 B 类）。 对于给定的连通网，起始状态全部顶点都归为 B 类。在找最小生成树时，选定任意一个顶点作为起始点，并将之从 B 类移至 A 类；然后找出 B 类中到 A 类中的顶点之间权值最小的顶点，将之从 B 类移至 A 类，如此重复，直到 B 类中没有顶点为止。所走过的顶点和边就是该连通图的最小生成树。 举例步骤如下： 假如从顶点A出发，顶点 B、C、D 到顶点 A 的权值分别为 2、4、2，所以，对于顶点 A 来说，顶点 B 和顶点 D 到 A 的权值最小，假设先找到的顶点 B： 继续分析顶点 C 和 D，顶点 C 到 B 的权值为 3，到 A 的权值为 4；顶点 D 到 A 的权值为 2，到 B 的权值为无穷大（如果之间没有直接通路，设定权值为无穷大）。所以顶点 D 到 A 的权值最小： 最后，只剩下顶点 C，到 A 的权值为 4，到 B 的权值和到 D 的权值一样大，为 3。所以该连通图有两个最小生成树： 普里姆算法的运行效率只与连通网中包含的顶点数相关，而和网所含的边数无关。所以普里姆算法适合于解决边稠密的网，该算法运行的 时间复杂度：O(n2)。 如果连通网中所含边的绸密度不高，则建议使用克鲁斯卡尔算法求最小生成树 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define VertexType int #define VRType int #define MAX_VERtEX_NUM 20 #define InfoType char #define INFINITY 65535 typedef struct &#123; VRType adj; &#x2F;&#x2F;对于无权图，用 1 或 0 表示是否相邻；对于带权图，直接为权值。 InfoType * info; &#x2F;&#x2F;弧额外含有的信息指针 &#125;ArcCell,AdjMatrix[MAX_VERtEX_NUM][MAX_VERtEX_NUM]; typedef struct &#123; VertexType vexs[MAX_VERtEX_NUM]; &#x2F;&#x2F;存储图中顶点数据 AdjMatrix arcs; &#x2F;&#x2F;二维数组，记录顶点之间的关系 int vexnum,arcnum; &#x2F;&#x2F;记录图的顶点数和弧（边）数 &#125;MGraph; &#x2F;&#x2F;根据顶点本身数据，判断出顶点在二维数组中的位置 int LocateVex(MGraph G,VertexType v)&#123; int i&#x3D;0; &#x2F;&#x2F;遍历一维数组，找到变量v for (; i&lt;G.vexnum; i++) &#123; if (G.vexs[i]&#x3D;&#x3D;v) &#123; return i; &#125; &#125; return -1; &#125; &#x2F;&#x2F;构造无向网 void CreateUDN(MGraph* G)&#123; scanf(&quot;%d,%d&quot;,&amp;(G-&gt;vexnum),&amp;(G-&gt;arcnum)); for (int i&#x3D;0; i&lt;G-&gt;vexnum; i++) &#123; scanf(&quot;%d&quot;,&amp;(G-&gt;vexs[i])); &#125; for (int i&#x3D;0; i&lt;G-&gt;vexnum; i++) &#123; for (int j&#x3D;0; j&lt;G-&gt;vexnum; j++) &#123; G-&gt;arcs[i][j].adj&#x3D;INFINITY; G-&gt;arcs[i][j].info&#x3D;NULL; &#125; &#125; for (int i&#x3D;0; i&lt;G-&gt;arcnum; i++) &#123; int v1,v2,w; scanf(&quot;%d,%d,%d&quot;,&amp;v1,&amp;v2,&amp;w); int m&#x3D;LocateVex(*G, v1); int n&#x3D;LocateVex(*G, v2); if (m&#x3D;&#x3D;-1 ||n&#x3D;&#x3D;-1) &#123; printf(&quot;no this vertex\\n&quot;); return; &#125; G-&gt;arcs[n][m].adj&#x3D;w; G-&gt;arcs[m][n].adj&#x3D;w; &#125; &#125; &#x2F;&#x2F;辅助数组，用于每次筛选出权值最小的边的邻接点 typedef struct &#123; VertexType adjvex;&#x2F;&#x2F;记录权值最小的边的起始点 VRType lowcost;&#x2F;&#x2F;记录该边的权值 &#125;closedge[MAX_VERtEX_NUM]; closedge theclose;&#x2F;&#x2F;创建一个全局数组，因为每个函数中都会使用到 &#x2F;&#x2F;在辅助数组中找出权值最小的边的数组下标，就可以间接找到此边的终点顶点。 int minimun(MGraph G,closedge close)&#123; int min&#x3D;INFINITY; int min_i&#x3D;-1; for (int i&#x3D;0; i&lt;G.vexnum; i++) &#123; &#x2F;&#x2F;权值为0，说明顶点已经归入最小生成树中；然后每次和min变量进行比较，最后找出最小的。 if (close[i].lowcost&gt;0 &amp;&amp; close[i].lowcost &lt; min) &#123; min&#x3D;close[i].lowcost; min_i&#x3D;i; &#125; &#125; &#x2F;&#x2F;返回最小权值所在的数组下标 return min_i; &#125; &#x2F;&#x2F;普里姆算法函数，G为无向网，u为在网中选择的任意顶点作为起始点 void miniSpanTreePrim(MGraph G,VertexType u)&#123; &#x2F;&#x2F;找到该起始点在顶点数组中的位置下标 int k&#x3D;LocateVex(G, u); &#x2F;&#x2F;首先将与该起始点相关的所有边的信息：边的起始点和权值，存入辅助数组中相应的位置，例如（1，2）边，adjvex为0，lowcost为6，存入theclose[1]中，辅助数组的下标表示该边的顶点2 for (int i&#x3D;0; i&lt;G.vexnum; i++) &#123; if (i !&#x3D;k) &#123; theclose[i].adjvex&#x3D;k; theclose[i].lowcost&#x3D;G.arcs[k][i].adj; &#125; &#125; &#x2F;&#x2F;由于起始点已经归为最小生成树，所以辅助数组对应位置的权值为0，这样，遍历时就不会被选中 theclose[k].lowcost&#x3D;0; &#x2F;&#x2F;选择下一个点，并更新辅助数组中的信息 for (int i&#x3D;1; i&lt;G.vexnum; i++) &#123; &#x2F;&#x2F;找出权值最小的边所在数组下标 k&#x3D;minimun(G, theclose); &#x2F;&#x2F;输出选择的路径 printf(&quot;v%d v%d\\n&quot;,G.vexs[theclose[k].adjvex],G.vexs[k]); &#x2F;&#x2F;归入最小生成树的顶点的辅助数组中的权值设为0 theclose[k].lowcost&#x3D;0; &#x2F;&#x2F;信息辅助数组中存储的信息，由于此时树中新加入了一个顶点，需要判断，由此顶点出发，到达其它各顶点的权值是否比之前记录的权值还要小，如果还小，则更新 for (int j&#x3D;0; j&lt;G.vexnum; j++) &#123; if (G.arcs[k][j].adj&lt;theclose[j].lowcost) &#123; theclose[j].adjvex&#x3D;k; theclose[j].lowcost&#x3D;G.arcs[k][j].adj; &#125; &#125; &#125; printf(&quot;\\n&quot;); &#125; int main()&#123; MGraph G; CreateUDN(&amp;G); miniSpanTreePrim(G, 1); &#125; 4.1.2 Kruskal算法 克鲁斯卡尔算法：从边的角度出发，时间复杂度为O(|E|log|E|)，时间复杂度只和边有关系，与普利姆算法（从顶点出发）相反，适合于求边稀疏的网的最小生成树 克鲁斯卡尔算法的具体思路是：将所有边按照权值的大小进行升序排序，然后从小到大一一判断，条件为：如果这个边不会与之前选择的所有边组成回路，就可以作为最小生成树的一部分；反之，舍去。直到具有 n 个顶点的连通网筛选出来 n-1 条边为止。筛选出来的边和所有的顶点构成此连通网的最小生成树。 判断是否会产生回路的方法为：在初始状态下给每个顶点赋予不同的标记，对于遍历过程的每条边，其都有两个顶点，判断这两个顶点的标记是否一致，如果一致，说明它们本身就处在一棵树中，如果继续连接就会产生回路；如果不一致，说明它们之间还没有任何关系，可以连接。 假设遍历到一条由顶点 A 和 B 构成的边，而顶点 A 和顶点 B 标记不同，此时不仅需要将顶点 A 的标记更新为顶点 B 的标记，还需要更改所有和顶点 A 标记相同的顶点的标记，全部改为顶点 B 的标记。 例如，使用克鲁斯卡尔算法找图 1 的最小生成树的过程为： 首先，在初始状态下，对各顶点赋予不同的标记（用颜色区别），如(1)所示： 对所有边按照权值的大小进行排序，按照从小到大的顺序进行判断，首先是（1，3），由于顶点 1 和顶点 3 标记不同，所以可以构成生成树的一部分，遍历所有顶点，将与顶点 3 标记相同的全部更改为顶点 1 的标记，如（2）所示： 其次是（4，6）边，两顶点标记不同，所以可以构成生成树的一部分，更新所有顶点的标记为： 其次是（2，5）边，两顶点标记不同，可以构成生成树的一部分，更新所有顶点的标记为： 然后最小的是（3，6）边，两者标记不同，可以连接，遍历所有顶点，将与顶点 6 标记相同的所有顶点的标记更改为顶点 1 的标记： 继续选择权值最小的边，此时会发现，权值为 5 的边有 3 个，其中（1，4）和（3，4）各自两顶点的标记一样，如果连接会产生回路，所以舍去，而（2，3）标记不一样，可以选择，将所有与顶点 2 标记相同的顶点的标记全部改为同顶点 3 相同的标记： 当选取的边的数量相比与顶点的数量小 1 时，说明最小生成树已经生成。所以最终采用克鲁斯卡尔算法得到的最小生成树如上图所示。 #include &quot;stdio.h&quot; #include &quot;stdlib.h&quot; #define MAX_VERtEX_NUM 20 #define VertexType int typedef struct edge&#123; VertexType initial; VertexType end; VertexType weight; &#125;edge[MAX_VERtEX_NUM]; &#x2F;&#x2F;定义辅助数组 typedef struct &#123; VertexType value;&#x2F;&#x2F;顶点数据 int sign;&#x2F;&#x2F;每个顶点所属的集合 &#125;assist[MAX_VERtEX_NUM]; assist assists; &#x2F;&#x2F;qsort排序函数中使用，使edges结构体中的边按照权值大小升序排序 int cmp(const void *a,const void*b)&#123; return ((struct edge*)a)-&gt;weight-((struct edge*)b)-&gt;weight; &#125; &#x2F;&#x2F;初始化连通网 void CreateUDN(edge *edges,int *vexnum,int *arcnum)&#123; printf(&quot;输入连通网的边数：\\n&quot;); scanf(&quot;%d %d&quot;,&amp;(*vexnum),&amp;(*arcnum)); printf(&quot;输入连通网的顶点：\\n&quot;); for (int i&#x3D;0; i&lt;(*vexnum); i++) &#123; scanf(&quot;%d&quot;,&amp;(assists[i].value)); assists[i].sign&#x3D;i; &#125; printf(&quot;输入各边的起始点和终点及权重：\\n&quot;); for (int i&#x3D;0 ; i&lt;(*arcnum); i++) &#123; scanf(&quot;%d,%d,%d&quot;,&amp;(*edges)[i].initial,&amp;(*edges)[i].end,&amp;(*edges)[i].weight); &#125; &#125; &#x2F;&#x2F;在assists数组中找到顶点point对应的位置下标 int Locatevex(int vexnum,int point)&#123; for (int i&#x3D;0; i&lt;vexnum; i++) &#123; if (assists[i].value&#x3D;&#x3D;point) &#123; return i; &#125; &#125; return -1; &#125; int main()&#123; int arcnum,vexnum; edge edges; CreateUDN(&amp;edges,&amp;vexnum,&amp;arcnum); &#x2F;&#x2F;对连通网中的所有边进行升序排序，结果仍保存在edges数组中 qsort(edges, arcnum, sizeof(edges[0]), cmp); &#x2F;&#x2F;创建一个空的结构体数组，用于存放最小生成树 edge minTree; &#x2F;&#x2F;设置一个用于记录最小生成树中边的数量的常量 int num&#x3D;0; &#x2F;&#x2F;遍历所有的边 for (int i&#x3D;0; i&lt;arcnum; i++) &#123; &#x2F;&#x2F;找到边的起始顶点和结束顶点在数组assists中的位置 int initial&#x3D;Locatevex(vexnum, edges[i].initial); int end&#x3D;Locatevex(vexnum, edges[i].end); &#x2F;&#x2F;如果顶点位置存在且顶点的标记不同，说明不在一个集合中，不会产生回路 if (initial!&#x3D;-1&amp;&amp; end!&#x3D;-1&amp;&amp;assists[initial].sign!&#x3D;assists[end].sign) &#123; &#x2F;&#x2F;记录该边，作为最小生成树的组成部分 minTree[num]&#x3D;edges[i]; &#x2F;&#x2F;计数+1 num++; &#x2F;&#x2F;将新加入生成树的顶点标记全不更改为一样的 for (int k&#x3D;0; k&lt;vexnum; k++) &#123; if (assists[k].sign&#x3D;&#x3D;assists[end].sign) &#123; assists[k].sign&#x3D;assists[initial].sign; &#125; &#125; &#x2F;&#x2F;如果选择的边的数量和顶点数相差1，证明最小生成树已经形成，退出循环 if (num&#x3D;&#x3D;vexnum-1) &#123; break; &#125; &#125; &#125; &#x2F;&#x2F;输出语句 for (int i&#x3D;0; i&lt;vexnum-1; i++) &#123; printf(&quot;%d,%d\\n&quot;,minTree[i].initial,minTree[i].end); &#125; return 0; &#125; 4.2 最短路径 最短路径 两个顶点之间带权路径长度最短的路径为最短路径。在带权图中，把从一个顶点v到另一个顶点u所经历的边的权值之和称为，路径的带权路径长度。 4.2.1 迪杰斯特拉（Dijkstra）算法 带权图单源最短路径，不适用于含有负权边的图 void Dijkstra(Graph G,int v) &#123; &#x2F;&#x2F; 初始化 int s[G.vexnum]; int path[G.vexnum]; int dist[G.vexnum]; for(int i &#x3D; 0; i &lt; G.vexnum; i++) &#123; dist[i] &#x3D; G.edge[v][i]; s[i] &#x3D; 0; if(G.edge[v][i] &lt; MAX) &#123; path[i] &#x3D; v; &#125; else &#123; path[i] &#x3D; -1; &#125; &#125; s[v] &#x3D; 1; path[v] &#x3D; -1; for(int i &#x3D; 0; i &lt; G.vexnum; i++)&#123; int min &#x3D; MAX: int u; for(int j &#x3D; 0; j &lt; G.vexnum; j++) &#123; if(S[j] &#x3D;&#x3D; 0 &amp;&amp; dist[j] &lt; min)&#123; min &#x3D; dist[j]; u &#x3D; j; &#125; &#125; s[u] &#x3D; 1; for(int j &#x3D; 0; j &lt; G.vexnum; j++) &#123; if(s[j] &#x3D;&#x3D; 0 &amp;&amp; dist[u] + G.Edge[i][j] &lt; dist[j]) &#123; dist[j] &#x3D; dist[u] + G.Edge[u][i]; path[j] &#x3D; u; &#125; &#125; &#125; &#125; 4.2.2 弗洛伊德（Floyd）算法 【算法思想】 弗洛伊德的核心思想是：对于网中的任意两个顶点（例如顶点 A 到顶点 B）来说，之间的最短路径不外乎有 2 种情况： 直接从顶点 A 到顶点 B 的弧的权值为顶点 A 到顶点 B 的最短路径； 从顶点 A 开始，经过若干个顶点，最终达到顶点 B，期间经过的弧的权值和为顶点 A 到顶点 B 的最短路径。 所以，弗洛伊德算法的核心为：对于从顶点 A 到顶点 B 的最短路径，拿出网中所有的顶点进行如下判断： Dis（A，K）+ Dis（K，B）&lt; Dis（A，B） 其中，K 表示网中所有的顶点；Dis（A，B） 表示顶点 A 到顶点 B 的距离。 也就是说，拿出所有的顶点 K，判断经过顶点 K 是否存在一条可行路径比直达的路径的权值小，如果式子成立，说明确实存在一条权值更小的路径，此时只需要更新记录的权值和即可。 任意的两个顶点全部做以上的判断，最终遍历完成后记录的最终的权值即为对应顶点之间的最短路径。 【例子】 例如，在使用弗洛伊德算法计算图 1 中的任意两个顶点之间的最短路径时，具体实施步骤为： 首先，记录顶点之间初始的权值，如下表所示： 依次遍历所有的顶点，假设从 V0 开始，将 V0 作为中间点，看每对顶点之间的距离值是否会更小。最终 V0 对于每对顶点之间的距离没有任何改善。 对于 V0 来说，由于该顶点只有出度，没有入度，所以没有作为中间点的可能。同理，V1也没有可能。 将 V2 作为每对顶点的中间点，有影响的为 （V0，V3） 和 （V1，V3）： 例如，（V0，V3）权值为无穷大，而（V0，V2）+（V2，V3）= 60，比之前的值小，相比而言后者的路径更短；同理 （V1，V3）也是如此。 更新的表格为： 以 V3 作为中间顶点遍历各队顶点，更新后的表格为： 以 V4 作为中间顶点遍历各队顶点，更新后的表格为： 而对于顶点 V5 来说，和顶点 V0 和 V1 相类似，所不同的是，V5 只有入度，没有出度，所以对各队顶点的距离不会产生影响。最终采用弗洛伊德算法求得的各个顶点之间的最短路径如上图所示。 #include &lt;stdio.h> #define MAX_VERtEX_NUM 20 //顶点的最大个数 #define VRType int //表示弧的权值的类型 #define VertexType int //图中顶点的数据类型 #define INFINITY 65535 typedef struct &#123; VertexType vexs[MAX_VERtEX_NUM]; //存储图中顶点数据 VRType arcs[MAX_VERtEX_NUM][MAX_VERtEX_NUM]; //二维数组，记录顶点之间的关系 int vexnum,arcnum; //记录图的顶点数和弧（边）数 &#125;MGraph; typedef int PathMatrix[MAX_VERtEX_NUM][MAX_VERtEX_NUM]; //用于存储最短路径中经过的顶点的下标 typedef int ShortPathTable[MAX_VERtEX_NUM][MAX_VERtEX_NUM]; //用于存储各个最短路径的权值和 //根据顶点本身数据，判断出顶点在二维数组中的位置 int LocateVex(MGraph * G,VertexType v)&#123; int i=0; //遍历一维数组，找到变量v for (; i&lt;G->vexnum; i++) &#123; if (G->vexs[i]==v) &#123; break; &#125; &#125; //如果找不到，输出提示语句，返回-1 if (i>G->vexnum) &#123; printf(\"no such vertex.\\n\"); return -1; &#125; return i; &#125; //构造有向网 void CreateUDG(MGraph *G)&#123; scanf(\"%d,%d\",&amp;(G->vexnum),&amp;(G->arcnum)); for (int i=0; i&lt;G->vexnum; i++) &#123; scanf(\"%d\",&amp;(G->vexs[i])); &#125; for (int i=0; i&lt;G->vexnum; i++) &#123; for (int j=0; j&lt;G->vexnum; j++) &#123; G->arcs[i][j]=INFINITY; &#125; &#125; for (int i=0; i&lt;G->arcnum; i++) &#123; int v1,v2,w; scanf(\"%d,%d,%d\",&amp;v1,&amp;v2,&amp;w); int n=LocateVex(G, v1); int m=LocateVex(G, v2); if (m==-1 ||n==-1) &#123; printf(\"no this vertex\\n\"); return; &#125; G->arcs[n][m]=w; &#125; &#125; //弗洛伊德算法，其中P二维数组存放各对顶点的最短路径经过的顶点，D二维数组存储各个顶点之间的权值 void ShortestPath_Floyed(MGraph G,PathMatrix *P,ShortPathTable *D)&#123; //对P数组和D数组进行初始化 for (int v=0; v&lt;G.vexnum; v++) &#123; for (int w=0; w&lt;G.vexnum; w++) &#123; (*D)[v][w]=G.arcs[v][w]; (*P)[v][w]=-1; &#125; &#125; //拿出每个顶点作为遍历条件 for (int k=0; k&lt;G.vexnum; k++) &#123; //对于第k个顶点来说，遍历网中任意两个顶点，判断间接的距离是否更短 for (int v=0; v&lt;G.vexnum; v++) &#123; for (int w=0; w&lt;G.vexnum; w++) &#123; //判断经过顶点k的距离是否更短，如果判断成立，则存储距离更短的路径 if ((*D)[v][w] > (*D)[v][k] + (*D)[k][w]) &#123; (*D)[v][w]=(*D)[v][k] + (*D)[k][w]; (*P)[v][w]=k; &#125; &#125; &#125; &#125; &#125; int main()&#123; MGraph G; CreateUDG(&amp;G); PathMatrix P; ShortPathTable D; ShortestPath_Floyed(G, &amp;P, &amp;D); for (int i=0; i&lt;G.vexnum; i++) &#123; for (int j=0; j&lt;G.vexnum; j++) &#123; printf(\"%d \",P[i][j]); &#125; printf(\"\\n\"); &#125; for (int i=0; i&lt;G.vexnum; i++) &#123; for (int j=0; j&lt;G.vexnum; j++) &#123; printf(\"%d \",D[i][j]); &#125; printf(\"\\n\"); &#125; return 0; &#125; 4.3 拓扑排序 有向无环图：不存在环的有向图，简称DAG图 AOV网：若用一个DAG图表示一个工程，其顶点表示活动，用有向边&lt;vi,vj&gt;表示活动vi先于活动vj进行的传递关系，则将这种DAG称为顶点表示活动网络，记为AOV网 拓扑排序：对DAG所有顶点的一种排序，使若存在一条从顶点A到顶点B的路径，在排序中B排在A的后面 【步骤】 从DAG中选择一个没有前驱的顶点并输出 从图中删除该顶点和所有以它为起点的有向边 重复上述步骤，直到当前DAG图为空或者当前图中不存在无前驱的顶点为止。后一种情况说明图中有环。 拓扑排序不一定唯一 O(|V|+|E|) bool TopologicalSort(Graph G) &#123; InitStack(s); for(int i &#x3D; 0; i &lt; G.vexnum; i++) &#123; if(indegree[i] &#x3D;&#x3D; 0) push(s,i); &#125; int count &#x3D; 0; while(!isEmpty(s)) &#123; pop(s,i); print[count++] &#x3D; i; for(p &#x3D; G.Vertices[i].firstarc; p; p&#x3D;p-&gt;next) &#123; v &#x3D; p-&gt;adjvex; if(!(--indegree[v])) push(s,v); &#125; &#125; if(count &lt; G.vexnum) return false; else return true; &#125; 若邻接矩阵为三角矩阵，则存在拓扑排序，反之不一定成立 4.4 关键路径 AOE网：在有向带权图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销（如完成活动需要的时间），则称这种有向图为用边表示活动的网络，简称AOE网 关键路径：从原点到汇点最大路径长度的路径称为关键路径，关键路径上的活动为关键活动 此时，d(i)为0的路径就是关键路径 {a2,a5,a7} 缩短关键活动的时间可以加快整个工程，但缩短到一定大小时，关键路径会发生变化 当网中关键路径不唯一时，只有加快关键活动或者关键活动组合包括在所有的关键路径上才能缩短工期 5 图的基本操作 操作 说明 Adjacent(G,x,y) 判断图G是否存在&lt;x,y&gt;或者(x,y) Neighbors(G,x) 列出图G与结点x邻接的边 InsertVertex(G,x) 在图G中插入顶点x DeleteVertex(G,x) 图G中删除顶点x AddEdge(G,x,y) 若所添加的边不存在，则添加（x,y）或者&lt;x,y&gt; RemoveEdge(G,x,y) 若该边存在，则删除 FirstNeighbor(G,x) 求G中顶点x的第一个邻接点，图中无x点或者没有找到，返回-1 NextNeighbor(G,x) y是x的一个邻接点，返回除y之外的顶点x的下一个邻接点顶点号，若y是x的最后一个邻接点，返回-1 Get_edge_value(G,x,y) 得到边的权重 Set_edge_value(G,x,y) 设置边的权重 Adjacent，判断图G是否存在某边 邻接矩阵 邻接表 无向图 O(1) O(|E|) 有向图 O(1) O(|E|) 邻接矩阵存储。只需要通过数组下标访问某个位置即可， 邻接表存储。需要遍历单链表 Neighbors，列出与所给结点邻接的边 邻接矩阵 邻接表 无向图 O(|V|) O(n),n≤|V| 有向图 O(2|V|) O(|E|) 有向图【邻接矩阵存储】，找结点出度和入度只需要遍历该结点所在的行与列，遍历的次数为2|V| 有向图【邻接表存储】，虽然某结点的出度很容易得到，但是统计某结点的入度需要遍历每个结点的链表。次数一共为|E| InsertVertex，插入 无向图/有向图【邻接矩阵】，插入结点，需要数组扩容，重新申请一个新数据，将旧数据拷贝（需要|V|2次），再将新结点与其他结点的填入扩充出来的位置中（需要|V|次），效率不高。 无向图/有向图，插入结点，需要扩充顶点表，旧数组中顶点表数据拷贝到新数组（|V|次），然后更新。效率会比邻接矩阵要高 DeleteVertex 对于邻接矩阵存储删除结点，可以使该结点的行与列置NULL，或者缩小矩阵来实现 AddEdge 邻接矩阵更快，直接修改矩阵中对应位置的值为1即可 邻接表，需要创建链表结点，再修改指针 RemoveEdge 邻接矩阵更快，直接修改数组中的元素数据 邻接表，找到对应的然后（费时间），然后删除","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"blog.silverbeats.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"silverbeats"},{"title":"树","slug":"树","date":"2020-10-25T12:49:33.000Z","updated":"2020-10-25T13:45:02.602Z","comments":false,"path":"树/","link":"","permalink":"blog.silverbeats.cn/%E6%A0%91/","excerpt":"","text":"树是n(n&gt;=0)个结点的有限集合，n=0时，称为空树，树是一种逻辑结构。而任意非空树应该满足： 1）有且仅有一个特定的称为根的结点 2）当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集合，其中每一个集合本身又是一棵树，称为根结点的子树 【相关概念】 术语 说明 祖先结点和子孙结点 A是所有结点的祖先结点，为根节点。B是EF的祖先结点，EF是B的子孙结点 双亲结点和孩子结点 B是E的双亲结点，E是B的孩子结点 兄弟节点 EF互为兄弟结点，BCD互为兄弟结点 度 树中一个结点的子结点的个数称为该结点的度。比如B的度为2，A的度为3 树的度 度中取最大值 分支结点 度大于0的结点 叶子结点 度为0的结点 结点的层次 见上图 结点的高度 从最底下一层向根节点累计。比如B结点的高度是3 结点的深度 与结点高度相反，从根节点开始，B结点的深度为2 树的高度(深度) 树中结点的最大层次 有序树和无序树 见下图。若为无序树，两个树相同，若为有序树，两个树不同 路径 树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的。树的分支是有向的，即从双亲结点指向孩子结点，所以路径一定是自上而下的。A到E的路径是ABE 路径长度 路径上所经历边的个数。A到E的路径长度为2 森林 m(m&gt;=0)棵互不相交的树的集合。比如上图去掉根节点A后，1棵树变3棵树 【树的性质】 树中的结点树等于所有结点的度+1 度为m的树中第i层上最多有mi-1个结点(i&gt;=1) 高度为h的m叉树至多有（mh-1）/（m-1）个结点 具有n个结点的m叉树的最小高度为⌈logm（n（m-1） + 1）⌉ 1 二叉树 1.1 二叉树的基本概念 1.1.1 定义及特点 二叉树是逻辑结构。 二叉树是n(n&gt;=0)个结点的有限集合。 n=0时，二叉树为空 n&gt;0时，由根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树也分别是一棵二叉树 概念 说明 满二叉树 一个高度为h的二叉树，且含有2h-1个结点的二叉树为满二叉树。 完全二叉树 设一个高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号1~n的结点一一对应，称为完全二叉树 二叉排序树 一个二叉树，若树非空则具有如下性质：对任意结点若存在左子树或右子树，则其左子树上所有结点的关键字均小于该结点，右子树上所有结点的关键字都大于该结点 平衡二叉树 树上任意结点的左子树和右子树的深度差不超过1 【满二叉树】 高度为h的m叉树，最多有（mh-1）/（m-1）个结点。 对于编号为i的结点，若存在，其双亲的编号为⌊i/2⌋，左孩子为2i，右孩子为2i+1 【完全二叉树】 若i≤⌊n/2⌋，则结点i为分支结点，否则为叶子结点 叶子结点只可能在层次最大的两层出现。对于最大层次的叶子结点，都依次排在最左边的位置上。 度为1的结点倘若存在，只可能存在一个，且是编号最大的分支结点，并孩子结点一定是左结点 【二叉排序树】 【平衡二叉树】 1.1.2 二叉树的性质 非空二叉树上的叶子结点树量等于度为2的结点数量加1，即n0=n2+1 非空二叉树上第k层上最多有2k-1个结点（k &gt;=1） 高度为h的二叉树至多有2h-1个结点（h &gt;=1） 结点i所在的层次为⌊log2i⌋+1 具有n个（n&gt;0）结点的完全二叉树的高度为⌊log2n⌋+1 或者⌈log2(n+ 1)⌉ 1.2 二叉树的存储结构 1.2.1 顺序存储 用一组连续的存储单元依次自上而下、自左至右存储完全二叉树的结点元素。顺序存储比较适合存储完全二叉树，通过利用第i个结点的左结点是2i，右结点是2i+1这条性质，来表达逻辑上的结构关系。 当存储的树不是完全二叉树时，上述所用的性质行不通，可以通过补结点的方式来将此树补成一颗完全二叉树。（倘若补的结点过多，会存在浪费的情况） 1.2.2 链式存储 用链表存放一棵二叉树，二叉树中每个结点用链表的一个链结点来存储 typedef struct BiTNode &#123; ElemType data; struct BiTNode *lchild, *rchild; &#125;BiTNode, *BiTree; ※含有n个结点的二叉链表，有n+1个空链域 1.3 二叉树的遍历 按某条搜索路径访问树中的每个结点，树的每个结点均被访问一次，而且只访问一次 1.3.1 前序遍历 根——&gt;左子树——&gt;右子树 上图遍历顺序：1 2 4 5 3 6 void PreOrder(BiTree T) &#123; if(T !&#x3D; NULL) &#123; visit(T); PreOrder(T-&gt;lchild); PreOrder(T-&gt;rchild); &#125; &#125; 1.3.2 中序遍历 左子树——&gt;根——&gt;右子树 上图遍历顺序：4 2 5 1 6 3 void InOrder(BiTree T) &#123; if(T !&#x3D; NULL) &#123; InOrder(T-&gt;lchild); visit(T); InOrder(T-&gt;rchild); &#125; &#125; 【非递归算法】 1）初始时，一次扫描根结点的所有左侧结点并进栈 2）出栈一个结点，并访问 3）扫描该结点的右孩子结点的所有结点并进栈 4）依次扫描右孩子结点的所有左侧结点并进栈 5）反复直到栈空 void InOrder(BiTree T) &#123; InitStack(S); BiTress p &#x3D; T; while(p || IsEmpty(S)) &#123; if(p) &#123; Push(S,p); p &#x3D; p-&gt;lchild; &#125; else &#123; Pop(S,p); visit(p); p&#x3D;p-&gt;rchild; &#125; &#125; &#125; 1.3.3 后序遍历 左子树——&gt;右子树——&gt;根 上图遍历顺序：4 5 2 6 3 1 void PreOrder(BiTree T) &#123; if(T !&#x3D; NULL) &#123; PreOrder(T-&gt;lchild); PreOrder(T-&gt;rchild); visit(T); &#125; &#125; 1.3.4 层次遍历 【算法思想】 1）初始将根入队列并访问根结点，然后出队 2）若有左子树，则将左子树的根入队 3）若有右子树，则将右子树的根入队 4）出队，访问该结点 5）反复直到队空 void levelOrder(BiTress T) &#123; InitQueue(Q); BiTree(Q,T); while(!isEmpty(Q)) &#123; DeQueue(Q,p); visit(p); if(p-&gt;lchild !&#x3D; NULL) EnQueue(Q,p-&gt;lchild); if(p-&gt;rchild !&#x3D; NULL) EnQueue(Q,p-&gt;rchild); &#125; &#125; 1.4 线索二叉树 线索化 若无左子树，则将左指针指向其前驱结点 若无右子树，则将右指针指向其后继结点 1.4.1 先序线索二叉树 1.4.2 中序线索二叉树 void InThread(ThreadTree &amp;p, ThreadTree &amp;pre) &#123; if(p !&#x3D; NULL) &#123; InThread(p-&gt;lchild,pre); if(p-&gt;lchild &#x3D;&#x3D; NULL) &#123; p-&gt;lchild &#x3D; pre; p-&gt;ltag &#x3D; 1; &#125; if(pre !&#x3D; NULL &amp;&amp; pre-&gt;rchild &#x3D;&#x3D; NULL) &#123; pre-&gt;rchild &#x3D; p; pre-&gt;rtag &#x3D; 1; &#125; pre &#x3D; p; InThread(p-&gt;rchild,pre); &#125; &#125; void CreateThread(ThreadTree T) &#123; ThreadTree pre &#x3D; NULL; if(T !&#x3D; NULL) &#123; InThread(T, pre); pre-&gt;rchild &#x3D; NULL; pre-&gt;tag &#x3D; 1; &#125; &#125; 中序线索二叉树遍历 ThreadNode * FirstNode(ThreadNode *p) &#123; while(p-&gt;ltag &#x3D;&#x3D; 0) p &#x3D; p-&gt;lchild; return p; &#125; ThreadNode * NextNode(ThreadNode *p) &#123; if(p-&gt;rtag &#x3D;&#x3D; 0) return FirstNode(p-&gt;rchild); else return p-&gt;rchild; &#125; void InOrder(ThreadNode *T) &#123; for(ThreadNode *p &#x3D; FirstNode(T); p!&#x3D;NULL; p&#x3D;NextNode(p)) visit(p); &#125; 1.4.3 后序线索二叉树 typedef struct ThreadNode &#123; ElemType data; struct ThreedNode *lchild, *rchild; int ltag, rtag; &#125;ThreadNode, *ThreadTree; 1.5 二叉树的应用 1.5.1 二叉排序树 二叉排序树 BST，也称二叉查找树。二叉排序树可为空树、非空树，当为非空树时有如下特点： 1）若左子树非空，左子树上的所有结点关键字小于根结点的关键字 2）若右子树非空，右子树上的所有结点关键字大于根结点的关键字 3）左、右子树本身也分别是一棵二叉排序树 【查找】 ①二叉树非空时，查找根结点，若相等则查找成功 ②若不等，当小于根结点，查找左子树，大于根结点，查找右子树 ③查找到叶子结点仍然没有找到，查找失败 BSTNode *BST_Search(BiTree T, ElemType key, BSTNode * &amp;p) &#123; &#x2F;&#x2F; p是双亲结点 p &#x3D; NULL; while(T !&#x3D; NULL &amp;&amp; key !&#x3D; T-&gt;data) &#123; p &#x3D; T; if(key &lt; T-&gt;data) T &#x3D; T-&gt;rchild; else T &#x3D; T-&gt;rchild; &#125; return T; &#125; 【插入】 ①若二叉排序树为空，直接插入 ②若二叉排序树非空，当值小于根结点，插入左子树；大于根结点，插入右子树，当值等于根结点，则不插入 int BST_Insert(BiTree &amp;T, KeyType k) &#123; if(T &#x3D;&#x3D; NULL) &#123; T &#x3D; (BiTree *)malloc(sizeof(BSTNode)); T-&gt;key &#x3D; k; T-&gt;lchild &#x3D; T-&gt;rchild &#x3D; NULL; return 1; &#125; else if(k &#x3D;&#x3D; T-&gt;key) return 0; else if(k &lt; T-&gt;key) return BST_Insert(T-&gt;lchild,k); else if(k &gt; T-&gt;key) return BST_Insert(T-&gt;rchild, k); &#125; 【构造二叉排序树】 void Create_BST(BiTree &amp;T, KeyType str[], int n) &#123; T &#x3D; NULL; int i &#x3D; 0; while(i &lt; n) BST_Insert(T, str[i++]); &#125; 【删除】 1 ）如果被删除的结点是叶结点，则直接删除 2）若被删除的结点z只有一颗子树，则让z的子树成为z父结点的子树，代替z结点 3）若被删除结点z有两棵子树，则让z的中序序列直接后继代替z，并删去直接后继结点 【查找效率】 平均查找长度（ASL）取决于树的高度，O(log2n)，最坏是O(n)。 构造二叉排序时最好转成平衡二叉树，这样查找效率是最高的 1.5.2 平衡二叉树 高度为h的最小平衡二叉树的结点数Nh = Nh-1 + Nh-2 + 1 平衡二叉树的判断 利用递归的后序遍历过程： 1）判断左子树是一棵平衡二叉树 2）判断右子树是一棵平衡二叉树 3）判断以该结点为根的二叉树为平衡二叉树。左子树和右子树均为平衡二叉树，且左右子树高度差的绝对值小于等于1，则平衡 void Judge_AVL(BiTree bt, int &amp;balance, int &amp;h) &#123; int bl &#x3D; 0,br &#x3D; 0, hl &#x3D; 0, hr &#x3D; 0; if(bt &#x3D;&#x3D; NULL) &#123; h &#x3D; 0; balance &#x3D; 1; &#125; else if (bt-&gt;lchild &#x3D;&#x3D; NULL &amp;&amp; bt-&gt;rchild &#x3D;&#x3D; NULL) &#123; h &#x3D; 1; balance &#x3D; 1; &#125; else &#123; Judge_AVL(bt-&gt;lchild,bl,hl); Judge_AVL(bt-&gt;rchild,br,hr); if(hl &gt; hr) h &#x3D; hl + 1; else h &#x3D; hr +1; if(abs(hl - hr) &lt; 2 &amp;&amp; bl &#x3D;&#x3D; 1 &amp;&amp; br &#x3D;&#x3D; 1) balance &#x3D; 1; else balance &#x3D; 0; &#125; &#125; 平衡二叉树的插入 先按照二叉排序树插入，然后进行平衡调整 1.5.3 哈夫曼树及哈夫曼编码 ==路径长度：==路径上所经历边的个数 ==结点的权：==结点被赋予的数值 ==树的带权路径长度WPL：==树中叶结点的带权路径长度之和，记为WPL=∑wili 【哈夫曼树的构造方法】 1）将n个结点作为n棵仅含有一个根结点的二叉树，构成森林F 2）生成一个新结点，并从F中找出根结点全值最小的两棵树作为它的左右子树，且新的结点权值为两棵子树根结点权值之和 3）从F中删除这两棵树，并将新生成的树加入到F中 4）重复2,3步，直到森林F中只有一棵树为止 【哈夫曼编码】 ABCDE后面的数字为权重，构造出哈夫曼树，然后令结点左边的边为0，右边的边为1，即可得到每个字母对应的哈夫曼编码 2 树和森林 2.1 树的存储结构 2.1.1 双亲表示法 采用一组连续的存储空间来存储每个结点，同时在每个结点中增设一个伪指针，指示双亲结点在数组中的位置。根结点的下标为0，其伪指针域为-1 #define MAX_TREE_SIZE 100 typedef struct &#123; ELemType data; int parent; &#125;PTNode; typedef struct &#123; PTNode nodes[MAX_TREE_SIZE]; int n; &#125;PTree; 2.1.2 孩子表示法 将每个结点的孩子结点都用单链表连接起来形成一个线性结构，n个结点具有n个孩子链表 #define MAX_TREE_SIZE 100 &#x2F;&#x2F; 单链表中的结点 typedef struct &#123; int child; struct CNode *next; &#125;CNode; &#x2F;&#x2F; 每一个结点存放的数据元素，以及链表第一个结点 typedef struct &#123; ElemType data; struct Cnode *child; &#125;PNode; typedef struct &#123; PNode nodes[MAX_TREE_SIZE]; int n; &#125;CTree; 2.1.3 孩子兄弟表示法 以二叉链表作为树的存储结构，又称二叉树表示法 typedef struct CSNode &#123; ElemType data; struct CSNode *firstchild,*nextsibling; &#125;CSNode,CSTree; 2.1.4 三种表示法比较 优点 缺点 双亲表示法 寻找结点的双亲结点效率高 寻找结点的孩子结点效率低 孩子表示法 寻找结点的孩子结点效率高 寻找结点的双亲结点效率低 孩子兄弟表示法 寻找结点的孩子结点效率高，方便实现树转二叉树 寻找结点的双亲结点效率低 2.2 树、森林二叉树 2.2.1 树转二叉树 规则：每个结点的左指针指向它的第一个孩子结点，右指针指向它在树中相邻兄弟结点。 【上图树转二叉树】 2.2.2 森林转二叉树 规则：将每棵树转换为二叉树，将每棵二叉树的根一次作为上一棵二叉树的右子树 2.2.3 树的遍历 先根遍历（类比二叉树的先序遍历） 树的先根遍历序列与这棵树对应的二叉树的先序遍历序列相同 后根遍历 后根遍历顺序类比二叉树的后序遍历，但是最后得到的遍历序列与该树对应的二叉树的中序遍历相同 层次遍历（类比二叉树的层次遍历） 2.2.4 森林的遍历 森林的先序遍历 森林的中序遍历 2.3 树的应用–并查集 并查集是一种简单的集合表示 通常用树的双亲表示法作为并查集的存储结构 通常用数组元素的下标代表元素名，用根结点的下标代表子集合名，根结点的双亲结点为负数 基本操作 Initial(S) 将集合S中的每个元素都初始化为只有一个单元数的子集合 Union(S,Root1,Root2) 把集合S中的子集合(互不相交)Root2并入子集合Root1 Find(S,x) 查找集合S中单元数x所在子集合，并返回该孩子集合的名字 #define SIZE 100 int UFSets[SIZE]; void Initial(int S[]) &#123; for(int i &#x3D; 0; i &lt; size; i++) &#123; S[i] &#x3D; -1; &#125; &#125; int Find(int S[], int x) &#123; while(S[x] &gt;&#x3D;0) x &#x3D; S[x]; return x; &#125; void Union(int S[], int Root1, int Roo2) &#123; S[Root2] &#x3D; Root1; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"blog.silverbeats.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"silverbeats"},{"title":"栈和队列","slug":"栈和队列","date":"2020-10-25T12:37:16.000Z","updated":"2020-10-25T13:52:56.194Z","comments":false,"path":"栈和队列/","link":"","permalink":"blog.silverbeats.cn/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","excerpt":"","text":"1 栈 1.1 基本概念 只允许在一端进行插入或删除操作的线性表，LIFO（后进先出） 基本操作 说明 InitStack(&amp;S) 初始化空栈S StackEmpty(S) 栈判空 Push(&amp;S,x) 压栈 Pop(&amp;S,&amp;x) 出栈，返回出栈元素 GetTop(S,&amp;x) 获取栈顶 ClearStack(&amp;S) 销毁栈 1.2 存储结构 1.2.1 顺序栈 采用顺序存储的栈 #define MaxSize 50 typedef struct &#123; ElemType data[MaxSize]; int top; &#125;SqStack; &#x2F;&#x2F; 栈空 S.top &#x3D;&#x3D; -1; &#x2F;&#x2F; 栈满 S.top &#x3D;&#x3D; MaxSize - 1; &#x2F;&#x2F; 栈长 S.top + 1 【栈判空】 bool StackEmpty(SqStack S) &#123; if(S.top &#x3D;&#x3D; -1) &#123; return true; &#125; else &#123; return false; &#125; &#125; 【进栈】 bool Push(SqStack &amp;S, ElemType x) &#123; if(S.top &#x3D;&#x3D; MaxSize - 1) return false; S.data[++S.top] &#x3D; x; return true; &#125; 【出栈】 bool Pop(SqStack &amp;S, ElemType &amp;x) &#123; if(S.top &#x3D;&#x3D; -1) return false; x &#x3D; S.data[S.top--]; return true; &#125; 【读栈顶】 bool GetTop(SqStack &amp;S, ElemType &amp;x) &#123; if(S.top &#x3D;&#x3D; -1)return false; x &#x3D; S.data[S.top]; return true; &#125; 1.2.2 共享栈 将两个栈底设置在共享空间的两端，栈顶向空间中间延伸 &#x2F;&#x2F; 判空 0号栈：top &#x3D;&#x3D; -1; 1号栈：top &#x3D;&#x3D; MaxSize; &#x2F;&#x2F; 栈满 top1 - top0 &#x3D;&#x3D; 1; 1.2.3 链栈 typedef struct LinkNode() &#123; ElemType data; struct LinkNode *next; &#125; *LiStack; 1.2 栈的应用 1.2.1 合法出栈个数 f(n) = C(2n,n) /（n+1） 1.2.2 括号匹配 【算法思想】 1）初始空栈，顺序读入括号 2）若是右括号，则弹出栈顶元素进行匹配。成功继续，失败return false 3）若是左括号，压栈 4）全部元素遍历结束后，栈非空，序列不合法 【代码】 /** * @param &#123;string&#125; s * @return &#123;boolean&#125; */ let isValid = function (s) &#123; if (s.length % 2) return false; let arr = []; for (let letter of s) &#123; switch (letter) &#123; case \"(\": &#123; arr.push(letter); break; &#125; case \"[\": &#123; arr.push(letter); break; &#125; case \"&#123;\": &#123; arr.push(letter); break; &#125; case \")\": &#123; if (arr.pop() !== \"(\") return false; break; &#125; case \"]\": &#123; if (arr.pop() !== \"[\") return false; break; &#125; case \"&#125;\": &#123; if (arr.pop() !== \"&#123;\") return false; break; &#125; &#125; &#125; return !arr.length; &#125;; 1.2.3 表达式求值 中缀表达式（A+B） [(A+B)*C]-[E-F] 前缀表达式（+AB） [(A+B)*C]-[E-F] &#x3D;&#x3D;&gt; [+AB * C] - [-EF] &#x3D;&#x3D;&gt; [*+ABC] - [-EF] &#x3D;&#x3D;&gt; -*+ABC-EF 后缀表达式（AB+） [(A+B)*C]-[E-F] &#x3D;&#x3D;&gt; [AB+*C] - [EF-] &#x3D;&#x3D;&gt; [AB+C*] - [EF-] &#x3D;&#x3D;&gt; AB+C*EF-- 【算法思想（中缀转后缀）】 1）数字直接加入后缀表示 2）运算符： 若为&quot;(&quot;，入栈 若为&quot;)&quot;，依次把栈中的运算符加入后缀表达式，直到出现&quot;(&quot;，并从栈中删除&quot;(&quot; 若为±*/ 栈空入栈 栈顶元素为&quot;(&quot;，入栈 高于栈顶元素优先级，入栈 否则，依次弹出栈顶运算符，直到弹出优先级比它低的运算符或者&quot;(&quot;为止 遍历完成，栈非空，依次弹出所有元素 1.2.4 递归 若一个函数、过程或数据结构的定义中又应用了它自身，则称为递归。 递归调用过程中，系统为每一层的返回点、局部变量、传入实参等开辟了递归工作栈进行数据存储，递归次数多了，容易造成栈溢出，通常情况下，递归效率不高 【斐波那契数列】 int Fib(int n) &#123; if(n &#x3D;&#x3D; 0)return 0; else if(n &#x3D;&#x3D; 1)return 1; else return Fib(n-1) + Fib(n-2); &#125; 2 队列 2.1 基本概念 只允许在表的一段进行插入，在另一端进行删除，先进先出（FIFO） 基本操作 说明 InitQueue(&amp;Q) 初始化队列 QueueEmpty(Q) 判断 EnQueue(&amp;Q,x) 入队 DeQueue(&amp;Q,&amp;x) 出队 GetHead(Q,&amp;x) 读队头元素，非空返回队头 ClearQueue(&amp;Q) 销毁队列，释放队列Q占用的内存空间 2.2 存储结构 2.2.1 顺序存储 front 指向队首元素 rear指向队尾元素的下一个位置 初始时：front == rear == 0 #define MaxSize 50 typedef struct &#123; ElemType data[MaxSize]; int front,rear; &#125;SqQueue; 普通队列 &#x2F;&#x2F;队列判空条件 Q.front &#x3D;&#x3D; Q.rear; &#x2F;&#x2F;队列对长 Q.rear - Q.front; &#x2F;&#x2F;队满条件 Q.rear &#x3D;&#x3D; MaxSize; &#x2F;&#x2F; 存在假溢出，可以使用循环队列来解决 循环队列 &#x2F;&#x2F; 出队列，front指针移动 Q.front &#x3D; (Q.front +1)%MaxSize; &#x2F;&#x2F; 进队列，rear指针移动 Q.rear &#x3D; (Q.rear + 1)%MaxSize; &#x2F;&#x2F; 队列长度 (Q.rear + MaxSize - Q.front)%MaxSize; &#x2F;&#x2F; 对空条件 Q.front &#x3D;&#x3D; Q.rear; &#x2F;&#x2F; 判断队满条件&lt;牺牲一个存储单元&gt; Q.front &#x3D;&#x3D; (Q.rear + 1)%MaxSize; &#x2F;&#x2F; 判断队满条件&lt;使用一个变量记录队列元素的个数&gt; Q.size &#x3D;&#x3D; MaxSize; 【初始化】 void InitQueue(SqQueue &amp;Q) &#123; Q.rear &#x3D; Q.front &#x3D; 0; &#125; 【判断队空】 bool isEmpty(SqQueue Q) &#123; if(Q.rear &#x3D;&#x3D; Q.front) &#123; return true; &#125; else &#123; return false; &#125; &#125; 【入队】 bool EnQueue(SqQueue &amp;Q, ElemType x) &#123; &#x2F;&#x2F; 如果队满 if(Q.front &#x3D;&#x3D; (Q.rear + 1)%MaxSize)return false; Q.data[Q.rear] &#x3D; x; Q.rear &#x3D; (Q.rear + 1)%MaxSize; &#125; 【出队】 bool DeQueue(SqQueue &amp;Q,ElemType &amp;x) &#123; if(Q.rear &#x3D;&#x3D; Q.front)return false; x &#x3D; Q.data[Q.front]; Q.front &#x3D; (Q.front + 1)%MaxSize; return true; &#125; 2.2.2 链式存储 队头指针front，指向头结点，从链头出队列 链表尾指针rear，从链尾入队 typedef struct &#123; ElemType data; struct LinkNode *next; &#125;LinkNode; typedef struct &#123; LinkNode *front, *rear; &#125;LinkQueue; 【初始化】 void InitQueue(LinkQueue &amp;Q) &#123; Q.front &#x3D; (LinkNode *)malloc(sizeof(LinkNode)); Q.rear &#x3D; Q.front; Q.front-&gt;next &#x3D; NULL; &#125; 【入队列】 void EnQueue(LinkQueue &amp;Q, ElemType x) &#123; &#x2F;&#x2F; 创建新结点 LinkNode *s &#x3D; (LinkNode *)malloc(sizeof(LinkNode)); s-&gt;data &#x3D; x; s-&gt;next &#x3D; Null; Q.rear-&gt;next &#x3D; s; Q.rear &#x3D; s; return true; &#125; 【出队列】 bool DeQueue(LinkQueue &amp;Q, ElemType &amp;x) &#123; if(Q.front &#x3D;&#x3D; Q.rear) return false; &#x2F;&#x2F; 存储被删除的结点 LinkNode *p &#x3D; Q.front-&gt;next; x &#x3D; p-&gt;data; Q.front-&gt;next &#x3D; p-&gt;next; &#x2F;&#x2F; 针对队列中只有一个结点的情况 if(Q.rear &#x3D;&#x3D; p) Q.rear &#x3D; Q.front; free(p); return true; &#125; 【判空】 bool isEmpty(LinkQueue Q) &#123; if(Q.front &#x3D;&#x3D; Q.rear)&#123; return true; &#125; else &#123; return false; &#125; &#125; 2.2.3 队列的应用 层次遍历 计算机系统 2.2.4 双端队列 两端都可以进行入队和出队 输出受限的双端队列 输入受限的双端队列 3 数组 3.1 数组的定义 数组是由n（n&gt;=1）个相同类型的数据元素构成的有限序列，每个数据元素称为一个数组元素，每个元素受n个线性关系的约束，每个元素在n个线性关系中的序号称为下标（索引），并称该数组为n为数组。 数组是一种逻辑结构，是线性表的推广 3.2 矩阵的压缩存储 压缩存储：多个值相同的元素只分配一个存储空间，对零元素不分配存储空间 特殊矩阵：指具有许多相同元素或者零元素，并且呈现一定分布规律的矩阵。比如对称矩阵、反对称矩阵、单位阵 特殊矩阵的压缩存储：找出特殊矩阵中值相同的矩阵元素的分布规律，把呈现规律性分布、值相同的多个矩阵元素压缩存储到一个存储空间上。","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"blog.silverbeats.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"silverbeats"},{"title":"线性表","slug":"线性表","date":"2020-10-25T12:24:31.000Z","updated":"2020-10-25T12:35:25.518Z","comments":false,"path":"线性表/","link":"","permalink":"blog.silverbeats.cn/%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"1 线性表的定义和基本操作 1.1 定义及特点 【定义】 线性表是具有相同类型的n（n&gt;=0）个元素的有限序列（长度有限），其中n为表长，当n=0时，为空表。 若L命名为线性表，一般表示为：L = (a1,a2,a3,…,ai+1,ai+2,…an) 【逻辑结构】 【特点】 元素个数有限 元素具有逻辑上的顺序性，序列中各个元素排序有先后次序 表中元素都是数据元素，每个元素都是单个元素 表中元素的数据类型相同 表中元素具有抽象性，讨论元素之间一对一的逻辑关系时，而不考虑元素究竟表示内容 线性表是逻辑结构，表示元素之间一对一相邻的关系 1.2 线性表九种基本操作 操作 说明 InitList(&amp;L) 初始化表。构造空的线性表 DestroyList(&amp;L) 销毁。销毁线性表，释放线性表L所占的内存空间 LocateElem(L,e) 按值查找。在表中L查找具有给定关键字值的元素 GetElem(L,i) 按位查找。获取表L中第i个位置的元素值 ListInsert(&amp;L,i,e) 插入。在L的第i个位置插入元素e(前插) ListDelete(&amp;L,i,&amp;e) 删除。删除L中第i个位置的元素，并用e返回删除元素的值 PrintList(L) 输出。按前后顺序输出线性表L的所有元素值 Empty(L) 判空。空返回True Length(L) 表长。即元素的个数。 2 线性表的顺序表示 2.1 顺序表的定义 线性表的顺序存储又称顺序表 一组地址连续存放的存储单元依次存放线性表元素，从而使得逻辑上相邻的两个元素，在物理位置上也相邻。 顺序表往往用数组来实现。 【数组与顺序表区别】 顺序表下标从1开始，数组从0开始 顺序表容量可扩充，数组不能 顺序表是一维的，数组可以是多维的 【顺序表程序语言描述—C语言】 数组静态分配 #define MaxSize 50 typedef struct &#123; ElemType data[MaxSize]; int length; &#125;SqList; 数组动态分配 #define MaxSize 50 typedef struct &#123; ElemType *data; int length; &#125;SqList; L.data = (Elemtype*)malloc(sizeof(ElemType)*InitSize); 2.2 顺序表的基本操作 【插入操作】 将插入位置后面的元素向后挪动。 MaxSize是数组最大容量 Length是顺序表的长度，在这里的作用和ArrayList中的size是一样 ，表示当前数组元素的个数，并非数组的长度。 这里的插入是向顺序表插入，顺序表下标从1开始，因为是用数组实现该顺序表（下标从0开始），所以在插入时，需要减1。 bool ListInsert(SqList &amp;L, int pos, ElemType e) &#123; if(pos &lt; 1 || pos &gt; L.length + 1) return false; if(L.length &gt;&#x3D; MaxSize) return false; for(int j &#x3D; L.length; j &gt;&#x3D; pos; j--) &#123; L.data[j] &#x3D; L.data[j-1]; &#125; L.data[pos - 1] &#x3D; e; L.length++; return true; &#125; 最好时间复杂度 平均时间复杂度 最坏时间复杂度 O(1) O(n) o(n) 【删除操作】 将被删除位置的后面元素向前移动，进行覆盖 bool ListDelete(SqList &amp;L, int pos, ElemType &amp;e) &#123; &#x2F;&#x2F; 判断合法性 if(pos &lt; 1 || pos &gt; L.length)return false; &#x2F;&#x2F; 保存被删除的元素 e &#x3D; L.data[pos - 1]; for(int i &#x3D; pos; i &lt; L.length; i++) &#123; L.data[i - 1] &#x3D; L.data[i]; &#125; L.length--; return true; &#125; 最好时间复杂度 平均时间复杂度 最坏时间复杂度 O(1) O(n) O(n) 【按值查找】 int LocateElem(SqList L, ElemType e) &#123; for(int i &#x3D; 0; i &lt; L.length; i++) &#123; if(L.data[i] &#x3D;&#x3D; e)return i + 1; &#125; return -1; &#125; 最好时间复杂度 平均时间复杂度 最坏时间复杂度 O(1) O(n) O(n) 3 线性表的链式表示 3.1 单链表定义 线性表的链式存储称为单链表，通过指针来实现线性的逻辑关系 typedef struct LNode&#123; ElemType data; struct LNode *next; &#125;LNode, *LinkList; 【头结点的优点】 链表的第一个位置和其他位置的操作统一 空表和非空表操作统一 3.2 单链表的基本操作 【头插法建立单链表】 s-&gt;next &#x3D; L-&gt;next; L-&gt;next &#x3D; s; LinkList List_HeadInsert(LinkList &amp;L) &#123; LNode *s; int x; L &#x3D; (LinkList)malloc(sizeof(LNode)); L-&gt;next &#x3D; NULL; scanf(&quot;%d&quot;,&amp;x); while(x !&#x3D; 9999) &#123; s &#x3D; (LNode*)malloc(sizeof(LNode)); s-&gt;data &#x3D; x; s-&gt;next &#x3D; L-&gt;next; L-&gt;next &#x3D; s; scanf(&quot;%d&quot;,&amp;x); &#125; return L; &#125; 【尾插法建立单链表】 要有一个尾指针r LinkList List_TailInsert(LinkList &amp;L) &#123; int x; L &#x3D; (LinkList)malloc(sizeof(LNode)); LNode *s, *r &#x3D; L; scanf(&quot;%d&quot;,&amp;x); while(x !&#x3D; 9999) &#123; s &#x3D; (LNode*)malloc(sizeof(LNode)); s-&gt;data &#x3D; x; r-&gt;next &#x3D; s; r &#x3D; s; scanf(&quot;%d&quot;,&amp;x); &#125; r-&gt;next &#x3D; NULL; return L; &#125; 【按序号查找&amp;&amp;按值查找】 都需要遍历单链表，但是按序号查找需要用到一个变量来记录当前结点的序号 &#x2F;&#x2F; 按序号查找 LNode *GetElem(LinkList L, int i) &#123; &#x2F;&#x2F; 记录序号的变量 int count &#x3D; 1; &#x2F;&#x2F; p当前指向第一个结点 LNode *p &#x3D; L-&gt;next; if(i &#x3D;&#x3D; 0)return L; if(i &lt; 1)return NULL; while(p&amp;&amp;count&lt;i) &#123; count++; p &#x3D; p-&gt;next; &#125; return p; &#125; &#x2F;&#x2F; 按值查找 LNode *LocateElem(LinkList L, ElemType e) &#123; LNode *p &#x3D; L-&gt;next; while(p!&#x3D;NULL&amp;&amp;p-&gt;data!&#x3D;e) &#123; p&#x3D;p-&gt;next; &#125; return p; &#125; 【插入结点】 插入有前插法（在插入位置的前面插入，需要获取插入位置的前一个结点地址）和后插法（在插入位置的后面插入，需要获取插入位置的地址）之分。 &#x2F;&#x2F; 前插法 pre &#x3D; GetElem(L,i-1);&#x2F;&#x2F; 获取插入位置的结点的前一个 s-&gt;next &#x3D; pre-&gt;next;&#x2F;&#x2F; s是要插入结点的指针 pre-&gt;next &#x3D; s; &#x2F;&#x2F; 后插法 p &#x3D; GetElem(L,i); s-&gt;next &#x3D; p-&gt;next; p-&gt;next &#x3D; s; 后插法可以转换为前插法 &#x2F;&#x2F; 1. 先后插法 p &#x3D; GetElem(L,i); s-&gt;next &#x3D; p-&gt;next; p-&gt;next &#x3D; s; &#x2F;&#x2F; 临时变量存储要插入的结点数据 ElemType temp &#x3D; s-&gt;data; &#x2F;&#x2F; 2. 交换数据 s-&gt;data &#x3D; p-&gt;data; p-&gt;data &#x3D; temp; 【删除结点】 pre &#x3D; GetElem(L, i-1);&#x2F;&#x2F; 获取要删除位置的结点的前一个 q &#x3D; pre-&gt;next; pre-&gt;next &#x3D; pre-&gt;next-&gt;next; free(q); 【求表长】 int count &#x3D; 0; p &#x3D; head; while(p-&gt;next !&#x3D; NULL) &#123; count++; p &#x3D; p-&gt;next; &#125; 【判空】 head-&gt;next &#x3D;&#x3D; NULL; 3.3 几种常用的链表 3.3.1 双向链表 【插入】 s-&gt;next &#x3D; p-&gt;next; p-&gt;next-&gt;prior &#x3D; s; s-&gt;prior &#x3D; p; p-&gt;next &#x3D; s; 【删除】 &#x2F;&#x2F; 存储被删除的结点（已知被删除结点的前驱结点地址） LNode *temp &#x3D; p-&gt;next; p-&gt;next-&gt;next-&gt;prior &#x3D; p; p-&gt;next &#x3D; p-&gt;next-&gt;next; free(temp); &#x2F;&#x2F; 存储被删除的结点（已知被删除结点地址） LNode *temp &#x3D; p; p-&gt;prior-&gt;next &#x3D; p-&gt;next; p-&gt;next-&gt;prior &#x3D; p-&gt;prior; free(temp); 3.3.2 循环链表 3.3. 静态链表 用数组实现链式存储 4 顺序表与链表对比 区别 顺序表 单链表 存取方式 顺序存取和随机存取 顺序存取 逻辑结构和物理结构 逻辑相邻物理上也相邻，通过相邻表示逻辑关系 逻辑连续，物理上不一定连续，通过指针表示逻辑关系 插入操作 挪动元素O(n) 修改指针O(n)，已知插入位置O(1) 删除操作 挪动元素O(n) 修改指针O(n)，已知删除位置O(1) 查找操作 按值O(n)和按下标O(1) 按值、按下标都是O(n) 内存空间 静态分配，容量定死，太大太小都不好动态分配，扩充需要移动大量元素，效率低下 按需分配，但指针的存储需要额外的空间","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"blog.silverbeats.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"silverbeats"},{"title":"课外书","slug":"课外书","date":"2020-10-24T11:19:20.000Z","updated":"2020-10-24T11:43:19.352Z","comments":true,"path":"课外书/","link":"","permalink":"blog.silverbeats.cn/%E8%AF%BE%E5%A4%96%E4%B9%A6/","excerpt":"","text":"1 语言相关 1.1 Java 3y教你学java（提取码：vzs2） Effective Java 原书第三版（提取码：4f4l ） 1.2 JavaScript 阮一峰 ES6 （提取码：kgp9 ） Javascript高级程序设计（提取码：ic9o） JavaScript设计模式—张容铭（提取码：i41t） [JavaScript设计模式—Ross Harmes（提取码：23uw） 编写可维护的JavaScript（提取码：asjn） 2 Web 图解HTTP（提取码：vybw） 3 版本控制 GitHub入门与实践 （提取码：yxcl） 4 服务器 Nginx开发从入门到精通 (淘宝团队出品) Nginx教程从入门到精通(PDF版本，运维生存时间出品) 5 设计模式 设计模式_可复用面向对象软件的基础 C/C++（提取码：6l3a） 6 分布式系统 走向分布式","categories":[{"name":"书籍","slug":"书籍","permalink":"blog.silverbeats.cn/categories/%E4%B9%A6%E7%B1%8D/"}],"tags":[{"name":"书籍","slug":"书籍","permalink":"blog.silverbeats.cn/tags/%E4%B9%A6%E7%B1%8D/"}],"author":"silverbeats"},{"title":"单例模式","slug":"单例模式","date":"2020-10-24T05:31:01.000Z","updated":"2020-10-25T13:42:29.503Z","comments":false,"path":"单例模式/","link":"","permalink":"blog.silverbeats.cn/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"推荐文章： 你知道吗？枚举单例模式是世界上最好的单例模式！！！ https://blog.csdn.net/fvdfsdafdsafs/article/details/88541909 1 饿汉式单例 构造器私有化 JVM保证线程安全 缺点： 不管是否使用，一上来就会加载对象，会浪费空间 反射可破坏单例 public class SingleTon01 &#123; // 构造器私有 private SingleTon01()&#123;&#125; // 类加载到内存后,就实例化一个单例,JVM保证线程安全 private static final SingleTon01 INSTANCE = new SingleTon01(); public static SingleTon01 getINSTANCE() &#123; return INSTANCE; &#125; &#125; 1.1 反射破坏单例 @Test public void testsingle01() throws Exception&#123; // 获取SingleTon01的Class属性 Class singleTon01Class = Class.forName(\"com.silverbeats.singleton.SingleTon01\"); // 通过正常方式获取instance1,instance2 SingleTon01 instance1 = SingleTon01.getINSTANCE(); SingleTon01 instance2 = SingleTon01.getINSTANCE(); // 获取该Class的无参构造器 Constructor declaredConstructor = singleTon01Class.getDeclaredConstructor(null); // 破坏构造器私有 declaredConstructor.setAccessible(true); // 通过反射创建instance3和instance4 SingleTon01 instance3 = (SingleTon01) declaredConstructor.newInstance(); SingleTon01 instance4 = (SingleTon01) declaredConstructor.newInstance(); // 输出instance1、instance2、instance3、instance4的地址 System.out.println(instance1); System.out.println(instance2); System.out.println(instance3); System.out.println(instance4); &#125; 输出的结果： com.silverbeats.singleton.SingleTon01@504bae78 com.silverbeats.singleton.SingleTon01@504bae78 com.silverbeats.singleton.SingleTon01@3b764bce com.silverbeats.singleton.SingleTon01@759ebb3d 可知，通过非反射的方式获取的instance1和instance2是同一个对象，符合单例。但是通过==反射==可以创建多个对象，破坏单例的效果，如instance3和instance4，都是不同于instance1的对象实例。 1.2 序列化破坏单例 倘若该单例实现了序列化接口java.io.Serializable，会被序列化反序列化破坏单例 @Test public void serializeSingle01() throws Exception &#123; SingleTon01 instance = SingleTon01.getINSTANCE(); // instance序列化输出流 FileOutputStream fileOutputStream = new FileOutputStream(\"/singleton01.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); // 序列化 objectOutputStream.writeObject(instance); // 关闭输出流 fileOutputStream.close(); objectOutputStream.close(); // 声明一个对象用来接收反序列化的结果 SingleTon01 instance2; // instance反序列化,输入流 FileInputStream fileIn = new FileInputStream(\"/singleton01.ser\"); ObjectInputStream in = new ObjectInputStream(fileIn); // 反序列化 instance2 = (SingleTon01)in.readObject(); // 关闭输入流 in.close(); fileIn.close(); // 判断是否是同一个对象 System.out.println(instance == instance2); // false &#125; 2 懒汉式：写法一 public class SingleTon02 &#123; private static SingleTon02 INSTANCE; private SingleTon02()&#123;&#125; public static SingleTon02 getINSTANCE() &#123; // 倘若没有创建,则创建对象 if(INSTANCE == null) &#123; /* 这里可以加线程睡眠,模拟效果 */ INSTANCE = new SingleTon02(); &#125; return INSTANCE; &#125; &#125; 3 懒汉式：写法二 加锁，方法锁 public static synchronized SingleTon02 getINSTANCE() &#123; if(INSTANCE == null) &#123; /* 这里可以加线程睡眠,模拟效果 */ INSTANCE = new SingleTon02(); &#125; return INSTANCE; &#125; 3 懒汉式：写法三 ==双重检查==单例。添加volatile保证创建对象是原子性，防止指令重排 创建对象的过程： 分配内存空间 执行构造方法，初始化对象 把对象指向这个空间 上面三个步骤，可能会出现指令重排现象,导致线程不安全 public class SingleTon02 &#123; // volatile保证创建对象是原子性 private static volatile SingleTon02 INSTANCE; private SingleTon02()&#123;&#125; public static SingleTon02 getINSTANCE() &#123; if(INSTANCE == null) &#123; synchronized (SingleTon02.class) &#123; /* 这里可以加线程睡眠,模拟效果 */ if(INSTANCE == null) &#123; INSTANCE = new SingleTon02(); &#125; &#125; &#125; return INSTANCE; &#125; &#125; 4 懒汉式：写法四 枚举类 public enum EnumClass &#123; INSTANCE; public EnumClass getInstance() &#123; return INSTANCE; &#125; &#125; **多线程测试：**通过,打印的都是同一个hashCode for (int i = 0; i &lt; 100; i++) &#123; new Thread(()->&#123; System.out.println(SingleTon03.getInstance().hashCode()); &#125;).start(); &#125; **反射测试：**结果报错，无法创建 Class singleTon01Class = Class.forName(\"com.silverbeats.singleton.SingleTon03\"); // 获取无参构造器 Constructor declaredConstructor = singleTon01Class.getDeclaredConstructor(null); // 破坏私有 declaredConstructor.setAccessible(true); // 创建对象 SingleTon01 instance = (SingleTon01) declaredConstructor.newInstance(); // 打印对象 System.out.println(instance.hashCode()); 序列化测试： @Test public void serializeEnumClass() throws Exception &#123; EnumClass instance = EnumClass.INSTANCE; // instance序列化输出流 FileOutputStream fileOutputStream = new FileOutputStream(\"/enumInstance.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); // 序列化 objectOutputStream.writeObject(instance); // 关闭输出流 fileOutputStream.close(); objectOutputStream.close(); // 声明一个对象用来接收反序列化的结果 EnumClass instance2; // instance反序列化,输入流 FileInputStream fileIn = new FileInputStream(\"/enumInstance.ser\"); ObjectInputStream in = new ObjectInputStream(fileIn); // 反序列化 instance2 = (EnumClass)in.readObject(); // 关闭输入流 in.close(); fileIn.close(); // 判断是否是同一个对象 System.out.println(instance == instance2); // true &#125; 4.1 防止反射的原因 反射newInstance方法中有这样一段代码： if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0) throw new IllegalArgumentException(\"Cannot reflectively create enum objects\"); 可知，枚举类型不可被创建，故可以防反射破坏枚举单例。枚举类型最终反编译源码中没有无参构造器，有一个接受string和int两个参数的有参构造器 4.2 防序列化的原因 Java的序列化专门对枚举的序列化做了规定，在序列化时，只是将枚举对象的name属性输出到结果中，在反序列化时通过java.lang.Enum的valueOf方法根据名字查找对象，而不是新建一个新的对象，所以防止了反序列化对单例的破坏。 可以查看java.io.ObjectInputStream#readObject验证。readObject判断到枚举类时，调用的了这个方法java.io.ObjectInputStream#readEnum jdk文档： 枚举常数的反序列化与普通可序列化或外部化对象不同。 枚举常数的序列化形式仅由其名称组成; 不传输常数的字段值。 要反序列化枚举常量，ObjectInputStream从流中读取常量名称; 然后通过使用枚举常量的基本类型和接收的常量名称作为参数调用静态方法Enum.valueOf(Class, String)获得反序列化常数。 像其他可序列化或可外部化的对象一样，枚举常量可以作为随后在序列化流中出现的反向引用的目标。 枚举常量被反序列化的过程无法自定义：在反序列化期间将忽略由枚举类型定义的任何特定于类的readObject，readObjectNoData和readResolve方法。 类似地，任何serialPersistentFields或serialVersionUID字段声明也被忽略 - 所有枚举类型都有一个固定的serialVersionUID为0L。 5 单例模式总结 单例写法 优点 缺点 饿汉式 JVM保证线程安全 ①浪费空间；②反射可以破坏单例③序列化可以破坏单例 懒汉式：写法一 需要的时候创建，避免空间的浪费 ①线程不安全；②反射可破坏单例③序列化可以破坏单例 懒汉式：写法二 ①需要的时候创建，避免空间的浪费②线程安全 ①因为加锁，影响效率；②反射可破坏单例③序列化可以破坏单例 懒汉式：写法三 ①需要的时候创建，避免空间的浪费②线程安全 ①比上面的写法效率会高一些；②反射破坏单例③序列化可以破坏单例 懒汉式：写法四 ①需要的时候创建，避免空间的浪费②线程安全③没有锁，效率高④防反射、防序列化","categories":[{"name":"java","slug":"java","permalink":"blog.silverbeats.cn/categories/java/"},{"name":"设计模式","slug":"java/设计模式","permalink":"blog.silverbeats.cn/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"blog.silverbeats.cn/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"blog.silverbeats.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"silverbeats"},{"title":"GOF23种设计模式概述","slug":"GOF23种设计模式概述","date":"2020-10-23T14:07:56.000Z","updated":"2020-10-25T12:27:31.862Z","comments":false,"path":"GOF23种设计模式概述/","link":"","permalink":"blog.silverbeats.cn/GOF23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/","excerpt":"","text":"设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解 1 优点 可以提高思维能力、编程能力和设计能力 程序设计更加标准化、编码编制更加工程化，使软件开发效率提高，缩短开发周期 使代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强 2 基本要素 模式名称 问题 解决方案 效果 3 分类 3.1 创建型模式 单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式 3.2 构建型模式 适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式 3.3 行为模式 模板方法模式，命令模式，迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式 4 面向对象OOP七大原则 开闭原则：对扩展开放，对修改关闭 里氏替换原则：继承必须确保超类所拥有的性质在之类中仍然成立。不要破坏继承关系。 依赖倒置原则：要面向接口编程，不要面向实现编程 单一职责原则：控制类的粒度大小、将对象解耦、提高其内聚性。要求每个类的职责单一。 接口隔离原则：要为各类建立它们需要的专用接口。保证接口的精简和单一。 迪米特法则：只与你的直接朋友交谈，不跟陌生人说话。降低程序之间的耦合度 合成复用原则：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系实现 5 创建型模式 单例模式 Post not found: 工厂模式 工厂模式 Post not found: 抽象工厂模式 抽象工厂模式 Post not found: 建造者模式 建造者模式 Post not found: 原型模式 原型模式","categories":[{"name":"java","slug":"java","permalink":"blog.silverbeats.cn/categories/java/"},{"name":"设计模式","slug":"java/设计模式","permalink":"blog.silverbeats.cn/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"blog.silverbeats.cn/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"blog.silverbeats.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"silverbeats"},{"title":"数据结构题目","slug":"数据结构题目","date":"2020-10-21T01:56:26.000Z","updated":"2020-10-26T03:37:50.746Z","comments":false,"path":"数据结构题目/","link":"","permalink":"blog.silverbeats.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE/","excerpt":"","text":"1 线性表 public class SingleLinearNode &#123; private int elemData; private SingleLinearNode next; // 以及get、set方法 &#125; 1.1 单链表原地逆置 单链表原地逆置（假定需要逆置的单链表不含头结点） public SingleLinearNode reverseLinear(SingleLinearNode linear) &#123; SingleLinearNode head = new SingleLinearNode(), temp, lp; lp = linear; while (lp != null) &#123; temp = lp.getNext(); lp.setNext(head.getNext()); head.setNext(lp); lp = temp; &#125; return head.getNext(); &#125; 1.2 将两个有序的单链表合并，合并后结果仍然有序 将两个有序的单链表合并，合并后结果仍然有序（假定两个链表不含头结点并非减） public SingleLinearNode combineTwoLinear(SingleLinearNode linear1, SingleLinearNode linear2) &#123; SingleLinearNode p1 = linear1, p2 = linear2; SingleLinearNode head = new SingleLinearNode(), hp = head, temp; while (p1 != null &amp;&amp; p2 != null) &#123; if (p1.getElemData() &lt; p2.getElemData()) &#123; hp.setNext(p1); hp = p1; p1 = p1.getNext(); &#125; else &#123; hp.setNext(p2); hp = p2; p2 = p2.getNext(); &#125; hp.setNext(null); &#125; // 如果某个链表还有节点 if (p1 != null) hp.setNext(p1); if (p2 != null) hp.setNext(p2); return head.getNext(); &#125; 1.3 现有两个递增单链表，要求合并后递减 现有两个递增单链表，要求合并后递减，含关键字的节点需要利用原有的 public SingleLinearNode MergeDiminishing(SingleLinearNode linear1, SingleLinearNode linear2) &#123; return reverseLinear(combineTwoLinear(linear1, linear2)); &#125; 1.4 一个数组正数负数混合，以最快的速度将所有的负数挪到整个数组的最前面 一个数组，其中有正数和负数，以最快的速度将所有的负数挪到整个数组的最前面 public void negativeFrontPositive(int[] arr) &#123; if (arr.length &lt;= 1) return; // left表示负数存储的下标,right表示正数的位置 int left = 0, right = arr.length - 1; while (left &lt; right) &#123; while (arr[left] &lt; 0) ++left; while (arr[right] > 0) --right; // 经过两个while,left的位置是正数,right的位置是负数,进行交换 swap(arr, left, right); ++left; --right; &#125; &#125; 1.5 一个递增有序数组，以最快的方式找到某个值，找到则将该值与后继进行交换，找不到则插入 一个递增有序数组，以最快的方式找到某个值，找到则将该值与后继进行交换，找不到则插入 public int[] findSwapOrInsert(int[] arr, int target) &#123; if (arr.length == 0) return new int[]&#123;target&#125;; // 二分查找 int left = 0, right = arr.length - 1, mid; while (left &lt; right) &#123; mid = (left + right) >> 1; if (arr[mid] > target) right = mid - 1; else if (arr[mid] &lt; target) left = mid + 1; else &#123; // 如果找到了 swap(arr, mid, mid + 1); return arr; &#125; &#125; // 如果没找到 int i = Math.max(right, 0); for (; i &lt; arr.length; i++) &#123; if (target &lt; arr[i]) break; &#125; // 此时i就是插入位置 int[] newArr = new int[arr.length + 1]; System.arraycopy(arr, 0, newArr, 0, i); newArr[i] = target; System.arraycopy(arr, i, newArr, i + 1, arr.length - i); return newArr; &#125; 1.6 判断某单链表前n个字符是否是中心对称 判断某单链表前n个字符是否是中心对称 public boolean isCenterSymmetry(SingleLinearNode linear, int len) &#123; // 先统计linear有多少个节点 int count = 0; SingleLinearNode lp = linear; while (lp != null) &#123; ++count; lp = lp.getNext(); &#125; // 可能会出现链表4个节点,让判断前5个乃至更多是否中心对称 int realN = Math.min(len, count); // 创建一个数组用来存储linear前realN个关键字 int[] arr = new int[realN]; for (int i = 0; i &lt; realN; i++) &#123; arr[i] = linear.getElemData(); linear = linear.getNext(); &#125; // 定义左右指针 int left = 0, right = realN - 1; // 判断是否中心对称 while (left &lt; right) &#123; if (arr[left++] != arr[right--]) return false; &#125; return true; &#125; 1.7 删除不带头结点的单链表，begin位置后的len个节点 删除不带头结点的单链表，begin位置后的len个节点 begin = 0：从单链表第一个节点开始删 begin = 1：从单链表第二个位置开始删除，第一个节点保留 …… 起始位置超出链表长度：报错 能删除的节点数量不足len个：有多少删多少 public SingleLinearNode deleteNodeFrom(SingleLinearNode linear, int begin, int len) &#123; if (begin &lt; 0) throw new RuntimeException(\"deleteNodeFrom参数错误,begin需要≥0\"); if (len &lt; 0) throw new RuntimeException(\"deleteNodeFrom参数错误,len需要≥0\"); if (linear == null) return null; // 令传递过来的单链表配上一个头结点 SingleLinearNode head = new SingleLinearNode(), hp = head; head.setNext(linear); int i = 0; while(i++ &lt; begin &amp;&amp; hp != null) hp = hp.getNext(); if(hp == null) throw new RuntimeException(\"起始位置超出链表长度\"); // 此时,从hp后面的节点开始计数len个要删除 SingleLinearNode temp = hp; for(i = 1; i &lt;= len &amp;&amp; temp != null; i++) temp = temp.getNext(); // 此时temp指向被删除的最后一个节点 if(temp != null) hp.setNext(temp.getNext()); // 说明能删的不够len个 else hp.setNext(null); return head.getNext(); &#125; 1.8 定位到单链表中某个位置 如果需要定位的位置超过链表长度：返回null public SingleLinearNode getPos(SingleLinearNode linear, int pos) &#123; if (pos &lt; 1) throw new RuntimeException(\"getPos参数错误,position需要≥1\"); if(linear == null) return null; SingleLinearNode lp = linear; for (int i = 2; i &lt;= pos &amp;&amp; lp != null; i++) lp = lp.getNext(); return lp; &#125; 1.9 删除linear1自begin后面的len个节点,并将linear1剩余的节点插入到linear2第insertPos位置之前 删除linear1自begin后面的len个节点,并将linear1剩余的节点插入到linear2第insertPos位置之前 public SingleLinearNode q7(SingleLinearNode linear1, int begin, int len, SingleLinearNode linear2, int insertPos) &#123; if(insertPos &lt; 0) throw new RuntimeException(\"linear2插入位置需要≥0\"); // 先对linear1进行处理,进行删除 linear1 = deleteNodeFrom(linear1, begin, len); // 判断经过删除后,linear1还有没有可以插入的节点 if(linear1 != null) &#123; // p定位到linear1的最后一个节点 SingleLinearNode p = linear1; while(p.getNext() != null) p = p.getNext(); if(insertPos > 0) &#123; // 找到linear的第j个位置的前一个位置 SingleLinearNode prePos = getPos(linear2, insertPos - 1); if(prePos != null) &#123; p.setNext(prePos.getNext()); prePos.setNext(linear1); &#125; else &#123; // 如果定位失败,则将linear1剩下的节点插入到linear2的最后 // 此时p指向linear2的最后一个节点 p = linear2; while(p.getNext() != null) p = p.getNext(); // linear1剩余节点插入linear2最后 p.setNext(linear1); &#125; &#125; else &#123; // 若j=0 p.setNext(linear2); return linear1; &#125; &#125; return linear2; &#125; 2 栈和队列 2.1 给定入栈序列和某个出栈序列，判断该出栈序列是否合法 给定入栈序列和某个出栈序列，判断该出栈序列是否合法 /** * @param inStackSeq: 入栈顺序 * @param outStackSeq: 出栈顺序 * @return: boolean */ public static boolean isRightOutStackSeq(String inStackSeq, String outStackSeq) &#123; if(inStackSeq.length() != outStackSeq.length()) return false; // 入栈序列和出栈序列转为数组,方便处理 char[] inStackSeqChars = inStackSeq.toCharArray(); char[] outStackSeqChars = outStackSeq.toCharArray(); // 声明一个栈 SequenceStack&lt;Character> stack = new SequenceStack&lt;>(inStackSeqChars.length); // 声明一个指针i,指向出栈序列,这里不借助队列实现 // 指针j指向入栈序列 int i = 0, j = 0; while(j &lt; inStackSeqChars.length) &#123; stack.push(inStackSeqChars[j++]); // 每次入栈和出栈顺序队列第一个比较,如果相等 while(!stack.isEmpty() &amp;&amp; stack.peek() == outStackSeqChars[i]) &#123; i++; stack.pop(); &#125; &#125; return i >= outStackSeqChars.length &amp;&amp; stack.isEmpty(); &#125; 2.2 前缀、中缀、后缀表达式 /** * @param char1: 第一个运算符 * @param char2: 第二个运算符 * @return: int * @description: 返回0,优先级一致;正数,前面优先级高;负数,前面优先级低 */ private int cmp(char char1, char char2) &#123; Map&lt;Character, Integer> map = new HashMap&lt;>(); char[] chars = &#123;'/', '*', '%'&#125;; for (char item : chars) map.put(item, 3); chars = new char[]&#123;'+', '-'&#125;; for (char item : chars) map.put(item, 4); chars = new char[]&#123;'^'&#125;; for (char item : chars) map.put(item, 9); return map.get(char2) - map.get(char1); &#125; /** * @param op: 操作符 * @return: boolean * @description: 判断是否是操作符 */ private boolean isOp(char op) &#123; return op == '*' || op == '+' || op == '/' || op == '-' || op == '%' || op == '^'; &#125; 2.2.1 中缀——&gt;前缀表达式 遵循右优先，倘若一个中缀表达式右边的运算符能够先运算，该右边的运算符优先级高 规则： 从右向左遍历 操作数前插 操作符，若栈空入栈；不空，则将栈中大于当前运算符优先级出栈进行前插,或遇到右括号停止。之后再将当前运算符压栈 右括号入栈，遇到左括号不断弹出操作符前插，直到遇到右括号 /** * @param nifixExpression : 中缀表达式 * @return: String * @description: 中缀转前缀 */ public String nifixToPrefix(String[] nifixExpression) &#123; // 存储表达式拼接的结果 StringBuilder sb = new StringBuilder(); // 存储界限符和运算符的栈 Stack&lt;Character> stack = new Stack&lt;>(); char top; for (int i = nifixExpression.length - 1; i >= 0; i--) &#123; String temp = nifixExpression[i]; // 如果长度是1,可能是：1位数字,界限符,操作符 if(temp.length() == 1) &#123; char item = temp.charAt(0); // 如果是操作符 if(isOp(item)) &#123; if(stack.isEmpty()) stack.push(item); else &#123; while(!stack.isEmpty() &amp;&amp; (top = stack.peek())!=')' &amp;&amp; cmp(item, top) &lt; 0) sb.insert(0, top); stack.push(item); &#125; &#125; else if(item == ')' || item == '(') &#123; // 如果是左括号,不断出栈直到遇到右括号 if(item == '(') &#123; while(!stack.isEmpty() &amp;&amp; (top = stack.pop())!=')') sb.insert(0, top); &#125; else stack.push(')'); &#125; else &#123; // 如果是1位数字 sb.insert(0, item); &#125; &#125; else &#123; // 如果长度不为1,说明是多位的数字,进行前插 sb.insert(0, temp); &#125; &#125; while(!stack.isEmpty()) sb.insert(0, stack.pop()); return sb.toString(); &#125; 2.2.2 前缀——&gt;中缀表达式 该前缀表达式的运算符从右向左依次生效，故前缀转中缀规则： 从右向左遍历 将操作数压栈 遇到操作符，则将栈中最上面的两个元素弹出比如A和B，进行拼接。最后将拼接结果压栈 整个数组遍历结束后，栈中就是中缀结果 /** * @param prefixExpression: 前缀表达式 * @return: String * @description: 后缀转中缀 */ public String PrefixToNifix(String[] prefixExpression) &#123; if (prefixExpression.length == 0) return null; // 栈 Stack&lt;String> stack = new Stack&lt;>(); String top1, top2; for (int i = prefixExpression.length - 1; i >= 0; i--) &#123; String item = prefixExpression[i]; if (item.length() == 1 &amp;&amp; isOp(item.charAt(0))) &#123; // 如果是操作符,则取出栈中最上面两个元素进行合并 top1 = stack.pop(); top2 = stack.pop(); // 合并后重新压栈 stack.push('(' + top1 + item + top2 + ')'); &#125; else &#123; // 如果是操作数直接压栈 stack.push(item + \"\"); &#125; &#125; // 此时栈顶元素就是中缀表达式 String res = stack.pop(); // 处理多余的括号 return res.substring(1, res.length() - 1); &#125; 2.2.3 中缀——&gt;后缀表达式 遵循左优先，倘若一个中缀表达式左边的运算符能够先运算，该左边的运算符可以运算 规则： 遇到操作数。直接加入后缀表达式 遇到界限符。比如()[]{}，遇到左半部分入栈，遇到右半部分依次弹出栈内运算符并加入后缀表达式，直到弹出对应的左半部分界限符 遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式。若遇到左半部分界限符或者栈空，则停止。之后再把当前运算符入栈。 将栈中剩余元素弹出加入表达式 /** * @param nifixExpression : 中缀表达式 * @return: String * @description: 中缀转后缀 */ public String nifixToPostfix(String[] nifixExpression) &#123; StringBuilder sb = new StringBuilder(); // 存储界限符和运算符的栈 Stack&lt;Character> stack = new Stack&lt;>(); char top, item; for (String s : nifixExpression) &#123; // 每个s判断长度,如果是1,则可能为：一位的数字,操作符或者界限符 if (s.length() == 1) &#123; item = s.charAt(0); if (isOp(item)) &#123; if(stack.isEmpty()) stack.push(item); else &#123; // 如果遇到运算符,将优先级高于或等于item的运算符出栈加入表达式,直到栈空或遇到左半部分括号 while(!stack.isEmpty() &amp;&amp; (top = stack.peek())!= '(' &amp;&amp; cmp(item, top) &lt;= 0) sb.append(stack.pop()); stack.push(item); &#125; &#125; else if (item == ')' || item == '(') &#123; // 如果是界限符的右半部分 if (item == ')') &#123; // 不断出栈加入表达式中,直到遇到右半部分的括号 while (!stack.isEmpty() &amp;&amp; (top = stack.pop()) != '(') sb.append(top); &#125; else stack.push(item); &#125; else &#123; sb.append(s); &#125; &#125; else &#123; // 长度大于1说明一定是多位数字操作数 sb.append(s); &#125; &#125; while(!stack.isEmpty()) sb.append(stack.pop()); return sb.toString(); &#125; 2.2.4 后缀——&gt;中缀表达式 该后缀表达式的运算符从左向右依次生效，故后缀转中缀规则： 从左向右遍历 将操作数压栈 遇到操作符，则将栈中最上面的两个元素弹出比如A和B，进行拼接。需要注意拼接时，先弹出来的要放到操作符的后面，比如B*A。最后将拼接结果压栈 整个数组遍历结束后，栈中就是中缀结果 /** * @param postfixExpression: 后缀表达式 * @return: String * @description: 后缀转中缀 */ public String PostfixToNifix(String[] postfixExpression) &#123; if(postfixExpression.length == 0) return null; Stack&lt;String> stack = new Stack&lt;>(); String top1, top2; for (String item : postfixExpression) &#123; if (item.length() == 1 &amp;&amp; isOp(item.charAt(0))) &#123; // 如果是操作符,则取出栈中最上面两个元素进行合并 top1 = stack.pop(); top2 = stack.pop(); // 合并后重新压栈 stack.push('(' + top2 + item + top1 + ')'); &#125; else &#123; // 如果是操作数直接压栈 stack.push(item + \"\"); &#125; &#125; // 此时栈顶元素就是中缀表达式 String res = stack.pop(); // 处理多余的括号 return res.substring(1, res.length() - 1); &#125; 3 树 @Data @AllArgsConstructor @NoArgsConstructor public class TreeNode &#123; private int elem; private TreeNode lChild; private TreeNode rChild; &#125; 3.1 遍历 递归 3.1.1 先序遍历（递归） /** * @param root: 根节点 * @return: void * @description: 先序遍历 */ public void preOrder(TreeNode root) &#123; if (root != null) &#123; System.out.println(root.getElem()); preOrder(root.getlChild()); preOrder(root.getrChild()); &#125; &#125; 3.1.2 中序遍历（递归） /** * @param root: 根节点 * @return: void * @description: 中序遍历 */ public void inOrder(TreeNode root) &#123; if (root != null) &#123; preOrder(root.getlChild()); System.out.println(root.getElem()); preOrder(root.getrChild()); &#125; &#125; 3.1.3 后序遍历（递归） /** * @param root: 根节点 * @return: void * @description: 后序遍历 */ public void postOrder(TreeNode root) &#123; if (root != null) &#123; postOrder(root.getlChild()); postOrder(root.getrChild()); System.out.println(root.getElem()); &#125; &#125; 3.2 遍历 非递归 3.2.1 先序遍历（非递归） /** * @param root: 根节点 * @return: void * @description: 先序遍历,非递归 */ public void preOrderNonRecursion(TreeNode root) &#123; /** * 规则： * 1. 先将根节点入栈 * 2. 栈不为空, 出栈, 访问, 将出栈元素的右孩子、左孩子入栈 * 3. 循环第二步 */ if (root == null) return; StringBuilder res = new StringBuilder(); // 存储访问结果 TreeNode p = root; // 指针 Stack&lt;TreeNode> stack = new Stack&lt;>(); // 栈 stack.push(p); // 根节点入栈 while (!stack.isEmpty()) &#123; // 元素出栈 p = stack.pop(); // 访问出栈元素 res.append(p.getElem()); // 右孩子存在,入栈 if (p.getrChild() != null) stack.push(p.getrChild()); // 左孩子存在,入栈 if (p.getlChild() != null) stack.push(p.getlChild()); &#125; System.out.println(res.toString()); &#125; 3.2.2 中序遍历（非递归） /** * @param root: 根节点 * @return: void * @description: 中序遍历,非递归 */ public void inOrderNonRecursion(TreeNode root) &#123; /** * 规则： * 1. 先将根节点入栈 * 2. 如果该节点有左孩子,循环将所有左孩子入栈 * 3. 出栈,访问,如果出栈元素有右孩子,压栈 */ if (root == null) return; StringBuilder res = new StringBuilder(); // 存储访问结果 TreeNode p = root; // 指针 Stack&lt;TreeNode> stack = new Stack&lt;>(); // 栈 while (!stack.isEmpty() || p != null) &#123; // 将节点的所有左孩子入栈 while (p != null) &#123; stack.push(p); p = p.getlChild(); &#125; if (!stack.isEmpty()) &#123; // 出栈, 访问, 若有右孩子, 则入栈 p = stack.pop(); res.append(p.getElem()); p = p.getrChild(); &#125; &#125; System.out.println(res.toString()); &#125; 3.2.3 后序遍历（非递归|双栈） /** * @param root: 根节点 * @return: void * @description: 后序遍历,非递归,双栈 */ public void postOrderNonRecursion(TreeNode root) &#123; /** * 规则： * 1. 先按照根-右-左的顺序入栈 * 2.等所有节点入栈结束后, 一个个出栈 */ if (root == null) return; StringBuilder res = new StringBuilder(); // 存储访问结果 TreeNode p = root; // 指针 Stack&lt;TreeNode> stack1 = new Stack&lt;>(); // 栈 Stack&lt;TreeNode> stack2 = new Stack&lt;>(); // 栈 stack1.push(p); while (!stack1.isEmpty()) &#123; // 元素出栈 p = stack1.pop(); // 访问出栈元素 stack2.push(p); // 左孩子存在,入栈 if (p.getlChild() != null) stack1.push(p.getlChild()); // 右孩子存在,入栈 if (p.getrChild() != null) stack1.push(p.getrChild()); &#125; while(!stack2.isEmpty()) &#123; p = stack2.pop(); // 访问出栈元素 res.append(p.getElem()); &#125; System.out.println(res.toString()); &#125; 3.2.4 后序遍历（非递归|单栈） class MyEntry&lt;K, V> implements Map.Entry&lt;K,V> &#123; private final K key; private V value; MyEntry(K key, V value) &#123; this.key = key; this.value = value; &#125; @Override public K getKey() &#123; return key; &#125; @Override public V getValue() &#123; return value; &#125; @Override public V setValue(V value) &#123; V old = this.value; this.value = value; return old; &#125; &#125; 实现Map.Entry接口，重写方法 stack中存储的是一个键值对，key是树的节点，value是该节点的右孩子是否被访问，是boolean类型 /** * @param root: 根节点 * @return: void * @description: 后序遍历,非递归,一个栈 */ public void postOrderNonRecursion(TreeNode root) &#123; if (root == null) return; StringBuilder res = new StringBuilder(); // 存储访问结果 TreeNode bt = root; // 指针 Stack&lt;MyEntry&lt;TreeNode, Boolean>> stack = new Stack&lt;>(); MyEntry&lt;TreeNode, Boolean> stackNode; while(bt != null || !stack.isEmpty()) &#123; // 将该bt指向的节点以及所有的左孩子入栈 while(bt != null) &#123; // false表示该节点的右孩子没有被访问过 stackNode = new MyEntry&lt;>(bt, false); stack.push(stackNode); bt = bt.getlChild(); &#125; // 栈不空,并且栈顶元素的右孩子被访问过 while(!stack.isEmpty() &amp;&amp; stack.peek().getValue()) // 出栈,加入遍历结果中 res.append(stack.pop().getKey().getElem()); if(!stack.isEmpty()) &#123; // 令栈顶的右孩子被访问 stack.peek().setValue(true); // bt指向栈顶节点的右孩子 bt = stack.peek().getKey().getrChild(); &#125; &#125; System.out.println(res.toString()); &#125; 3.2.5 层次遍历 /** * @param root: 根节点 * @return: void * @description: 层次遍历 */ public void levelTraversal(TreeNode root) &#123; if(root == null) return; // 记录遍历结果 StringBuilder sb = new StringBuilder(); // 队列 Queue&lt;TreeNode> queue = new LinkedBlockingQueue&lt;>(); TreeNode node; queue.add(root); while(!queue.isEmpty()) &#123; node = queue.poll(); sb.append(node.getElem()); if(node.getlChild() != null) queue.add(node.getlChild()); if(node.getrChild() != null) queue.add(node.getrChild()); &#125; System.out.println(sb.toString()); &#125; 3.3 获取树的高度 获取树的高度 /** * @param root: 根节点 * @return: void * @description: 获取树的高度/深度 */ public void getTreeHeight(TreeNode root) &#123; if(root == null) return 0; // 获取左子树高度 int leftChildHeight = getTreeHeight(root.getlChild()); // 获取右子树高度 int rightChildHeight = getTreeHeight(root.getrChild()); return Math.max(leftChildHeight, rightChildHeight) + 1; &#125; 3.4 判断该树是否是平衡二叉树 判断该树是否是平衡二叉树 /** * @param root: 根节点 * @return: void * @description: 判断是否是AVL树 */ public boolean isAVL(TreeNode root) &#123; // 如果是空树 if(root == null) return true; // 获取左子树高度 int leftChildHeight = getTreeHeight(root.getlChild()); // 获取右子树高度 int rightChildHeight = getTreeHeight(root.getrChild()); return Math.abs(leftChildHeight - rightChildHeight) &lt;= 1; &#125; 3.5 给定一个数组建树 给定一个数组建树。利用层次遍历 /** * @param arr: 数组 * @return: TreeNode * @description: 根据数组创建树 */ public TreeNode createTreeByArray(int[] arr) &#123; if(arr.length == 0) return null; // 建立根节点 TreeNode root = new TreeNode(); root.setElem(arr[0]); // 创建队列 Queue&lt;TreeNode> queue = new LinkedBlockingQueue&lt;>(); TreeNode node, temp; // i用来指向数组元素的位置 int i = 1; // 根节点入队列 queue.add(root); while(!queue.isEmpty() &amp;&amp; i &lt; arr.length) &#123; // 出队列一个节点 node = queue.poll(); // 新建一个节点,将出栈节点的左指针指向该节点,新建的节点入栈 temp = new TreeNode(); temp.setElem(arr[i++]); node.setlChild(temp); queue.add(temp); // 如果数组还有元素,新建一个节点,将出栈节点的右指针指向该节点,新建的节点入栈 if(i &lt; arr.length) &#123; temp = new TreeNode(); temp.setElem(arr[i++]); node.setrChild(temp); queue.add(temp); &#125; &#125; queue.clear(); return root; &#125; 3.6 判断一颗树是否是完全二叉树 判断一颗树是否是完全二叉树 原理：若节点无左子树，则不应该有右子树 /** * @param root: 根节点 * @return: void * @description: 判断是否是FBT树 */ public boolean isFBT(TreeNode root) &#123; public boolean isFBT(TreeNode root) &#123; // 如果是空树 if (root == null) return true; // 声明一个队列,对树进行层次遍历 Queue&lt;TreeNode> queue = new LinkedBlockingQueue&lt;>(); // 当第一次出现null时,tag会置位true boolean tag = false; TreeNode node; // 根节点入队列 queue.add(root); while (!queue.isEmpty()) &#123; // 出队列 node = queue.poll(); // 如果有左孩子并且还没有出现第一个null if (!tag &amp;&amp; node.getlChild() != null) queue.add(node.getlChild()); else if (node.getlChild() != null) return false; else tag = true; // 如果有右孩子并且还没有出现第一个null if (!tag &amp;&amp; node.getrChild() != null) queue.add(node.getrChild()); else if (node.getrChild() != null) return false; else tag = true; &#125; return true; &#125; &#125; 3.7 给定一棵树的根节点和某个值,得到该值对应的所有祖先节点 给定一棵树的根节点和某个值,得到该值对应的所有祖先节点 利用单栈的后序遍历 /** * @param root: 树的根节点 * @param x: 被查找的值 * @return: TreeNode * @description: 根据数组创建树 */ public String getParents(TreeNode root, int x) &#123; // 存储该node节点的所有祖先 StringBuilder sb = new StringBuilder(); // 栈 Stack&lt;MyEntry&lt;TreeNode, Boolean>> stack = new Stack&lt;>(); TreeNode bt = root; while(bt != null || !stack.isEmpty()) &#123; // 如果bt有左孩子,并且bt的值不为x,则沿左分支向下入栈 while(bt != null &amp;&amp; bt.getElem() != x) &#123; stack.push(new MyEntry&lt;>(bt, false)); bt = bt.getlChild(); &#125; // bt指针一定不空,并且指向的节点要么是某个节点的左分支最后一个,要么该节点的值就位x if(bt != null &amp;&amp; bt.getElem() == x) &#123; while(!stack.isEmpty()) sb.insert(0,stack.pop().getKey().getElem()); return sb.toString(); &#125; while(!stack.isEmpty() &amp;&amp; stack.peek().getValue()) stack.pop(); if(!stack.isEmpty()) &#123; stack.peek().setValue(true); bt = stack.peek().getKey().getrChild(); &#125; &#125; return null; &#125; 3.8 统计某二叉树度1节点的数量 统计某二叉树度1节点的数量 /** * @param root: 树的根节点 * @param degree: 度 * @return: int * @description: 统计数中度为degree的节点数量 */ public int treeCountDegree(TreeNode root, int degree) &#123; int count = 0; LinkedBlockingQueue&lt;TreeNode> queue = new LinkedBlockingQueue&lt;>(); TreeNode bt; queue.add(root); // 通过层次遍历实现统计 while(!queue.isEmpty()) &#123; bt = queue.poll(); int temp = 0; if(bt.getlChild() != null)&#123; temp++; queue.add(bt.getlChild()); &#125; if(bt.getrChild() != null) &#123; temp++; queue.add(bt.getrChild()); &#125; if(temp == degree) count++; &#125; return count; &#125; 3.9 交换一个树所有节点的左右之树 交换一个树所有节点的左右之树 递归版本 /** * @param root: 根节点 * @return: void * @description: 交换树的左右子树, 递归 */ public void changeLeftAndRightChild(TreeNode root) &#123; if(root != null) &#123; // 交换左右子树 TreeNode temp = root.getlChild(); root.setlChild(root.getrChild()); root.setrChild(temp); // 递归修改左子树 changeLeftAndRightChild(root.getlChild()); // 递归修改左子树 changeLeftAndRightChild(root.getrChild()); &#125; &#125; 非递归版本 /** * @param root: 根节点 * @return: void * @description: 交换树的左右子树, 非递归 */ public void changeLeftAndRightChildNonRecursion(TreeNode root) &#123; if(root == null) return; // 利用层次遍历来完成 LinkedBlockingQueue&lt;TreeNode> queue = new LinkedBlockingQueue&lt;>(); TreeNode temp,bt; queue.add(root); while(!queue.isEmpty()) &#123; bt = queue.poll(); // 交换bt的左右子树 temp = bt.getlChild(); bt.setlChild(bt.getrChild()); bt.setrChild(temp); if(bt.getlChild() != null) queue.add(bt.getlChild()); if(bt.getrChild() != null) queue.add(bt.getrChild()); &#125; &#125; 3.10 已知先序和中序构建二叉树 已知先序和中序构建二叉树 /** * @param inOrder: 中序遍历数组 * @param preOrder: 先序遍历数组 * @param li: 中序遍历数组的左边界 * @param ri: 中序遍历数组的右边界 * @param lp: 先序遍历数组的左边界 * @param rp: 先序遍历数组的右边界 * @return: tree.TreeNode * @description: 根据中序和先序序列创建树, 递归 */ public TreeNode createTreeByInOrderAndPreOrder(int[] inOrder, int[] preOrder, int li, int ri, int lp, int rp) &#123; // 创建根节点 TreeNode root = new TreeNode(); root.setElem(preOrder[lp]); // 将根节点到中序遍历序列去遍历定位 int i; for (i = li; i &lt; inOrder.length &amp;&amp; inOrder[i] != root.getElem(); i++) ; // 此时,i的这个位置的左边就是左子树序列,右边就是右子树序列 // 左子树节点个数：i-li; 右子树节点个数ri-i // 左子树的节点在先序遍历数组中的下标范围是：[lp+1,lp+i-li] // 右子树的节点在先序遍历数组中的下标范围是：[lp+i-li+1,rp] if (i == li) root.setlChild(null); else root.setlChild(createTreeByInOrderAndPreOrder(inOrder, preOrder, li, i - 1, lp + 1, lp + i - li)); if (i == ri) root.setrChild(null); else root.setrChild(createTreeByInOrderAndPreOrder(inOrder, preOrder, i + 1, ri, lp + i - li + 1, rp)); return root; &#125; 3.11 已知后序和中序构建二叉树 已知先序和中序构建二叉树 /** * @param inOrder: 中序遍历数组 * @param postOrder: 后序遍历数组 * @param li: 中序遍历数组的左边界 * @param ri: 中序遍历数组的右边界 * @param lp: 后序遍历数组的左边界 * @param rp: 后序遍历数组的右边界 * @return: tree.TreeNode * @description: 根据中序和后序序列创建树, 递归 */ public TreeNode createTreeByInOrderAndPostOrder(int[] inOrder, int[] postOrder, int li, int ri, int lp, int rp) &#123; // 后序遍历数组的最后一个是根节点,然后创建根节点 TreeNode root = new TreeNode(); root.setElem(postOrder[rp]); // 根据这个根节点元素,去中序遍历数组中定位,然后划分左右子树 int i; for (i = 0; i &lt; inOrder.length &amp;&amp; inOrder[i] != root.getElem(); i++) ; // 此时,i的这个位置的左边就是左子树序列,右边就是右子树序列 // 左子树节点个数：i-li; 右子树节点个数ri-i // 左子树的节点在后序遍历数组中的下标范围是：[lp,lp+i-li-1] // 右子树的节点在后序遍历数组中的下标范围是：[rp-ri+i,rp-1] if (i == li) root.setlChild(null); else root.setlChild(createTreeByInOrderAndPostOrder(inOrder, postOrder, li, i - 1, lp, lp + i - li - 1)); if (i == ri) root.setrChild(null); else root.setrChild(createTreeByInOrderAndPostOrder(inOrder, postOrder, i + 1, ri, rp - ri + i, rp - 1)); return root; &#125; 3.12 给定一个整数数组，构建二叉排序树 给定一个数组，构建二叉排序树 /** * @param arr: 数组 * @return: TreeNode * @description: 构建二叉排序树 */ public TreeNode createBST(int[] arr) &#123; if (arr.length == 0) return null; // 创建根节点 TreeNode root = new TreeNode(); root.setElem(arr[0]); Stack&lt;TreeNode> stack = new Stack&lt;>(); // 根节点入栈 stack.push(root); TreeNode temp, top; for (int i = 1; i &lt; arr.length; i++) &#123; temp = new TreeNode(); temp.setElem(arr[i]); while (!stack.isEmpty()) &#123; top = stack.peek(); // 如果栈顶元素关键字的值&lt;当前要插入的节点 if (top.getElem() &lt; temp.getElem()) &#123; if (top.getrChild() == null) &#123; top.setrChild(temp); break; &#125; else &#123; stack.push(top.getrChild()); &#125; &#125; else &#123; // 如果栈顶元素关键字的值>当前要插入的节点 if (top.getlChild() == null) &#123; top.setlChild(temp); break; &#125; else &#123; stack.push(top.getlChild()); &#125; &#125; &#125; &#125; return root; &#125; 3.13 将一颗二叉树调整为平衡二叉树 4 查找 5 排序 点击这里查看内部排序详解","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"blog.silverbeats.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法设计题目","slug":"算法设计题目","permalink":"blog.silverbeats.cn/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE/"}],"author":"silverbeats"},{"title":"Mybatis","slug":"Mybatis","date":"2020-10-18T08:39:50.000Z","updated":"2020-10-21T06:24:53.049Z","comments":true,"path":"Mybatis/","link":"","permalink":"blog.silverbeats.cn/Mybatis/","excerpt":"","text":"1. 简介 1.1 什么是Mybatis MyBatis本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github MyBatis 是一款优秀的持久层框架 它支持自定义 SQL、存储过程以及高级映射。 MyBatis免除了几乎所有的 JDBC代码以及设置参数和获取结果集的工作。MyBatis可以通过简单的XML或注解来配置和映射原始类型、接口和 Java的POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 1.2 获得Mybatis Maven仓库 &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --> &lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> &lt;artifactId>mybatis&lt;/artifactId> &lt;version>3.5.3&lt;/version> &lt;/dependency> GitHub 中文文档 1.2 使用Mybatis的原因 简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。 解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 提供映射标签，支持对象与数据库的orm字段关系映射 提供对象关系映射标签，支持对象关系组建维护 提供xml标签，支持编写动态sql 2. 第一个Mybatis程序 2.1 环境搭建 搭建数据库 CREATE DATABASE `mybatistest`; USE `mybatistest`; CREATE TABLE `user` ( `id` INT(20) NOT NULL PRIMARY KEY, `name` VARCHAR(30) DEFAULT NULL, `pwd` VARCHAR(30) DEFAULT NULL )ENGINE=INNODB DEFAULT CHARSET=utf8; INSERT INTO `user` VALUES (1,\"张三\", \"123456\"), (2,\"李四\", \"1234567\"), (3,\"王五\", \"1234568\") 创建Maven项目 删除src目录 导入Maven依赖 &lt;dependencies> &lt;!--mysql驱动--> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>8.0.18&lt;/version> &lt;/dependency> &lt;!--mybatis--> &lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> &lt;artifactId>mybatis&lt;/artifactId> &lt;version>3.5.3&lt;/version> &lt;/dependency> &lt;!--Junit--> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.13&lt;/version> &lt;/dependency> &lt;/dependencies> 2.2 创建一个模块 在resources文件夹下，创建Mybatis核心配置文件 &lt;!--configuration核心配置文件--> &lt;configuration> &lt;!--多个环境--> &lt;environments default=\"development\"> &lt;!--开发环境--> &lt;environment id=\"development\"> &lt;!--事务管理--> &lt;transactionManager type=\"JDBC\"/> &lt;!--数据库相关--> &lt;dataSource type=\"POOLED\"> &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/> &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatistest?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai\"/> &lt;property name=\"username\" value=\"root\"/> &lt;property name=\"password\" value=\"root\"/> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;/configuration> 编写Mybatis的工具类 package com.silverbeats.utils; public class MybatisUtil &#123; private static SqlSessionFactory sqlSessionFactory; static &#123; // 使用Mybatis第一步：获取SQLSessionFactory对象 try &#123; String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。 // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession // 实例来直接执行已映射的 SQL 语句 public static SqlSession getSqlSession() &#123; return sqlSessionFactory.openSession(); &#125; &#125; 2.3 编写代码 实体类 public class User &#123; private int id; private String name; private String pwd; // 以及空参、有参、get、set、toString方法 &#125; Dao接口 public interface UserMapper &#123; List&lt;User> getUserList(); &#125; 接口实现类 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;!--命名空间 绑定一个对应的dao接口也就是mapper接口--> &lt;mapper namespace=\"com.silverbeats.dao.UserMapper\"> &lt;!--id对应绑定接口的方法,resultType返回类型要写全类名--> &lt;select id=\"getUserList\" resultType=\"com.silverbeats.pojo.User\"> select * from mybatistest.user &lt;/select> &lt;/mapper> 2.4 Junit测试 根据上面的内容进行测试一定出现下面的异常 绑定异常 org.apache.ibatis.binding.BindingException: Type interface com.silverbeats.dao.UserMapper is not known to the MapperRegistry 这是因为在Maybatis核心配置文件中缺少内容 &lt;!--每一个Mapper.xml都需要在Mybatis核心配置文件中注册,这里就是MapperRegistry--> &lt;mappers> &lt;mapper resource=\"com/silverbeats/dao/UserMapper.xml\"/> &lt;/mappers> 但是运行单元测试还是会出现下面的异常，表示找不到配置文件 java.lang.ExceptionInInitializerError at com.silverbeats.dao.UserMapperTest.test(UserMapperTest.java:15) …… Caused by: org.apache.ibatis.exceptions.PersistenceException: ### Error building SqlSession. ### The error may exist in com&#x2F;silverbeats&#x2F;dao&#x2F;UserMapper.xml ### Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.io.IOException: Could not find resource com&#x2F;silverbeats&#x2F;dao&#x2F;UserMapper.xml 这是因为Maven项目中资源导出的问题，需要在父工程或者子工程的pom.xml导入如下代码（保险起见都父子工程导入） &lt;build> &lt;resources> &lt;resource> &lt;directory>src/main/resources&lt;/directory> &lt;includes> &lt;include>**/*.properties&lt;/include> &lt;include>**/*.xml&lt;/include> &lt;/includes> &lt;filtering>false&lt;/filtering> &lt;/resource> &lt;resource> &lt;directory>src/main/java&lt;/directory> &lt;includes> &lt;include>**/*.properties&lt;/include> &lt;include>**/*.xml&lt;/include> &lt;/includes> &lt;filtering>false&lt;/filtering> &lt;/resource> &lt;/resources> &lt;/build> @Test public void test() &#123; // 获得SqlSession对象 SqlSession sqlSession = MybatisUtil.getSqlSession(); try &#123; // 方式一：执行sql UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User> userList = userMapper.getUserList(); // 方法2 // List&lt;User> userList = sqlSession.selectList(\"com.silverbeats.dao.UserMapper.getUserList\"); // 打印数据 for (User user : userList) &#123; System.out.println(user); &#125; &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭SqlSession sqlSession.close(); &#125; &#125; 2.5 总结 上面的第一个程序中，一共创建了6个文件 子工程resources/mybatis-config.xml Mybatis核心配置文件 子工程java目录下建包，dao目录下User实体类对应的接口UserMapper dao目录下实体类接口UserMapper对应的配置文件UserMapper.xml，并且每个xml配置文件都需要在Mybatis核心配置文件中进行注册 pojo目录下，User实体类，JavaBean utils目录下，MybatisUtil工具类，加载核心配置文件，返回sqlSession test目录下，对应目录结构，创建了Junit测试类 其中，在后期使用过程中，有一些文件是不需要修改的： MybatisUtil类不需要修改 User实体类不需要变动，除非数据库对应的字段发生变化 当需要向数据库添加新的表时，只需要在dao目录下创建对应的Mapper、Mapper.xml并在Mybatis-config.xml进行注册，以及pojo下的实体类即可 3. CRUD 在UserMapper.xml书写sql，进行CRUD 3.1 select标签 编写接口 // 查询全部用户 List&lt;User> getUserList(); // 根据id查询用户 User getUserById(int id); 编写对应Mapper.xml的sql &lt;!--普通查询--> &lt;select id=\"getUserList\" resultType=\"com.silverbeats.pojo.User\"> select * from mybatistest.user; &lt;/select> &lt;!--带有条件的查询--> &lt;select id=\"getUserById\" resultType=\"com.silverbeats.pojo.User\" parameterType=\"int\"> select * from mybatistest.user where id = #&#123;id&#125;; &lt;/select> id 绑定的namespace中的方法名 resultType sql语句执行的返回值 parameterType 参数类型 @Test public void getUserById() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.getUserById(2); System.out.println(user); sqlSession.close(); &#125; 3.2 insert标签 编写接口 // 插入用户 int addUser(User user); // 删除用户 int deleteUser(int id); 编写对应Mapper.xml的sql &lt;insert id=\"addUser\" parameterType=\"com.silverbeats.pojo.User\"> insert into mybatistest.user (id, name, pwd) values(#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;); &lt;/insert> @Test public void addUser() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int res = userMapper.addUser(new User(4, \"胡娜\", \"asdf\")); // 插入成功，提交事务 if(res > 0) &#123; sqlSession.commit(); &#125; sqlSession.close(); &#125; 3.3 update标签 编写接口 // 修改用户 int updateUser(User user); 编写对应Mapper.xml的sql &lt;update id=\"updateUser\" parameterType=\"com.silverbeats.pojo.User\"> update mybatistest.user set name=#&#123;name&#125;, pwd=#&#123;pwd&#125; where id = #&#123;id&#125;; &lt;/update> @Test public void updateUser() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int res = userMapper.updateUser(new User(4, \"胡娜12\", \"asdf\")); // 更新成功，提交事务 if(res > 0) &#123; sqlSession.commit(); &#125; sqlSession.close(); &#125; 3.4 delete标签 编写接口 // 删除用户 int deleteUser(int id); 编写对应Mapper.xml的sql &lt;delete id=\"deleteUser\" parameterType=\"int\"> delete from mybatistest.user where id = #&#123;id&#125;; &lt;/delete> @Test public void deleteUser() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int res = userMapper.deleteUser(4); // 插入成功，提交事务 if(res > 0) &#123; sqlSession.commit(); &#125; sqlSession.close(); &#125; 3.5 Map 倘若实体类或者数据库中的表字段过多，可以考虑使用Map集合来解决 // 用map插入用户 int addUser2(Map&lt;String, Object> map); &lt;!--通过map添加--> &lt;insert id=\"addUser2\" parameterType=\"map\"> insert into mybatistest.user (id, name, pwd) values(#&#123;userid&#125;, #&#123;userName&#125;, #&#123;password&#125;); &lt;/insert> @Test public void addUser2() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); HashMap&lt;String, Object> map = new HashMap&lt;String, Object>(); map.put(\"userid\", 7); map.put(\"userName\", \"呼啦啦\"); map.put(\"password\", \"lliiww\"); userMapper.addUser2(map); sqlSession.commit(); sqlSession.close(); &#125; Map传递参数，直接在sql中取出对应的key即可，parameterType=“map” 对象传递参数，直接在sql中取对象的属性即可，parameterType=“com.silverbeats.pojo.User” 在只有一个基本类型参数的情况下，可以直接在sql中取到 多个参数用Map，或者注解 4. 配置解析 配置文档 4.1 核心配置文件mybatis-config.xml 标签书写顺序 The content of element type “configuration” must match “(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)”. 4.2 properties 属性 可以通过properties 属性来实现引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置 在[上面的程序](#2. 第一个Mybatis程序)的核心配置文件中，可以将其中的driver、url、username、password写到properties文件中 driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatistest?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai username=root password=root 然后在核心配置文件中引入该properties文件 &lt;configuration> &lt;!--引入外部配置文件--> &lt;properties resource=\"db.properties\" /> &lt;environments default=\"development\"> &lt;environment id=\"development\"> &lt;transactionManager type=\"JDBC\"/> &lt;dataSource type=\"POOLED\"> &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/> &lt;property name=\"url\" value=\"$&#123;url&#125;\"/> &lt;property name=\"username\" value=\"$&#123;username&#125;\"/> &lt;property name=\"password\" value=\"$&#123;password&#125;\"/> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;!--每一个Mapper.xml都需要在Mybatis核心配置文件中注册--> &lt;mappers> &lt;mapper resource=\"com/silverbeats/dao/UserMapper.xml\"/> &lt;/mappers> &lt;/configuration> 同时properties标签内可以使用property标签来添加属性，比如将username和password用property传递，url和driver用properties文件 driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatistest?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai &lt;properties resource=\"db.properties\"> &lt;property name=\"username\" value=\"root\"/> &lt;property name=\"password\" value=\"root\"/> &lt;/properties> 这样也可以达到相同的效果。 倘若是下面这种情况 password=root &lt;properties resource=\"db.properties\"> &lt;property name=\"password\" value=\"1234\"/> &lt;/properties> 会优先使用properties文件中的password值 4.3 settings 设置 settings 设置文档 4.4 typeAliases 类型别名 在核心配置文件中给实体类起别名，这样，可以在Mapper.xml中的resultType和parameterType直接使用这个别名即可，而不需要写全类名 &lt;!--给实体类起别名--> &lt;typeAliases> &lt;typeAlias type=\"com.silverbeats.pojo.User\" alias=\"User\" /> &lt;/typeAliases> 也可以指定一个包名，Mybatis会在包名下面搜索需要的JavaBean，在没有注解的情况下，扫描到的Bean别名模式是类名小写 &lt;typeAliases> &lt;package name=\"com.silverbeats.pojo\"/> &lt;/typeAliases> 第三种起别名方式为加注解 @Alias(\"hulala\") public class User &#123;&#125; 上面三个方式都可以给实体类起别名，优先级不同，第一种直接给实体类起别名优先级最高，其次是注解，最后是指定包名给实体类起别名 4.5 environments 环境变量 MyBatis 可以配置成适应多种环境，尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境 &lt;!--通过修改default的值来切换环境--> &lt;environments default=\"development\"> &lt;environment id=\"development\"> &lt;transactionManager type=\"JDBC\"> &lt;property name=\"...\" value=\"...\"/> &lt;/transactionManager> &lt;dataSource type=\"POOLED\"> &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/> &lt;property name=\"url\" value=\"$&#123;url&#125;\"/> &lt;property name=\"username\" value=\"$&#123;username&#125;\"/> &lt;property name=\"password\" value=\"$&#123;password&#125;\"/> &lt;/dataSource> &lt;/environment> &lt;/environments> transactionManager事务管理器 JDBC 默认 MANAGED dataSource数据源，dataSource元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源，三种内建的数据源类型 UNPOOLED 这个数据源的实现会每次请求时打开和关闭连接。虽然有点慢，但对那些数据库连接可用性要求不高的简单应用程序来说，是一个很好的选择。 性能表现则依赖于使用的数据库，对某些数据库来说，使用连接池并不重要，这个配置就很适合这种情形 POOLED 默认 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这种处理方式很流行，能使并发 Web 应用快速响应请求 JNDI 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用 4.6 映射器Mappers 既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要来定义 SQL 映射语句了。 但首先，我们需要告诉 MyBatis 到哪里去找到这些语句。 在自动查找资源方面，Java 并没有提供一个很好的解决方案，所以最好的办法是直接告诉 MyBatis 到哪里去找映射文件。 你可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 file:/// 形式的 URL），或类名和包名等。例如： &lt;!-- 使用相对于类路径的资源引用 --> &lt;mappers> &lt;mapper resource=\"org/mybatis/builder/AuthorMapper.xml\"/> &lt;mapper resource=\"org/mybatis/builder/BlogMapper.xml\"/> &lt;mapper resource=\"org/mybatis/builder/PostMapper.xml\"/> &lt;/mappers> &lt;!-- 使用完全限定资源定位符（URL） --> &lt;mappers> &lt;mapper url=\"file:///var/mappers/AuthorMapper.xml\"/> &lt;mapper url=\"file:///var/mappers/BlogMapper.xml\"/> &lt;mapper url=\"file:///var/mappers/PostMapper.xml\"/> &lt;/mappers> 下面两个方法需要注意： 接口和它的Mapper配置文件必须同名 接口和它的Mapper配置文件必须同包 &lt;!-- 使用映射器接口实现类的完全限定类名 --> &lt;mappers> &lt;mapper class=\"org.mybatis.builder.AuthorMapper\"/> &lt;mapper class=\"org.mybatis.builder.BlogMapper\"/> &lt;mapper class=\"org.mybatis.builder.PostMapper\"/> &lt;/mappers> &lt;!-- 将包内的映射器接口实现全部注册为映射器 --> &lt;mappers> &lt;package name=\"org.mybatis.builder\"/> &lt;/mappers> 4.7 其他 typeHandlers 类型处理器 objectFactory 对象工厂 plugins 插件 Mybatis-generator-core Mybatis-plus 通用mapper 5. 生命周期和作用域 作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题 对象生命周期和依赖注入框架 依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。 如果对如何通过依赖注入框架使用 MyBatis 感兴趣，可以研究一下 MyBatis-Spring 或 MyBatis-Guice 两个子项目。 5.1 SqlSessionFactoryBuilder 可实例化 一旦创建了 SqlSessionFactory，就不再需要它了 作用域：局部变量 5.2 SqlSessionFactory 一旦创建，一直存在 可以想象为：数据库连接池 单例模式或静态单例模式 作用域：全局作用域 5.3 SqlSession 每个线程都应该有它自己的 SqlSession 实例，可以理解为连接到连接池的一个请求，需要自行请求和关闭 SqlSession 的实例不是线程安全的，因此是不能被共享的 用完就关闭，否则会出现资源占用 最佳的作用域是请求或方法作用域 6. 解决属性名和字段名不一致的问题 当实体类中的私有属性，比如password，而在数据库中对应的字段名是pwd，倘若通过id查询，是不会获得对应的值的。 因为在Mapper.xml中对应的sql是这样写的： select * from mybatistest.user where id = #&#123;id&#125;; -- 实际上是： select id,name,pwd from mybatistest.user where id = #&#123;id&#125;; -- 目标就是，如何将查询到的pwd值给到password 解决方法 起别名 select id,name,pwd as password from mybatistest.user where id = #&#123;id&#125;; resultMap结果集映射，在Mapper.xml中写 &lt;resultMap id=\"UserMap\" type=\"User\"> &lt;!--column和property值一样，可省略--> &lt;!--column对应数据库的列--> &lt;!--property对应实体类的属性值--> &lt;result column=\"id\" property=\"id\" /> &lt;!--column和property值一样，可省略--> &lt;result column=\"name\" property=\"name\" /> &lt;result column=\"pwd\" property=\"password\" /> &lt;/resultMap> &lt;!--此时不需要resultType--> &lt;select id=\"getUserById\" resultMap=\"UserMap\" parameterType=\"int\"> select * from mybatistest.user where id = #&#123;id&#125;; &lt;/select> 7. 日志 7.1 日志工厂 如果一个数据库操作出现异常，需要排错，日志就是最好的助手。 在核心配置文件中配置logImpl，指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J LOG4J 【掌握】【需要导包】 LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING【掌握】【可以直接用】 NO_LOGGING &lt;settings> &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/> &lt;/settings> 7.2 LOG4J Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIXSyslog守护进程等； 可以控制每一条日志的输出格式 可以定义每一条日志信息的级别，能够更加细致地控制日志的生成过程 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 导入LOG4J包 &lt;dependency> &lt;groupId>log4j&lt;/groupId> &lt;artifactId>log4j&lt;/artifactId> &lt;version>1.2.17&lt;/version> &lt;/dependency> log4j.properties #将登记为DEBUG的日志信息输出到console和file两个目的地 log4j.rootLogger = debug,console,file #控制台输出的相关配置 log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.Threshold = DEBUG log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern = [%c]-%m%n #文件输出相关配置 log4j.appender.file = org.apache.log4j.RollingFileAppender log4j.appender.file.File = ./logs/log.log log4j.appender.file.MaxFileSize = 10mb ##输出DEBUG级别以上的日志 log4j.appender.file.Threshold = DEBUG log4j.appender.file.layout = org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n #日志输出级别 log4j.logger.org.mybatis = DEBUG log4j.logger.java.sql = DEBUG log4j.logger.java.sql.Statement = DEBUG log4j.logger.java.sql.ResultSet = DEBUG log4j.logger.java.sql.PrepareStatement= DEBUG 配置核心文件 &lt;settings &lt;setting name=\"logImpl\" value=\"LOG4J\"/> &lt;/settings> 8. 分页 8.1 limit分页 分页的原因：减少数据的处理量，提高效率 select * from 表 limit startIndex, pageSize; 接口 // 测试分页 List&lt;User> getUsers(Map&lt;String, Integer> map); Mapper.xml &lt;select id=\"getUsers\" resultMap=\"UserMap\" parameterType=\"map\"> select * from mybatistest.user limit #&#123;startIndex&#125;, #&#123;pageSize&#125;; &lt;/select> 测试 @Test public void testLimit() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); HashMap&lt;String, Integer> map = new HashMap&lt;String, Integer>(); map.put(\"startIndex\", 1); map.put(\"pageSize\", 2); List&lt;User> userList = userMapper.getUsers(map); for (User user : userList) &#123; logger.info(user); &#125; sqlSession.close(); &#125; 8.2 RowBounds分页 接口 // 使用RowBounds查询 List&lt;User> getUsersByRowBounds(); Mapper.xml &lt;select id=\"getUsers\" resultMap=\"UserMap\"> select * from mybatistest.user; &lt;/select> 测试 @Test public void testRoundBounds() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); // RowBounds实现 RowBounds rowBounds = new RowBounds(0, 3); // 通过java代码层面实现分页 List&lt;User> selectList = sqlSession.selectList(\"com.silverbeats.dao.UserMapper.getUsersByRowBounds\",null, rowBounds); for (User user : selectList) &#123; logger.info(user); &#125; sqlSession.close(); &#125; 8.3 分页插件 pagehelper 9. 使用注解 接口 @Select(\"select * from user\") List&lt;User> getUsers(); // 方法存在多个参数,所有参数前面必须要有@Param @Select(\"select * from user where id = #&#123;id&#125;\") User getUserById(@Param(\"id\") int id); // 插入用户 @Select(\"insert into mybatistest.user (id, name, pwd) values(#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;)\") void insertUser(@Param(\"id\") int id, @Param(\"name\") String name,@Param(\"pwd\") String password); @Select(\"insert into mybatistest.user (id, name, pwd) values(#&#123;id&#125;, #&#123;name&#125;, #&#123;password&#125;)\") void addUser(User user); // 更新 @Update(\"update user set name = #&#123;name&#125; where id = #&#123;id&#125;\") int updateUser(User user); // 删除 @Delete(\"delete from user where id = #&#123;id&#125;\") int deleteUser(@Param(\"id\") int id); @Param()注解 基本类型的参数或者String类型，需要加上注解 如果只有一个基本类型，可以忽略 引用类型不需要加 在sql引用的就是这里设定的属性名 核心配置xml &lt;!--绑定接口--> &lt;mappers> &lt;mapper class=\"com.silverbeats.dao.UserMapper\"/> &lt;/mappers> 10. Lombok Lombok项目是一个Java库，它会自动插入您的编辑器和构建工具中，从而使您的Java更加生动有趣。永远不要再写另一个getter或equals方法，带有一个注释的您的类有一个功能全面的生成器，自动执行记录变量等。 idea中安装插件 项目中导入lombok的jar包 @data: 可以添加无参构造、get、set、toString、hashCode、equals @ToString: 重写toString方法 @AllArgsConstructor: 添加有参构造 @NoArgsConstructor: 添加无参构造 @EqualsAndHashCode: 添加hashCode、equals方法 11. 复杂查询环境 搭建环境，创建学生表和老师表 CREATE TABLE `teacher` ( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO teacher(`id`, `name`) VALUES (1, '乌拉拉'); CREATE TABLE `student` ( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAULT NULL, `tid` INT(10) DEFAULT NULL, PRIMARY KEY (`id`), KEY `fktid` (`tid`), CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('1', '小明', '1'); INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('2', '小红', '1'); INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('3', '小张', '1'); INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('4', '小李', '1'); INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('5', '小王', '1'); 11.1 多对一 多个学生关联一个老师 @Data @AllArgsConstructor @NoArgsConstructor public class Student &#123; private int id; private String name; private Teacher teacher; &#125; @Data @AllArgsConstructor @NoArgsConstructor public class Teacher &#123; private int id; private String name; &#125; -- 在mybatis实现下面的sql select * from student s, teacher t where s.tid = t.id; ①先获取所有学生的信息 ②根据学生的tid获取对应老师的信息 按照查询嵌套 &lt;select id=\"getStudentInfo\" resultMap=\"studentTeacher\"> select * from student; &lt;/select> &lt;resultMap id=\"studentTeacher\" type=\"student\"> &lt;result column=\"id\" property=\"id\"/> &lt;result column=\"name\" property=\"name\"/> &lt;association column=\"tid\" property=\"teacher\" javaType=\"teacher\" select=\"getTeacher\"/> &lt;/resultMap> &lt;select id=\"getTeacher\" resultType=\"teacher\"> select * from teacher where id = #&#123;tid&#125;; &lt;/select> 按照结果嵌套 &lt;select id=\"getStudentInfo2\" resultMap=\"studentTeacher2\"> select s.id sid, s.name sname, t.name tname from student s, teacher t where s.tid = t.id; &lt;/select> &lt;resultMap id=\"studentTeacher2\" type=\"student\"> &lt;result property=\"id\" column=\"sid\"/> &lt;result property=\"name\" column=\"sname\"/> &lt;association property=\"teacher\" javaType=\"teacher\"> &lt;result property=\"name\" column=\"tname\"/> &lt;/association> &lt;/resultMap> 11.2 一对多 一个老师关联多个学生 @Data @AllArgsConstructor @NoArgsConstructor public class Student &#123; private int id; private String name; private int tid; &#125; @Data @AllArgsConstructor @NoArgsConstructor public class Teacher &#123; private int id; private String name; private List&lt;Student> students; &#125; // 获取指定老师下的学生信息和老师信息 Teacher getTeacherById(@Param(\"tid\") int id); 按照结果嵌套 &lt;!--获取指定老师下的学生信息和老师信息--> &lt;select id=\"getTeacherById\" resultMap=\"teacherStudent\"> select s.id sid, s.name sname, t.name tname, t.id tid from student s, teacher t where s.tid = tid and tid = #&#123;tid&#125; &lt;/select> &lt;resultMap id=\"teacherStudent\" type=\"teacher\"> &lt;result property=\"id\" column=\"tid\" /> &lt;result property=\"name\" column=\"tname\"/> &lt;collection property=\"students\" ofType=\"student\"> &lt;result property=\"id\" column=\"sid\"/> &lt;result property=\"name\" column=\"sname\"/> &lt;result property=\"tid\" column=\"tid\"/> &lt;/collection> &lt;/resultMap> 按照查询嵌套 &lt;select id=\"getTeacherById\" resultMap=\"teacherStudent\"> select * from teacher where id = #&#123;tid&#125;; &lt;/select> &lt;resultMap id=\"teacherStudent\" type=\"teacher\"> &lt;result property=\"id\" column=\"id\" /> &lt;result property=\"name\" column=\"name\"/> &lt;collection property=\"students\" javaType=\"ArrayList\" ofType=\"student\" select=\"getStudentsByTeacherId\" column=\"id\" /> &lt;/resultMap> &lt;select id=\"getStudentsByTeacherId\" resultType=\"student\"> select * from student where tid = #&#123;tid&#125; &lt;/select> 12. 动态sql 根据不同的条件生成不同的sql 环境 CREATE TABLE `blog`( `id` VARCHAR(50) NOT NULL COMMENT '博客id', `title` VARCHAR(100) NOT NULL COMMENT '博客标题', `author` VARCHAR(30) NOT NULL COMMENT '博客作者', `create_time` DATETIME NOT NULL COMMENT '创建时间', `views` INT(30) NOT NULL COMMENT '浏览量' )ENGINE=INNODB DEFAULT CHARSET=utf8 public void addBlog() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); Blog blog = new Blog(); blog.setId(IDUtils.getID()); blog.setTitle(\"Mybatis\"); blog.setAuthor(\"狂神说\"); blog.setCreateTime(new Date()); blog.setViews(9999); mapper.addBlog(blog); blog.setId(IDUtils.getID()); blog.setTitle(\"Java\"); mapper.addBlog(blog); blog.setId(IDUtils.getID()); blog.setTitle(\"Spring\"); mapper.addBlog(blog); blog.setId(IDUtils.getID()); blog.setTitle(\"微服务\"); mapper.addBlog(blog); sqlSession.close(); &#125; &lt;mapper namespace=\"com.silverbeats.dao.BlogMapper\"> &lt;insert id=\"addBlog\" parameterType=\"blog\"> insert into blog(id, title, author, create_time, views) values(#&#123;id&#125;,#&#123;title&#125;,#&#123;author&#125;,#&#123;createTime&#125;,#&#123;views&#125;); &lt;/insert> &lt;/mapper> 实体类 @Data @NoArgsConstructor @AllArgsConstructor public class Blog &#123; private String id; private String author; private String title; private Date createTime; private int view; &#125; 12.1 iF 接口 // 查询blog List&lt;Blog> queryBlogIF(Map map); Mapper.xml &lt;select id=\"queryBlogIF\" parameterType=\"map\" resultType=\"blog\"> select * from blog where 1=1 &lt;if test=\"title != null\"> and title = #&#123;title&#125; &lt;/if> &lt;if test=\"author != null\"> and author = #&#123;author&#125; &lt;/if> &lt;/select> 测试 @Test public void testIf() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); HashMap map = new HashMap(); map.put(\"title\", \"Spring\"); List&lt;Blog> blogs = mapper.queryBlogIF(map); for (Blog blog : blogs) &#123; System.out.println(blog); &#125; sqlSession.close(); &#125; 12.2 choose(when、otherwise) choose标签，当满足第一个when的条件就不会再往下走了 &lt;!--测试choose--> &lt;select id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"blog\"> select * from blog &lt;where> &lt;choose> &lt;when test=\"title != null\">title = #&#123;title&#125;&lt;/when> &lt;when test=\"author != null\">and author = #&#123;author&#125;&lt;/when> &lt;otherwise>and views = #&#123;views&#125;&lt;/otherwise> &lt;/choose> &lt;/where> &lt;/select> 12.3 trim（where、set） where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。 &lt;!--测试where--> &lt;select id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"blog\"> select * from blog &lt;where> &lt;if test=\"title != null\">title = #&#123;title&#125;&lt;/if> &lt;if test=\"author != null\">and author = #&#123;author&#125;&lt;/if> &lt;/where> &lt;/select> set 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。 &lt;!--测试set--> &lt;update id=\"updateBlog\" parameterType=\"map\"> update blog &lt;set> &lt;if test=\"title != null\">title = #&#123;title&#125;,&lt;/if> &lt;if test=\"author != null\">author = #&#123;author&#125;,&lt;/if> &lt;/set> where id = #&#123;id&#125;; &lt;/update> 12.4 foreach foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！ &lt;!--测试foreach--> &lt;select id=\"queryForeach\" parameterType=\"ArrayList\" resultType=\"blog\"> select * from blog where views in &lt;foreach item=\"item\" collection=\"list\" index=\"index\" open=\"(\" close=\")\" separator=\",\"> #&#123;item&#125; &lt;/foreach> &lt;/select> 实质：循环字符串拼接 collection：需要遍历的集合 item：被遍历集合的每个元素 index：被遍历元素的索引 open：开始的字符 close：结束的字符 separator：分隔符 // 测试foreach List&lt;Blog> queryForeach(@Param(\"list\") List&lt;Integer> list); /*----------------------------------------------------------*/ @Test public void TestForeach() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); ArrayList&lt;Integer> list = new ArrayList&lt;Integer>(); list.add(1000); list.add(2000); list.add(7000); List&lt;Blog> blogs = mapper.queryForeach(list); sqlSession.close(); &#125; 12.5 sql片段 有的时候，会将公共的部分抽取出来，方便反复使用 &lt;!--测试sql片段--> &lt;sql id=\"if_title_author\"> &lt;if test=\"title != null\"> and title = #&#123;title&#125; &lt;/if> &lt;if test=\"author != null\"> and author = #&#123;author&#125; &lt;/if> &lt;/sql> &lt;!--测试where--> &lt;select id=\"queryBlogWhere\" parameterType=\"map\" resultType=\"blog\"> select * from blog &lt;where> &lt;include refid=\"if_title_author\" /> &lt;/where> &lt;/select> 最好基于单表来定义sql片段 sql片段中不要存在where标签 13. 缓存 读写分离，主从复制 经常查询并且不经常改变的数据可以使用缓存 13.1 Mybatis的缓存 Mybatis包含了一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存，缓存可以极大地提升查询效率 Mybatis系统中默认定义了两级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启，（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存 为了提高扩展性，Mybatis定义了缓存接口Cache，可以通过实现Cache接口来自定义二级缓存 13.2 一级缓存 @Test public void test() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user1 = mapper.queryUserById(1); System.out.println(\"=================\"); User user2 = mapper.queryUserById(1); System.out.println(user1 == user2); sqlSession.close(); &#125; 可以看到，只有一次SQL查询，并且user1和user2是同一个对象 缓存失效的情况 查询不同的东西 增删改操作，可能会改编原来的数据，所以会刷新缓存 @Test public void test() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user1 = mapper.queryUserById(1); System.out.println(\"=================\"); System.out.println(\"更新id=2的用户\"); HashMap map = new HashMap(); map.put(\"id\", 2); map.put(\"name\", \"嗯哼2\"); mapper.updateUserById(map); System.out.println(\"=================\"); User user2 = mapper.queryUserById(1); System.out.println(user1 == user2); sqlSession.close(); &#125; 查询不同的Mapper.xml 手动清理缓存 @Test public void test() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user1 = mapper.queryUserById(1); System.out.println(\"=================\"); System.out.println(\"清理缓存\"); sqlSession.clearCache(); System.out.println(\"=================\"); User user2 = mapper.queryUserById(1); System.out.println(user1 == user2); sqlSession.close(); &#125; 13.3 二级缓存 二级缓存也称全局缓存，是基于namespace级别的缓存，一个名称空间对应一个二级缓存 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中 如果当前会话关闭了，这个会话对应的一级缓存就没了，但是目标是：一级缓存消失，会将其中的数据保存到二级缓存中 新的会话查询信息，就可以从二级缓存中获取内容 不同的mapper查出的数据可以放在自己对应的缓存（map）中 步骤： 开启全局缓存 &lt;settings> &lt;setting name=\"cacheEnabled\" value=\"true\"/> &lt;/settings> 在Mapper.xml中添加cache标签 &lt;cache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/> @Test public void test() &#123; SqlSession sqlSession1 = MybatisUtil.getSqlSession(); SqlSession sqlSession2 = MybatisUtil.getSqlSession(); UserMapper mapper1 = sqlSession1.getMapper(UserMapper.class); UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class); User user1 = mapper1.queryUserById(1); System.out.println(\"关闭sqlSession1\"); sqlSession1.close(); User user2 = mapper2.queryUserById(1); System.out.println(\"=================\"); System.out.println(user1); System.out.println(user2); System.out.println(user1 == user2); sqlSession2.close(); &#125; 这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。 可用的清除策略有： LRU – 最近最少使用：移除最长时间不被使用的对象。 FIFO – 先进先出：按对象进入缓存的顺序来移除它们。 SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。 WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。 默认的清除策略是 LRU。 flushInterval（刷新间隔）属性可以被设置为任意的正整数，设置的值应该是一个以毫秒为单位的合理时间量。 默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新。 size（引用数目）属性可以被设置为任意正整数，要注意欲缓存对象的大小和运行环境中可用的内存资源。默认值是 1024。 readOnly（只读）属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。 13.4 缓存原理 缓存顺序： 先找二级缓存 再找一级缓存 最后查询数据库","categories":[{"name":"java","slug":"java","permalink":"blog.silverbeats.cn/categories/java/"},{"name":"Mybatis","slug":"java/Mybatis","permalink":"blog.silverbeats.cn/categories/java/Mybatis/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"blog.silverbeats.cn/tags/Mybatis/"}],"author":"silverbeats"},{"title":"算法设计与分析-动态规划","slug":"算法设计与分析-动态规划","date":"2020-10-02T08:27:27.000Z","updated":"2020-10-21T06:24:07.258Z","comments":false,"path":"算法设计与分析-动态规划/","link":"","permalink":"blog.silverbeats.cn/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"动态规划和分治法类似，其基本思想也是将待求解问题分解成若干个子问题。不同点在于，适用于动态规划的问题，其子问题往往不是相互独立，倘若使用分治法，会进行大量的重复计算。比如斐波那契数列求解问题，当计算Fib(10)时，会需要用到Fib(9)和Fib(8)，而计算Fib(9)也需要用到Fib(8)，实际上Fib(8)只需要计算一次即可，倘若使用分治法会对其进行两次的计算。（然而实际上，计算斐波那契数列不会用到这种求解方式，可以使用迭代解决，或者直接使用通项公式求解） 动态规划通常可以按下面四个步骤设计： 找出最优解的性质，并刻画其结构特征 递归定义最优解 以自底向上的方式计算出最优解 根据计算最优时得到的信息，构造最优解 动态规划往往是利用空间换时间 1. 矩阵连乘 矩阵的乘法有结合律，不同的计算顺序所耗费的代价不同。比如： 矩阵1 矩阵2 矩阵3 A10×100 A100×5 A5×50 计算顺序1：（矩阵1×矩阵2）×矩阵3 所需要的乘法次数：10×5×100 + 10×50×5 = 7500次 所需要的加法次数：10×5×99 + 10×50×4 = 6950次 计算顺序2：矩阵1×（矩阵2×矩阵3） 所需要的乘法次数：100×50×5 + 10×50×100 = 750000次 所需要的加法次数：100×50×4 + 10×50×99 = 497000次 这里不做矩阵相乘的O(n3)写法，相关代码可以参考算法设计与分析——分治法Strassen矩阵乘法。 2. 最长公共子序列 3. 最大子段和 4. 凸多边形最优三角剖分 5. 多边形游戏 6. 图像压缩 7. 电路布线 8. 流水作业调度 9. 背包问题 10. 最优二叉搜索树","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"算法设计与分析","slug":"算法/算法设计与分析","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"}],"tags":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"blog.silverbeats.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"silverbeats"},{"title":"KMP","slug":"KMP","date":"2020-09-29T05:08:18.000Z","updated":"2020-10-22T12:20:40.722Z","comments":true,"path":"KMP/","link":"","permalink":"blog.silverbeats.cn/KMP/","excerpt":"","text":"1. KMP简介 KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n) 2. KMP图解 2.1 通览(编号从0开始) 2.1.1 情况一 以上述主串和模式串为例子，可知，i指针指向主串，j指针指向模式串 当主串i位置与模式串j位置字符一样，i，j向后移动一个位置 2.1.2 情况二 易知，当i=5，j=5时，主串与模式串发生不匹配，此时需要进行的操作就是KMP的精华所在。 找到不匹配位置之前的字符串的最大公共前后缀。易知，最长公共前后缀是{A,B}，长度是2 进行如上图下半部分的操作。将字符串向后挪动，让前缀处于后缀的位置 易知，此时指针i是不需要任何变动。 挪动后，i，j所指向的位置继续比较。 字符串是不可能挪动的，实际上改变的是指针j，易知，挪动后指针j指向模式串编号为2的位置 上图，指针j经过调整后，从模式串编号2开始，继续和主串进行比较，当j指向编号6时发生不匹配，进行上述提到的步骤，经过调整得到下图情况三。 2.1.3 情况三 每次移动指针j后，需要检查主串剩余长度是否≥模式串需要匹配的长度 2.1.4 综合 根据上面提到的情况进行汇总，也就是代码实现的需要用到的步骤 当主串i位置与模式串j位置字符一样，i，j向后移动一个位置 当出现不匹配时，需要寻找不匹配位置之前的串的最大公共前后缀长度，比如长度是n，并将j移动到编号为n的位置，这里需要结合next数组，详情见[Next数组](#3. Next数组) 移动指针j后，需要检查主串剩余长度是否≥模式串需要匹配的长度，不符合条件直接break，返回匹配失败 当j的位置超过了模式串的编号，说明匹配成功，返回模式串第一个字符在主串出现的位置 2.2 通览(编号从1开始) 整个过程与上面标号从0开始的过程大体一致，只有一个区别就是：调整指针j的值，指的位置是不匹配位置之前的字符串的最大公共前后缀长度+1 3. Next数组 通过上一节内容可以知道，KMP算法核心是指向模式串的指针j的移动，该指针的如何移动实际上与主串是什么无关，只与模式串有关。只需要将模式串研究明白，则可以对任意主串进行匹配。 因为要匹配任意主串，故很容易知道，模式串的每个位置都有可能和主串出现不匹配。这时，当模式串每个位置出现不匹配时，此时的指针j应该调整到哪个位置，需要研究。 模式串第一个位置不匹配，j应该重新指向模式串的哪个位置 模式串第二个位置不匹配，j应该重新指向模式串的哪个位置 …… 将j重新指向的位置整理记录下来，存储到数组中，就是Next数组，Next数组的下标代表着该模式串出现不匹配的位置，数组下标对应的值就是j重新指向的位置。 同时需要考虑另外一个问题，这个问题在上面的内容有所体现。就是模式串起始编号是0还是1。起始编号不同，Next数组不同，二者之间相差一个位置 在进行KMP算法之前，是需要先获取模式串的Next数组，以便使用。 3.1 起始位置：0 上图提供的示例不全，但足以说明当某个位置出现不匹配时，指针j重新定位的位置为：不匹配位置之前字符串的最大公共前后缀长度所对应的编号 首先，为什么首位是-1，因为模式串首位不匹配需要挪动的是指向主串的i指针，是特殊情况，这样在获取next数组值的时候发现是-1，就知道需要挪动i指针，然而在实现时，只需要判断j时候等于0即可，并不需要访问next[0]时候等于-1。 3.2 起始位置：1 4. NextVal数组 5. 代码 5.1 Next 5.1.1 模式串从0标号 代码实现所使用到的next数组并不是[上面](#3.1 起始位置：0)提到的next数组。这里的next数组是每一位的最长公共前后缀的长度。比如next[2]=2，表示模式串前三个包括第三个字符，它们的最长公共前后缀长度是2。所以，倘若是模式串j位置出现不匹配，那么j位置之前的字符的最长公共前后缀长度是next[j-1] 关于下面getNext方法，可以理解为自己匹配自己 // 获取该模式串每个位置的最大公共前后缀长度 private int[] getNext(char[] pattern) &#123; // 模式串长度 int len = pattern.length; int[] next = new int[len]; next[0] = 0; // i代表最长前后缀长度 int i = 0, j; for(j = 1; j &lt; len; j++) &#123; while(pattern[i] != pattern[j] &amp;&amp; i > 0) i = next[i - 1]; if(pattern[i] == pattern[j]) next[j] = ++i; else next[j] = 0; &#125; return next; &#125; // 模式串匹配kmp算法,匹配成功返回匹配的位置,失败则返回-1 public int kmp(char[] str, char[] pattern) &#123; // 这里的next数组是每个位置的最长公共前后缀的长度 // 比如next[2]表示0、1、2三个位置组成的字符串公共前后缀的最大长度 int[] next = getNext(pattern); // 主串的长度mainLen,i指向主串比较的位置,j指向模式串比较的位置 int mainLen = str.length, i = 0, j = 0; while(i &lt; mainLen) &#123; // 情况三: 主串不够长 if(mainLen - i &lt; pattern.length - j) break; // 情况一: 主串的字符与模式串字符相等 if(str[i] == pattern[j]) &#123; i++; j++; // 当j指向的位置已经超过模式串长度时,说明匹配成功,则返回模式串在主串中匹配成功的位置 if(j >= pattern.length) return i - pattern.length; &#125; else &#123; // 情况二: 出现不匹配 // 如果j是模式串0位置,特殊情况 if(j == 0) &#123; // 挪动主串指针i i++; &#125; else &#123; // 重定位到不匹配位置之前字符，最大公共前后缀长度 j = next[j - 1]; &#125; &#125; &#125; // 默认失败 return -1; &#125; 同时可以发现，倘若要得到上面提到的那种next数组，只需要将里面所有的元素后移一个位置，然后首位添-1即可。上图中最后面的1会被舍弃。 5.1.2 模式串从1标号 // 获取模式串的next数组 private int[] getNext(char[] pattern) &#123; // 模式串长度 int len = pattern.length; int[] next = new int[len]; next[1] = 0; // i代表最长前后缀长度 int i = 1, j; for(j = 2; j &lt; len; j++) &#123; while(pattern[i] != pattern[j] &amp;&amp; i > 1) i = next[i - 1]==0?1:next[i-1]; if(pattern[i] == pattern[j]) next[j] = i++; else next[j] = 0; &#125; // 倘若写上了这一步,下面的kmp中的最后一个else只需要写j = next[j]即可 // 倘若没有这一步,下面的kmp中的最后一个else需要写成j = next[j - 1] + 1 for(int k = next.length - 1; k > 1; k--) &#123; next[k] = next[k-1] + 1; &#125; return next; &#125; public int kmp(char[] str, char[] pattern) &#123; // 获取该模式串的next数组 int[] next = getNext2(pattern); // 主串的长度mainLen,i指向主串比较的位置,j指向模式串比较的位置 int mainLen = str.length, i = 0, j = 1; while(i &lt; mainLen) &#123; if(mainLen - i &lt; pattern.length - j) break; // 主串的字符与模式串字符相等 if(str[i] == pattern[j]) &#123; i++; j++; // 当j指向的位置已经超过模式串长度时,说明匹配成功,则返回模式串在主串中匹配成功的位置 if(j >= pattern.length) return i - pattern.length + 1; // 这里有变化 &#125; else &#123; // 如果模式串在j这个位置与主串i这个位置字符不相等,则需要通过next数组来重新定位指向模式串字符的j的值 if(j == 1) &#123; i++; &#125; else &#123; // 这里有变化,倘若getNext有最后一个for循环 j = next[j]; // 倘若getNext没有最后一个for循环需要下面这种写法 // j = next[j - 1] + 1; &#125; &#125; &#125; // 默认失败 return -1; &#125; 5.2 NextVal","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"串","slug":"串","permalink":"blog.silverbeats.cn/tags/%E4%B8%B2/"},{"name":"KMP","slug":"KMP","permalink":"blog.silverbeats.cn/tags/KMP/"}],"author":"silverbeats"},{"title":"算法设计与分析——分治法","slug":"算法设计与分析-分治法","date":"2020-09-19T23:48:47.000Z","updated":"2020-10-22T12:32:33.944Z","comments":false,"path":"算法设计与分析-分治法/","link":"","permalink":"blog.silverbeats.cn/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%88%86%E6%B2%BB%E6%B3%95/","excerpt":"","text":"分治法的基本思想是将一个规模为n的问题分解为k个规模较小的子问题，这些子问题互相独立且与原问题相同。递归的解决这些子问题，然后将各个子问题的解合并得到原问题。 1. 二分搜索法 最简单的想法是从头找到尾，进行遍历，时间复杂度为O(n)，而利用分治法思想，使用二分搜索法，可以将时间复杂度缩小为O(logn)，但是该方法有一个前提就是，这一个序列必须有序。 下面代码假设序列是非递减序列 递归写法 public int binarySearch(int[] arr, int from, int to, int target) &#123; // 这说明没有数字了,说明没找到,返回-1 if(to &lt; from) return -1; // 得到from至to中间位置的数字的下标 int midPos = (to + from) >> 1; // 如果找到了该数字,返回数组下标 if(arr[midPos] == target) &#123; return midPos; &#125; else if(arr[midPos] > target) &#123; // 如果中间的数字比目标值大,说明目标值值在中间值的左边 return binarySearch(arr, from, midPos - 1, target); &#125; else &#123; // 如果中间的数字比目标值大,说明目标值值在中间值的右边 return binarySearch(arr, midPos + 1, to, target); &#125; &#125; 非递归写法 public int binarySearch2(int[] arr, int target) &#123; // 两个指针指向target存在区域的左右边界,圈定范围 int left = 0, right = arr.length - 1; while(left &lt;= right) &#123; // 得到该范围的中间位置 int midPos = (right + left) >> 1; // 说明找到了 if(arr[midPos] == target) return midPos; // 如果中间值大,说明目标值在中间值左边,右边界right指针挪到midPos的前一个 else if(arr[midPos] > target) right = midPos - 1; // 如果中间值大,说明目标值在中间值左边,右边界left指针挪到midPos的后一个 else left = midPos + 1; &#125; // 找不到返回-1 return -1; &#125; 2. 大整数乘法 对于乘法，直接使用乘法的运算符会很方便，但是仅限于参加运算的整数能在计算机硬件对整数的表示范围内直接处理时才是合理的。当需要处理很大的整数时，无法在计算机硬件能直接表示的整数范围内进行处理，若用浮点数表示，只能得到近似值，计算结果中的有效位数也会受到限制。 同时，当XY分3块，4块乃至更多，只会越来越慢。当分两块时，初步版需要4次，改进版需要3次相乘；而分成3块，其初步版就需要9次，想要得到比分成2块改进版的3次更少的乘法次数是不可能的，更何况是16次乘法的分4块初步版。 同时下图所示的过程有前提条件： X,Y都是n位，且n是2的整数次幂，只有这样才能保证每次划分A,B,C,D四个部分位数保持一致 （A-B），(D-C)这个两个数也需要满足上面这一条要求。因为这两个数相乘也是需要递归使用同一个函数 然而前提条件很多，实际上在使用时，上面两个条件都很难达到。当落地时，是实现初步版，计算4次乘法。 这里进行说明，为什么X可以那样表示。 比如一个十进制数1234，一共4位，按照上面的样子进行划分成左右AB两部分，则1234 = 12 * 102 + 34，这里的10其实是进制 同理，案例中，XY都是二进制，如X = 1101，X = 11 * 22 + 01，1101的十进制是13，11的十进制是3，01的十进制是1，X = 3 * 4 + 1 = 13 2.1 O(n2)写法 // 因为数字很大,无法用某个整数数据类型表示,需要转换成整型数组,方便处理 public int[] NumToArr(String num) &#123; num = fliter(num); char[] temp = num.toCharArray(); int[] arr = new int[temp.length]; for (int i = 0; i &lt; temp.length; i++) &#123; arr[i] = Integer.parseInt(temp[i] + \"\"); &#125; return arr; &#125; // 倘若传进来的字符串num中有0开头,比如0123,,或者00123,需要将0去掉 public String fliter(String num) &#123; int pos0 = num.indexOf('0'); if(pos0 != 0) return num; StringBuilder sb = new StringBuilder(num); while(pos0 == 0) &#123; sb.deleteCharAt(pos0); pos0 = sb.indexOf('0' + \"\"); &#125; return sb.toString(); &#125; // O(n2)的大整数乘法 public String LargeIntegerMultiplication(int[] num1, int[] num2) &#123; int len1 = num1.length; int len2 = num2.length; int[] res = new int[len1 * len2]; int p = res.length - 1; for(int i = len1 - 1; i >= 0; i--) &#123; for(int j = len2 - 1; j >= 0; j--) &#123; res[p--] += num2[j] * num1[i]; &#125; p++; &#125; // 处理进制 for(int k = res.length - 1; k >= 0; k--) &#123; if(res[k] >= 10) &#123; res[k - 1] = res[k] / 10; res[k] %= 10; &#125; &#125; // 从后向前充填res数组，可能没有填满，导致前几位有0 StringBuilder sb = new StringBuilder(); // 从头向后遍历当遇到第一次非0数字后,flag为true boolean flag = false; for (int k = 0; k &lt; res.length; k++) &#123; if (res[k] != 0) flag = true; if(flag) sb.append(res[k]); &#125; return sb.toString(); &#125; 2.2 分治法版本的O(n2) 2.2.1 主体 这里使用字符串，方便截取获得ABCD // 大整数乘法 public String largeLongMultiply(String num1, String num2) &#123; // 存储num1乘num2的结果的数组 int[] res; // 只要有一个字符串数字长度为1,那么就可以直接相乘了 if (num1.length() == 1 || num2.length() == 1) &#123; // 相乘 res = mult(num1, num2); &#125; else &#123; // 因为num1和num2长度不一定相同,假设num1长度为a,num2长度为b,同样分成两部分 // num1 = A*10^(a/2) + B // num2 = C*10^(b/2) + D // num1*num2 = AC*10^(a/2+b/2) + BD + AD10^(a/2) + BC*10^(b/2) // 开始截取字符串,得到ABCD int halfNum1 = num1.length() >> 1; int halfNum2 = num2.length() >> 1; String A = num1.substring(0, halfNum1), B = num1.substring(halfNum1), C = num2.substring(0, halfNum2), D = num2.substring(halfNum2); // 开始相乘 String AC = largeLongMultiply(A, C), BD = largeLongMultiply(B, D), AD = largeLongMultiply(A, D), BC = largeLongMultiply(B, C); // 位移,相加并得到最终结果 res = arrAddArr( strNumToArr(BD), arrAddArr( arrAddArr( move(strNumToArr(AC), halfNum1 + halfNum2), move(strNumToArr(AD), halfNum1) ), move(strNumToArr(BC), halfNum2) ) ); &#125; // 处理进制 decimalism(res); // 处理首位0,并转成字符串返回 return arrToStr(filterZero(res)); &#125; 2.2.2 主体之外的函数 // 只有当str1或者str2的length为1时才会执行这里 private int[] mult(String str1, String str2) &#123; int[] a = new int[str1.length()]; int[] b = new int[str2.length()]; // 将两个字符串变为数组,并且每个元素都是int类型 for (int i = 0; i &lt; a.length; i++) a[i] = (int) str1.charAt(i) - 48; for (int i = 0; i &lt; b.length; i++) b[i] = (int) str2.charAt(i) - 48; int[] res = new int[Math.max(a.length, b.length) + 1]; // 二者进行相乘 if (a.length == 1) &#123; for (int i = 0; i &lt; b.length; i++) res[i] = b[i] * a[0]; &#125; else &#123; for (int i = 0; i &lt; a.length; i++) res[i] = a[i] * b[0]; &#125; // 返回乘积结果 return res; &#125; // 字符串数字变数组 public int[] strNumToArr(String str) &#123; int len = str.length(); int[] arr = new int[len]; for (int i = 0; i &lt; len; i++) arr[i] = (int) str.charAt(i) - 48; return arr; &#125; // 数组变字符串 private String arrToStr(int[] arr) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; arr.length; i++) &#123; sb.append(arr[i]); &#125; return sb.toString(); &#125; // arr数组所代表的数字扩大n位 private int[] move(int[] arr, int n) &#123; int len = arr.length; int[] res = new int[len + n]; System.arraycopy(arr, 0, res, 0, len); return res; &#125; // 两个数组相加 private int[] arrAddArr(int[] arr1, int[] arr2) &#123; int len1 = arr1.length, len2 = arr2.length;//123,12 // 这里还需要长度＋1是因为：900 + 900 = 1800类似这种情况 // 另外两个相加的数组的长度不一定一样 int[] res = new int[Math.max(len1, len2) + 1]; int p = res.length - 1; int dist = len1 - len2; if (dist &lt; 0) &#123; // arr1短 for (int i = len1 - 1; i >= 0; i--) &#123; res[p--] = arr1[i] + arr2[i - dist]; &#125; for (int i = -dist - 1; i >= 0; i--) &#123; res[p--] = arr2[i]; &#125; &#125; else if (dist > 0) &#123; // arr2短 for (int i = len2 - 1; i >= 0; i--) &#123; res[p--] = arr1[i + dist] + arr2[i]; &#125; for (int i = dist - 1; i >= 0; i--) &#123; res[p--] = arr1[i]; &#125; &#125; else &#123; for (int i = arr1.length - 1; i >= 0; i--) &#123; res[p--] = arr1[i] + arr2[i]; &#125; &#125; // 处理进制 decimalism(res); // 再次考虑,当res[0]为0的情况 return filterZero(res); &#125; // 进制处理 private void decimalism(int[] arr) &#123; // 处理进制 for (int k = arr.length - 1; k > 0; k--) &#123; if (arr[k] >= 10) &#123; arr[k - 1] += arr[k] / 10; arr[k] %= 10; &#125; &#125; &#125; // 处理数组arr首位为0的情况 private int[] filterZero(int[] arr) &#123; if (arr[0] != 0) return arr; // 从头遍历arr,当出现第一个不为0的数字后,会变成true boolean flag = false; // 用来统计非0数字前面,0的个数 int k = 0; for (int i = 0; i &lt; arr.length &amp;&amp; !flag; i++) &#123; if (arr[i] != 0) flag = true; // 倘若还没有遇到第一个不为0的数字,计数+1 if (!flag) k++; &#125; // 比如[0,0,1,2,3],经过统计k=2,那么最终的finalRes长度应该是3 = arr.length - k int[] finalRes = new int[arr.length - k]; // 开始拷贝的位置下标应该是k System.arraycopy(arr, k, finalRes, 0, finalRes.length); return finalRes; &#125; 3. Strassen矩阵乘法 矩阵乘法，线性代数常见，假设两个矩阵同型AB，都是n×n的矩阵，C = AB，则在计算矩阵C时，C中每个元素都需要进行n次乘法和n-1次加法，最终求出C，n2个元素需要的计算时间复杂度是O(n3) 3.1 O(n3)写法 // 矩阵m1,a行b列;矩阵m2,c行d列 public int[][] matrixMultiply(int[][] m1, int[][] m2) &#123; // m1的行数,m1的列数 int m1Col = m1.length, m1Row = m1[0].length; // m2的行数,m2的列数 int m2Col = m1.length, m2Row = m2[0].length; // 检查矩阵相乘的条件 if (m1Row != m2Col) throw new RuntimeException(\"矩阵无法相乘\"); // 新建一个存储结果的矩阵 int[][] res = new int[m1Col][m2Row]; // 遍历m1的第i行 for(int i = 0; i &lt; m1Col; i++) &#123; // 遍历m2的第j列 for(int j = 0; j &lt; m2Row; j++) &#123; // 遍历m2的第k行 for(int k = 0; k &lt; m2Col; k++) &#123; res[i][j] += m1[i][k] * m2[k][j]; &#125; &#125; &#125; return res; &#125; 3.2 分治思想 假设条件： 两个矩阵都是n×n n都是2的幂 4. 棋盘覆盖 5. 合并排序 其实就是归并排序，相关代码可以查看排序 6. 快速排序 相关代码可以查看排序 快速排序的运行时间与每次划分是否对称有关，划分的最坏情况就是一边1个元素，另一边n-1的元素，当每次都划分对称的时候，时间复杂度是O(nlogn)，当每次划分都最坏的时候，时间复杂度是O(n2)，在排序提到，对于快速排序来说，越有序越慢，因为越有序，每次划分出现最坏情况的可能性就越大。 为了尽可能每次划分都较为对称，可以采用随机选择策略的快速排序算法。快速排序对于基准的选择都是待排序序列的第一个元素，随机选择意思就是说，在进行快速排序之前，先从序列中随机挑一个元素与序列首位进行位置交换，这样快排时的基准就是随机的了。 // 实现随机选择基准 // (int)(Math.random()*(high - low + 1))范围：[0,high - low + 1) // (int)(Math.random()*(high - low + 1)) + low范围：[low,high + 1)，即[low, high] private int RandomizedPartition(int[] arr, int low, int high) &#123; // i是从low-high随机挑选出来的下标 int i = (int)(Math.random()*(high - low + 1)) + low; // 将i位置的元素与待排序范围的首位进行交换 int temp = arr[low]; arr[low] = arr[i]; arr[i] = temp; return QSort_Partition(arr, low, high); &#125; // 快速排序 public void QSort(int[] arr, int low, int high) &#123; if (low &lt; high) &#123; int piovtpos = RandomizedPartition(arr, low, high); // 排左边 QSort(arr, low, piovtpos - 1); // 排右边 QSort(arr, piovtpos + 1, high); &#125; &#125; // 一趟快速排序 // 参数1：数组,参数2：数组的起始位置,参数3：数组的终了位置,闭区间 private int QSort_Partition(int[] arr, int left, int right) &#123; // 指定基准 int base = arr[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; arr[right] >= base) right--; if (left &lt; right) arr[left] = arr[right]; while (left &lt; right &amp;&amp; arr[left] &lt; base) left++; if (left &lt; right) arr[right] = arr[left]; &#125; arr[left] = base; return left; &#125; 7. 线性时间选择 给定一串数字，从中选出第k小，时间复杂度要求是O(n)，即线性时间选择。 7.1 利用堆排序获得第k小 易知，倘若要知道第k小的关键字，那么只需要利用小根堆，进行k次堆调整，即可得到第k小的关键字。 其中adjustHeap函数的代码可见排序，其中adjustHeap函数是调整成大根堆，只需要将循环中两个if判断条件中的小于号改成大于号，即可实现调整为小根堆的功能 public int heapSortFindK(int[] arr, int k) &#123; // 存储arr,目的是堆排序过程中不改变原数组 int[] temp = arr.clone(); int len = temp.length; // 首先构建小根堆 for (int pos = len / 2 - 1; pos >= 0; --pos) &#123; //从第一个非叶子结点从下至上，从右至左调整结构 adjustHeap(temp, pos, len); &#125; // 经过上一步可以得到小根堆,现在开始排序 for (int j = len - 1; j >= len - k; --j) &#123; //将堆顶元素与末尾元素进行交换 swap(temp, 0, j); //重新对堆进行调整 adjustHeap(temp, 0, j); &#125; return temp[len - k]; &#125; 7.2 利用快速排序获得第k小 每一次快排都会选则一个基准，将其排到它的最终位置，而第k小在排好序的序列中排在第k位。所以，可以通过比较每次快排后基准的最终位置与k，来获取第k小 public int QSortFindK(int[] arr, int k, int start, int end) &#123; // 首先,一趟快速排序,确定一个关键字的最终位置 int piovtpos = QSort_Partition(arr, start, end); // 易知，为了使快速排序的效率变高，可以利用上述随机策略法。 // int piovtpos = RandomizedPartition(arr, start, end); if(piovtpos + 1 == k) // 倘若该数字正好是第k小 return arr[piovtpos]; else if(piovtpos + 1 > k) &#123; // 说明目标在该数字的左边 return QSortFindK(arr, k, start, piovtpos - 1); else return QSortFindK(arr, k, piovtpos + 1, end); &#125; 8. 最接近点对问题 平面中有n个点，求出哪两个点之间的距离是最短的。很容易想到O(n2)的写法，倘若利用分治法，可以将时间复杂度降低为O(nlog2n) 9. 循环赛日程表","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"算法设计与分析","slug":"算法/算法设计与分析","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"}],"tags":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"分治法","slug":"分治法","permalink":"blog.silverbeats.cn/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"}],"author":"silverbeats"},{"title":"最短路径","slug":"最短路径","date":"2020-09-19T01:53:19.000Z","updated":"2020-10-25T13:34:01.922Z","comments":false,"path":"最短路径/","link":"","permalink":"blog.silverbeats.cn/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/","excerpt":"","text":"1. 迪杰斯特拉Dijkstra算法详解 1.1 完整代码 public void Dijkstra(int[][] graph, int start) &#123; // 当起点无法达到该点时,路径长度是无穷大,这里用整型最大值代替 int MAXDIST = Integer.MAX_VALUE; int vertexNum = graph.length; /* * 1. Dijkstra算法需要三个辅助数组 **/ boolean[] isVisited = new boolean[vertexNum]; int[] path = new int[vertexNum]; int[] dist = new int[vertexNum]; /* * 2. 初始化 **/ for (int i = 0; i &lt; vertexNum; i++) &#123; dist[i] = graph[start][i]; if (graph[start][i] &lt; MAXDIST) &#123; path[i] = start; &#125; else &#123; path[i] = -1; &#125; &#125; // start起点默认已经被访问 isVisited[start] = true; // start没有前驱结点,因为它是开始的位置 path[start] = -1; /* * 3. 迪杰斯特拉算法核心 **/ for (int i = 0; i &lt; vertexNum - 1; i++) &#123; // 存储最短路径 int minPath = MAXDIST; // 存储距离最小的点的数组下标 // 倘若这里minIndex不赋初始值,在后面isVisited[minIndex] = true会报错 // 因为后面的循环找最小值可能找不到 int minIndex = start; // 这个循环目的是:从未访问的节点中找到路径最短的那个 for (int j = 0; j &lt; vertexNum; j++) &#123; // 倘若这个节点没有访问,并且该点小于最短路径 if (!isVisited[j] &amp;&amp; dist[j] &lt; minPath) &#123; minPath = dist[j]; minIndex = j; &#125; &#125; if (minIndex != start) isVisited[minIndex] = true; for (int j = 0; j &lt; vertexNum; j++) &#123; if (!isVisited[j] &amp;&amp; graph[minIndex][j] != MAXDIST &amp;&amp; dist[minIndex] + graph[minIndex][j] &lt; dist[j] &amp;&amp; minIndex != start) &#123; dist[j] = dist[minIndex] + graph[minIndex][j]; path[j] = minIndex; &#125; &#125; &#125; &#125; 1.2 分段解读 1.2.1 完整过程图示 1.2.2 辅助数组说明 // 用来记录每个节点是否被访问 boolean[] isVisited = new boolean[vertexNum]; // 用来存储到达某个点最短路径的前一个节点下标 // 比如上图第1次循环,到达顶点4的最短路径是0-2-4,那么path[4]存放下标2 // 这个数组的每个值会不断变动 int[] path = new int[vertexNum]; // 存放到某个顶点的最短路径长度 // 比如顶点4,dist[4]从8,最后修改成7,这个数组的每个值会不断变动 int[] dist = new int[vertexNum]; 1.2.3 初始化说明 for (int i = 0; i &lt; vertexNum; i++) &#123; dist[i] = graph[start][i]; // 这一步其实可以不用,声明boolean数组时默认就是false // isVisited[i] = false; // start点到i有路径,这里面包含了start自己到自己 // path[start]=start,这是不对的,start没有前驱节点,应该存-1,循环结束之后会做处理 if (graph[start][i] &lt; MAXDIST) &#123; path[i] = start; &#125; else &#123; // 没有前驱节点的意思,当前以start为起点,到不了i这个点 path[i] = -1; &#125; &#125; // start起点默认已经被访问 isVisited[start] = true; // start没有前驱结点,因为它是开始的位置 path[start] = -1; 1.2.4 算法核心说明 for (int i = 0; i &lt; vertexNum; i++) &#123; // 存储最短路径 int minPath = MAXDIST; // 存储距离最小的点的数组下标 // 倘若这里minIndex不赋初始值,在后面isVisited[minIndex] = true会报错 // 因为后面的循环找最小值可能找不到 int minIndex = start; // 这个循环目的是:从未访问的节点中找到路径最短的那个 for (int j = 0; j &lt; vertexNum - 1; j++) &#123; // 倘若这个节点没有访问,并且该点小于最短路径 if (!isVisited[j] &amp;&amp; dist[j] &lt; minPath) &#123; minPath = dist[j]; minIndex = j; &#125; &#125; if (minIndex != start) isVisited[minIndex] = true; for (int j = 0; j &lt; vertexNum; j++) &#123; if (!isVisited[j] &amp;&amp; graph[minIndex][j] != MAXDIST &amp;&amp; dist[minIndex] + graph[minIndex][j] &lt; dist[j] &amp;&amp; minIndex != start) &#123; dist[j] = dist[minIndex] + graph[minIndex][j]; path[j] = minIndex; &#125; &#125; &#125; 内层循环第一个for比较简单，目的是找到一个点，该点满足：①未被访问，②有路径能访问，③到达改点路径值最小 内层循环第二个详解见下图： ❥(^_-)Tip： 当你使用某个数据类型的最大值作为无穷大，表示无该路径时，需要注意dist[minIndex] + graph[minIndex][j] &lt; dist[j]，倘若graph[minIndex][j]是无穷大，再加上一个数字后，会超出该类型的表示范围，变成一个负数，从而达成这个判断条件，执行if代码块中语句。这并不是我们想要的。所以需要在if中需要添加graph[minIndex][j] != MAXDIST这句话，避免上述情况发生 1.3 思考 首先，迪杰斯特拉算法能解决单源并且没有负权值边的最短路径问题，那么倘若出现负权值边，该算法不能求解出最短路径的原因是什么 1.3.1 尝试一下 当把1-&gt;2的权值改为-3后，继续走一遍之前的代码，就可以发现问题。 当i = 1时，即第二次循环，此时的minIndex为1，当j = 2时，根据if条件，因为isVisited[2]是之前访问过的点，所以不会执行if语句块中的代码，即便dist[minIndex] + graph[minIndex][j] &lt; dist[j]，5 + (-3) &lt; 3 那么倘若if中没有!isVisited[j]这个判断是否就可以了呢？ 根据上图，可以看到path数组是没有问题的，但是问题出在了dist[4]上。dist[4]应该为6，但却是7，这里是因为什么原因导致的？ 手动模拟一遍过程后不难发现，i=0的第一次循环修改了dist[4]和path[4]；在i=1的第二次循环，到达节点2的最短路径发生变化，但是没有任何的机会去修改以2为前驱的点的dist数组。 所以在第二个for循环中再添加一个循环，倘若某个点x的最短路径发生变化，去找以x为前驱的其他点y，看看y这个点的最短路径有没有因为x的变化而缩短。 for (int j = 0; j &lt; vertexNum; j++) &#123; if (graph[minIndex][j] != MAXDIST &amp;&amp; dist[minIndex] + graph[minIndex][j] &lt; dist[j] &amp;&amp; minIndex != start) &#123; dist[j] = dist[minIndex] + graph[minIndex][j]; path[j] = minIndex; // 在遍历一遍path数组 for(int k = 0; k &lt; vertexNum; k++) &#123; // 如果path数组的某个点的前驱节点正好是修改长度的点的话 if(path[k] == j &amp;&amp; dist[k] > dist[j] + graph[j][k]) &#123; dist[k] = dist[j] + graph[j][k]; &#125; &#125; &#125; &#125; 之后的结果就没有问题了： 2. 弗洛伊德Floyd算法详解 其实倘若涉及到负权值，会选择用Floyd算法，而且，更为强大的是，Floyd能够求出各个顶点到其他点的最短距离。 我不能呼吸了……= = 2.1 完整代码 public void Floyd(int[][] graph) &#123; int vertexNum = graph.length; // path数组,用来存储路径 int[][] path = new int[vertexNum][vertexNum]; // 初始化 for (int i = 0; i &lt; vertexNum; i++) &#123; for(int j = 0; j &lt; vertexNum; j++) path[i][j] = -1; &#125; for(int i = 0; i &lt; vertexNum; i++) &#123; for(int j = 0; j &lt; vertexNum; j++) &#123; for(int k = 0; k &lt; vertexNum; k++) &#123; if(graph[j][i] == Integer.MAX_VALUE || graph[i][k] == Integer.MAX_VALUE) continue; int temp = graph[j][i] + graph[i][k]; if(graph[j][k] > temp) graph[j][k] = temp; &#125; &#125; &#125; &#125; 举例：顶点0到4的最短路径 graph(0,4)的数字是6，说明最短路径长度是6，那么该怎么走呢。这是需要看path数组 path(0,4)为2，说明想要到顶点4需要经过顶点2，路径0-&gt;2-&gt;4，此时再看path(0,2)为1，说明想要从0到2需要经过顶点1，路径变为0-&gt;1-&gt;2-&gt;4 关于代码的详细描述过程，见文章：Floyd-傻子也能看懂的弗洛伊德算法（转）","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"最短路径","slug":"最短路径","permalink":"blog.silverbeats.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"blog.silverbeats.cn/tags/Dijkstra/"},{"name":"Floyd","slug":"Floyd","permalink":"blog.silverbeats.cn/tags/Floyd/"}],"author":"silverbeats"},{"title":"hexo相关命令语法","slug":"hexo相关命令语法","date":"2020-09-17T04:44:15.000Z","updated":"2020-10-21T06:24:35.698Z","comments":false,"path":"hexo相关命令语法/","link":"","permalink":"blog.silverbeats.cn/hexo%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E8%AF%AD%E6%B3%95/","excerpt":"","text":"1. 相关命令 #初始化一个hexo博客 hexo init blog #创建新页面 hexo new page 页面名 #清理之前生成的旧文件 hexo clean #重新生成静态文件 下面是简写 hexo generate hexo g #本地预览 下面是简写 hexo server hexo s #合并写法 hexo clean | hexo g | hexo s #通过git提交到仓库,需要配置hexo项目的_config.yml文件 hexo deploy hexo d #当安装七牛云同步插件后,可以通过如下命令将hexo根目录下的static文件夹同步到七牛云 hexo qiniu sync #或者 hexo qiniu s #或者 hexo qiniu sync2 #或者 hexo qiniu s2 2. 引用站内文章 &#123;% post_link 文章文件名（不要后缀） 文章标题（可选） %&#125; 3. 引用图片 3.1 引用七牛云图片 &#123;% qnimg 图片.格式 alt:这是图片 title:这是图片 %&#125; 不过这种方式引用图片，还是相当于本地存储，之后引用的图片会出现在需要上传的public目录中，还是会占用空间。 3.2 引用本地图片 倘若hexo项目的配置文件中将post_asset_folder设置为true，可以通过以下方式来引入图片，需要将example放入source/_post下的文章同名文件夹下。 &#123;% asset_path slug %&#125; &#123;% asset_img slug [title] %&#125; &#123;% asset_link slug [title] %&#125; &#123;% asset_img example.jpg This is an example image %&#125;","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"blog.silverbeats.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"blog.silverbeats.cn/tags/hexo/"}],"author":"silverbeats"},{"title":"排序","slug":"排序","date":"2020-09-16T14:17:31.000Z","updated":"2020-10-22T12:23:42.653Z","comments":true,"path":"排序/","link":"","permalink":"blog.silverbeats.cn/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"1. 插入排序 1.1 直接插入排序 直接插入排序，思想较为简单。 可以类比平常打扑克抓牌的过程。每次抓一张牌时，都会将这张牌与之前手里的牌（之前手里的牌是有序的）进行比较（从左向右比，或者从右向左比），得到一个最终的插入位置，然后插入。 // 直接插入排序, 假定前面是有序的，从乱序的后面取一个数插入有序的前面 public void insertSort(int[] arr) &#123; int len = arr.length; if (len == 0 || len == 1) return; // 进行插入排序 for (int i = 1; i &lt; len; i++) &#123; for (int j = i; j > 0; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; swap(arr, j, j - 1); &#125; &#125; &#125; &#125; // 交换 private void swap(int[] arr, int a, int b) &#123; int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125; 上面的代码可以再简化一下： // 直接插入排序, 假定前面是有序的，从乱序的后面取一个数插入有序的前面 public void insertSort(int[] arr) &#123; int len = arr.length; if (len == 0 || len == 1) return; // 进行插入排序 for (int i = 1; i &lt; len; i++) &#123; for (int j = i; j > 0 &amp;&amp; arr[j] &lt; arr[j - 1]; j--) swap(arr, j, j - 1); &#125; &#125; 1.2 折半插入排序 直接插入排序确定位置是通过将待排序的元素，与前面有序的序列一个个比较过去，从而得到最终的插入位置。那么，因为是顺序存储，利用数组实现排序，可以对前面的有序序列使用折半查找来确定最终插入位置。 public void binaryInsertSort(int[] arr) &#123; int len = arr.length; if (len == 0 || len == 1) return; // low high mid用于折半查找 int low, high, mid; for (int i = 1; i &lt; arr.length; i++) &#123; low = 0; high = i - 1; while (low &lt;= high) &#123; // (high+low)/2 这样的写法可能会超出int的表示范围 mid = low + ((high - low) >> 1); if (arr[mid] &lt; arr[i]) low = mid + 1; else high = mid - 1; &#125; // high + 1就是插入的位置 int temp = arr[i]; // 找到插入位置后,对元素进行挪动 for (int j = i - 1; j > high; j--) arr[j + 1] = arr[j]; // 将待排序的元素插入找到的位置 arr[high + 1] = temp; &#125; &#125; 1.3 希尔排序 希尔排序又称为缩小增量排序，当增量为1时，其实就是直接插入排序。增量的选取一般两种方案： 希尔提出，对数组长度不断折半。比如数组长度是32，则增量dk分别是：16,8,4,2,1 帕佩尔诺夫和斯塔舍维奇提出，dk = 2k + 1，dk &lt; 数组长度，k ≥ 0。比如数组长度是32，此时k 只能从4开始，则k = 4，dk = 17；k = 3，dk = 9；k = 2，dk = 5；k = 1，dk = 3；此时还需要额外添加dk = 1，算是一个兜底作用。 // 希尔排序 public int[] shellSort(int[] arr) &#123; int len = arr.length; if (len == 0 || len == 1) return arr; int dk = len >> 1; while (dk != 0) &#123; shell_InsertSort(arr, dk); // shell_BinaryInsertSort(arr, dk); dk = dk >> 1; &#125; return arr; &#125; /** * @Title: shell_InsertSort * @Description: 希尔排序，直接插入法进行排序 * @param ar: 数组 * @param dk: 间隔 * @return: void */ private void shell_InsertSort(int[] arr, int dk) &#123; int len = arr.length; int i, j; for (i = dk; i &lt; len; i++) &#123; int temp = arr[i]; for (j = i - dk; j >= 0 &amp;&amp; arr[j] > temp; j -= dk) &#123; arr[j + dk] = arr[j]; arr[j] = temp; &#125; &#125; &#125; /** * @Title: shell_BinaryInsertSort * @Description: 希尔排序，折半插入法进行排序 * @param arr: 数组 * @param dk: 间隔 * @return: void */ private void shell_BinaryInsertSort(int[] arr, int dk) &#123; int i, j, high, low, mid, temp; for (i = dk; i &lt; arr.length; i++) &#123; low = i % dk; high = i - dk; while (low &lt;= high) &#123; mid = low + (high - low) / 2; if (arr[mid] &lt; arr[i]) low = mid + dk; else high = mid - dk; &#125; temp = arr[i]; // high + dk 即为插入的位置 for (j = i - dk; j > high; j -= dk) arr[j + dk] = arr[j]; arr[high + dk] = temp; &#125; &#125; 后面那个通过折半插入法进行排序纯属练手，效率远远不及直接插入法希尔排序 前者，规模1W，20次，19ms 前者，规模10W，20次，187ms 后者，规模1W，20次，129ms 后者，规模10W，20次，10761ms 估计是在dk较小的时候，序列基本有序，折半插入的话是不管有没有序都得比较那么多次，而直接插入是越有序越快。 2. 选择排序 2.1 堆排序 堆又分大根堆和小根堆，倘若要升序，选择大根堆，倘若要降序，选择小根堆。 大根堆：根节点的数字不小于左右孩子的值 小根堆：根节点的值不大于左右孩子的值 堆排序是把一个数组，看做是一颗完全二叉树，排序步骤： 先对乱序的数组建立大根堆，可以得到数组的第一个元素（看做完全二叉树的话就是根节点）就是最大的 将其与数组最后面的那个值交换，然后重新调整，变为大根堆 依次类推 // 堆排序 public void heapSort(int[] arr) &#123; // 首先构建大根堆 for(int pos = arr.length/2 - 1; pos >= 0; --pos) &#123; //从第一个非叶子结点从下至上，从右至左调整结构 adjustHeap(arr, pos, arr.length); &#125; // 经过上一步可以得到大根堆,现在开始排序 for(int j = arr.length - 1; j > 0; --j) &#123; //将堆顶元素与末尾元素进行交换 swap(arr,0, j); //重新对堆进行调整 adjustHeap(arr,0, j); &#125; &#125; // 调整为大根堆 // arr是要调整的数组, i是要调整的数组下标, length是调整的范围 private void adjustHeap(int[] arr, int pos, int length) &#123; // 临时存储被调整的数组数据 int temp = arr[pos]; // pos是被调整元素的数组下标, 2*pos+1 是其左孩子 2*pos + 2是其右孩子 for(int i = pos*2 + 1; i &lt; length; i = i*2 + 1) &#123; /* 前面的判断条件保证它的右孩子是无序的, 在堆排序过程中会将最大值不断放到后面, length就是限制条件,可以通过这个条件让有序的右孩子不被波及 这个if保证i的下标对应的值是两个孩子中最大的那一个 */ if(i + 1 &lt; length &amp;&amp; arr[i] &lt; arr[i + 1]) &#123; i++; &#125; // 如果根节点小于它的孩子,则交换 if(temp &lt; arr[i]) &#123; // 交换根节点和它孩子的值 swap(arr, pos, i); // 因为经过了调整,当被调整的节点挪了位置,可能会导致后面的序列出问题,所以需要让pos定到i这个位置 pos = i; &#125; else &#123; break; &#125; &#125; &#125; 2.2 简单选择排序 思路简单：每次选择最大排到后面，或者每次选择最小的排到最前面 public void selectSort(int[] arr) &#123; // 每次过滤一遍数组将最小值放到前面 int i, j, min; for (i = 0; i &lt; arr.length - 1; i++) &#123; min = i; // 假定第i个位置最小 for (j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) min = j; &#125; if (i != min) swap(arr, i, min); &#125; &#125; 下面是另外一种做法，是每次将最小的放到最前面，最大的放到最后面 public void selectSort_2(int[] arr) &#123; // 每次过滤一遍数组将最小值放到前面 // 将最大的数字放到最后面 int i, j, min, max, lastPos; for (i = 0; i &lt;= arr.length >> 1; i++) &#123; min = max = i; lastPos = arr.length - i - 1; for (j = i + 1; j &lt;= lastPos; j++) &#123; if (arr[j] &lt; arr[min]) min = j; if (arr[j] > arr[max]) max = j; &#125; if (i != min) swap(arr, i, min); if (lastPos != max) swap(arr, max, lastPos); &#125; &#125; 前者，规模10W，20次，54408ms，2720ms/次 后者，规模10W，20次，53938ms，2697ms/次 呵呵…… 简单选择排序有两个版本，一种是如同上面的两种写法一样，将最大值（最小值）与序列最后（第一）个进行调换位置，这个版本成为交换版 另一种版本是将最大值（最小值）插入到序列的最后（最前）面，成为插入版。 区别在于： 交换版不稳定，插入版稳定 倘若序列顺序存储，插入版会涉及到大批量的元素挪动，不如交换版来的划算 倘若序列是链式存储，插入版会划算一些 3. 交换排序 3.1 冒泡排序 冒泡排序很经典，每次排序都能讲最大的数字排到最后，或者将最小的数字排到最前面 听说冒泡是毒瘤，比较次数和交换次数超级多 public int[] bubbleSort(int[] arr) &#123; int len = arr.length; if (len == 0 || len == 1) return arr; for (int i = 0; i &lt; len; i++) &#123; // 倘若内循环没有进行交换,则整个序列有序,会直接终止整个排序,是一个优化的地方 boolean flag = false; for (int j = 0; j &lt; len - i - 1; j++) &#123; if (arr[j] > arr[j + 1]) &#123; swap(arr, j, j + 1); flag = true; &#125; &#125; if (!flag) break; &#125; return arr; &#125; 继续发挥，双向冒泡 // 双向冒泡 public void bubble2Ways(int[] arr) &#123; int left = 0, right = arr.length - 1; boolean flag; while(left &lt; right) &#123; flag = false; // 从左往右将最大的数字挪到最右边 for(int i = left; i &lt; right; ++i) &#123; if(arr[i] > arr[i + 1])&#123; swap(arr, i, i + 1); flag = true; &#125; &#125; // 挪到结束后right-- --right; // 从右往左将最小的数字挪到最左边 for(int j = right; j > 0; --j) &#123; if(arr[j] &lt; arr[j - 1])&#123; swap(arr, j, j - 1); flag = true; &#125; &#125; ++left; if(!flag)break; &#125; &#125; 前者，规模1W，20次，1362ms，68ms/次 后者，规模1W，20次，1445ms，72ms/次 前者，规模10W，20次，303042ms，5min，15152ms/次 后者，规模10W，20次，202945ms，3min23s，10147ms/次 ……还是有点提高的 3.2 快速排序 利用分而治之的思想。每一次快速排序会实现这样的结果： 该数字的左边都比它小 该数字的右边都不小于它 每一次排序都会确定一个数的最终位置 // 快速排序 public void QSort(int[] arr, int low, int high) &#123; if (low &lt; high) &#123; int piovtpos = this.QSort_Partition(arr, low, high); // 排左边 QSort(arr, low, piovtpos - 1); // 排右边 QSort(arr, piovtpos + 1, high); &#125; &#125; // 一趟快速排序 // 参数1：数组,参数2：数组的起始位置,参数3：数组的终了位置,闭区间 private int QSort_Partition(int[] arr, int left, int right) &#123; // 指定基准 int base = arr[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; arr[right] >= base) right--; if (left &lt; right) arr[left] = arr[right]; while (left &lt; right &amp;&amp; arr[left] &lt; base) left++; if (left &lt; right) arr[right] = arr[left]; &#125; arr[left] = base; return left; &#125; 平均时间复杂度为nlogn的算法中，如：堆排序，快速排序，希尔排序，归并排序中，快速排序前面系数最小 规模1W，20次，15ms 规模10W，20次，359ms 快速排序有其特点：越有序越慢，越无序越快 4. 二路归并排序 /** * @Title: mergeSort * @Description: 归并排序 * @param arr: int类型数组 * @return: void */ public void mergeSort(int[] arr, int leftStart, int rightBound) &#123; if(leftStart == rightBound)return; if(leftStart > rightBound || leftStart &lt; 0 || rightBound &lt; 0)throw new RuntimeException(\"error\"); int mid = leftStart + ((rightBound - leftStart) >> 1); mergeSort(arr,leftStart,mid); mergeSort(arr,mid+1,rightBound); merge(arr, leftStart, mid+1, rightBound); &#125; /** * @Title: merge * @Description:一次归并,将两个有序的数组合并，仍有序 * @param arr 数组 * @param leftStart 第一个数组的左边界开始的位置 * @param rightStart 第二个数组的左边界开始的位置 * @param rightBound 第二个数组的右边界结束的位置 * @return: void */ private void merge(int[] arr, int leftStart, int rightStart, int rightBound) &#123; // 合并思想：新建一个数组，每次将小的数字放到新建的数组中 int i = leftStart, j = rightStart, k = 0; int[] tempArr = new int[rightBound - leftStart + 1]; while(i &lt; rightStart &amp;&amp; j&lt;= rightBound) tempArr[k++] = arr[i] &lt;= arr[j]?arr[i++]:arr[j++]; // 倘若还有剩余 while(i &lt; rightStart) tempArr[k++] = arr[i++]; while(j &lt;= rightBound) tempArr[k++] = arr[j++]; // 此时tempArr就是合并好有序的数组，对原始数组进行覆盖 for(int p = leftStart; p &lt;= rightBound; p++) arr[p] = tempArr[p - leftStart]; // 对原数组进行覆盖可以使用System.arraycopy,可以提高效率 /* if (i &lt; rightStart) &#123; System.arraycopy(arr, i, tempArr, k, rightStart - i); k += (rightStart - i); &#125; if (j &lt;= rightBound) &#123; System.arraycopy(arr, j, tempArr, k, rightBound - j + 1); &#125; System.arraycopy(tempArr, 0, arr, leftStart, tempArr.length); */ &#125; 规模1W，20次，32ms 规模10W，20次，241ms 5. 桶排序 5.1 基数排序 5.1.1 完整代码（只适用于非负数） // 基数排序 public void radixSort(int[] arr) &#123; int len = arr.length; int arrMax = getMinMax(arr)[1]; // 从个位开始,对数组进行排序 // exp = 1, 按照个位 // exp = 10, 按照十位 // exp = 100, 按照百位 for (int exp = 1; arrMax / exp > 0; exp *= 10) &#123; int i; // 存储被排序数组的临时数组 int[] output = new int[arr.length]; // 桶,因为不管是什么数字,个数十位不管是哪一位,都是0-9，所以桶数组的长度是10 int[] buckets = new int[10]; // 将数据出现的次数进行统计 for (i = 0; i &lt; len; i++) &#123; buckets[(arr[i] / exp) % 10]++; &#125; // 转为累加数组。目的是让更改后的buckets[i]的值，是该数据在output中的位置 for (i = 1; i &lt; 10; i++) &#123; buckets[i] += buckets[i - 1]; &#125; // 将数据存储到临时数组output中 for (i = len - 1; i >= 0; i--) &#123; output[buckets[(arr[i] / exp) % 10] - 1] = arr[i]; buckets[(arr[i] / exp) % 10]--; &#125; // 将排序好的数组赋值给arr for (i = 0; i &lt; len; i++) arr[i] = output[i]; &#125; &#125; 5.1.2 分段说明 分段说明举例说明的乱序数组为：{53, 3, 542, 748, 14, 214, 154, 63, 616}，为了更好的说明过程，for循环的说明将会以个位排序，演示整个过程 5.1.2.1 外层循环 arrMax是整个数组中最大的数字，同时也是位数最多的那个数字，比如arrMax是748，那么需要进行3次循环，分别对整个数组的个位，十位，百位来进行排序，故，外层循环的次数是由arrMax的位数来决定的。 for (int exp = 1; arrMax / exp > 0; exp *= 10) &#123; …… &#125; exp = 1，arrMax = 748/1 = 748&gt; 0，对个位进行排序 exp = 10，arrMax = 748/10 = 74 &gt; 0，对十位进行排序 exp = 100，arrMax = 748/100 = 8 &gt; 0，对百位进行排序 exp = 1000，arrMax = 748/1000 = 0 &gt; 0，false，中止外层循环 5.1.2.2 内部循环两个辅助数组的作用 首先，先来看一下，我们熟知的基数排序的过程： 很清楚能知道，其中一个辅助数组为buckets长度为10，即为上面的桶。但问题是，模拟的时候，是将每个数字放入桶中，然后取出的顺序是放入的先后顺序一致，颇有一种每个桶里面放的都是一个队列，先进先出，这样想倒是很符合，很自然，可以声明一个Object[]数组，之后每个位置存储一个队列，队列不需要自己实现，可以使用java.util包下的Queue实现类，之后操作就比较简单了，完全就和手动模拟的过程是一致的。（倘若用C语言，这样想能恶心死你= =） 但上面这种考虑虽然简单，但空间复杂度肯定是小不了的，这里给出的是另外一种比较巧妙的解决方案。可见后面更为详细的过程图。 // 存储被排序数组的临时数组 int[] output = new int[arr.length]; // 桶,因为不管是什么数字,个数十位不管是哪一位,都是0-9，所以桶数组的长度是10 int[] buckets = new int[10]; 5.1.2.3 内部四for第一for: 将数据出现的次数进行统计 (arr[i]/exp)%10的目的是要获得目标位置的数字。 首先，将需要的那一位变为个位，比如214，想要取得十位1，此时的exp = 10，先要除exp，得到21，这样想要的十位数字1就挪到了个位，之后让21 % 10，即可得到想要的十位数字1 这里的for循环其实目的是统计每个数字的exp位（exp = 1 表示每个数字的个位，exp = 10 表示每个数字的十位……）出现的次数。 for (i = 0; i &lt; len; i++) &#123; buckets[(arr[i] / exp) % 10]++; &#125; 以个排序演示完整过程，出现次数：为待排序数组，每个数字的个位出现的次数 5.1.2.4 内部四for第二for: 转为累加数组 // 转为累加数组。目的是让更改后的buckets[i]的值，是该数据在output中的位置 for (i = 1; i &lt; 10; i++) &#123; buckets[i] += buckets[i - 1]; &#125; 这个累加数组中的值，就代表了每个数字最终应该存储的位置。比如53这个数字，当按照个位排完序，应该在哪里？ 首先，我们应该能想到应该要遍历待排序数组，然后按照某种规则放入用来临时存储的output数组中。那么问题来了，应该正向遍历，还是逆向遍历？ 假设是正向遍历，遍历到每个数字都需要考虑一些问题： 有多少个数字在我前面 和我拥有相同的个位，有多少个，还有多少个没有被安排进临时数组 比如，第一个数字53，首先，获取53的个位数字3，对应到buckets数组中发现buckets[3] = 4，说明最后一个个位为3的数字应该排在第四个。通过buckets[2] = 1，说明能排在个位3前面的数字只有1个，能推出，在最后的排序结果中，以3为个位的数字应该排在序列的第2,3,4位置。问题来了，如何确定到底是那个位置，同时还要保证相同个位的数字之间相对位置不变。 假设是逆序，它天然就能保证在最终结果序列中，相同个位之间相对顺序不变。比如063。 buckets[3] = 4，让063排第4位，buckets[3] = 3 buckets[3] = 3，让003排第3位，buckets[3] = 2 buckets[2] = 2，让053排第2位，buckets[3] = 1 这个逻辑写起来就会很轻松。 5.1.2.5 内部四for第三for: 将数据存储到临时数组output中 这里是整个排序中最不好懂的一部分。但是当你看到上面的说明，这里就会比较容易去理解。为了方便理解，将源代码中的两行代码拆分。 // 将数据存储到临时数组output中 for (i = len - 1; i >= 0; i--) &#123; // 获取这个数字的exp位 int pos = (arr[i] / exp) % 10; // 对应到buckets数组 int b = buckets[pos]; // 数组下标从0开始,需要减1,才是arr[i]应该存储的地方 output[--b] = arr[i]; // 让桶的数字自减 buckets[pos]--; //output[buckets[(arr[i] / exp) % 10] - 1] = arr[i]; //buckets[(arr[i] / exp) % 10]--; &#125; 第1次：616，获取个位6，buckets[6] = 8，需要减1才是存放处，output[8 - 1] = 616，桶的数字减1，buckets[6] = 7 第2次：063，获取个位3，buckets[3] = 4，需要减1才是存放处，output[4 - 1] = 063，桶的数字减1，buckets[3] = 3 第3次：154，获取个位4，buckets[4] = 7，需要减1才是存放处，output[7 - 1] = 154，桶的数字减1，buckets[4] = 6 第4次：214，获取个位4，buckets[4] = 6，需要减1才是存放处，output[6 - 1] = 124，桶的数字减1，buckets[4] = 5 第5次：014，获取个位4，buckets[4] = 5，需要减1才是存放处，output[5 - 1] = 014，桶的数字减1，buckets[4] = 4 第6次：748，获取个位8，buckets[8] = 9，需要减1才是存放处，output[9 - 1] = 748，桶的数字减1，buckets[8] = 8 第7次：542，获取个位2，buckets[2] = 1，需要减1才是存放处，output[1 - 1] = 542，桶的数字减1，buckets[2] = 0 第8次：003，获取个位3，buckets[3] = 3，需要减1才是存放处，output[3 - 1] = 003，桶的数字减1，buckets[3] = 2 第9次：053，获取个位3，buckets[3] = 2，需要减1才是存放处，output[2 - 1] = 053，桶的数字减1，buckets[3] = 1 5.1.3 完整代码（适用于负数） public void radixSort(int[] arr) &#123; int len = arr.length; if(len == 1 ||len == 0) return; int[] temp = getMinMax(arr); // 应该是位数最多的那一个 int arrMax = Math.max(Math.abs(temp[0]), Math.abs(temp[1])); for (int exp = 1; arrMax / exp != 0; exp *= 10) &#123; int i; // 存储被排序数组的临时数组 int[] output = new int[len]; // 桶,因为要考虑负数,桶编号从-9~9,，所以桶数组的长度是19 int[] buckets = new int[19]; // 将数据出现的次数进行统计,其中buckets数组下标0-8代表-9~-1,下标9代表0,10-18代表1-9 for (i = 0; i &lt; len; i++) &#123; //获取这一位 int bit = arr[i]/exp % 10; buckets[bit + 9]++; &#125; // 转为累加数组。目的是让更改后的buckets[i]的值，是该数据在output中的位置 for (i = 1; i &lt; buckets.length; i++) &#123; buckets[i] += buckets[i - 1]; &#125; // 将数据存储到临时数组output中 for (i = len - 1; i >= 0; i--) &#123; output[buckets[(arr[i] / exp) % 10 + 9] - 1] = arr[i]; buckets[(arr[i] / exp) % 10 + 9]--; &#125; // 将排序好的数组赋值给arr for (i = 0; i &lt; len; i++) arr[i] = output[i]; &#125; &#125; 首先和上面不包含负数的基数排序相比，变动的地方如下： arrMax int[] temp = getMinMax(arr); int arrMax = Math.max(Math.abs(temp[0]), Math.abs(temp[1])); 实际上，arrMax的意义其实没有变化，都指的是这一串数字当中位数最多的那个数字，至于是正的还是负的，这无所谓，只要它位数最多。 所以，倘若这串数字包含负数，在获取位数最多的那个数字，可以这样获取。 其中getMinMax是获取arr中的最小值和最大值，返回值{min，max} 桶数组大小变动 int[] buckets = new int[19]; // 将数据出现的次数进行统计,其中buckets数组下标0-8代表-9~-1,下标9代表0,10-18代表1-9 for (i = 0; i &lt; len; i++) &#123; //获取这一位 int bit = arr[i]/exp % 10; buckets[bit + 9]++; &#125; …… // 将数据存储到临时数组output中 for (i = len - 1; i >= 0; i--) &#123; output[buckets[(arr[i] / exp) % 10 + 9] - 1] = arr[i]; buckets[(arr[i] / exp) % 10 + 9]--; &#125; 因为要考虑到负数，应该有：-9，-8，-7，-6，……，0，1，2，……，9共计19个桶 因为数组下标是从0开始的，所以在第一个计数的for循环，当在得到该数字的某一位时，需要+9 同时在第三个for循环，在获取某个桶的值的时候，也需要+9 5.2 计数排序 利用桶，空间换时间，在面对在一定范围内的大量重复数字的场景下，很适用。 比如一个省的高考成绩排名，可以声明一个长度为751的计数数组，其数组下标为0-750，代表每个分数。之后遍历整个省的所有人，统计每个分数的出现的次数，然后再遍历计数数组，即可实现有序。 /** * @Title: countSort * @Description:计数排序,适用于数字的范围小，排序量大的数组 * @param arr 数组 * @param min 该数组中的最小值 * @param max 该数组中的最大值 * @return: int[] */ public void countSort(int[] arr, int min, int max) &#123; // arr的最小值到最大值之间的数字，即为countArr的下标 int[] countArr = new int[max - min + 1]; // 统计arr中每个数字出现的次数 for (int j = 0; j &lt; arr.length; j++) countArr[arr[j] - min]++; int[] res = new int[arr.length]; // 将countArr变为累加数组,这一步主要是实现算法稳定 for (int m = 1; m &lt; countArr.length; m++) countArr[m] += countArr[m - 1]; // 这一步参见基数排序的过程示意图 for(int k = arr.length - 1; k >= 0; k--) res[--countArr[arr[k] - min]] = arr[k]; // 将排序好的数组赋值给arr for(int i = 0; i &lt; arr.length; i++) &#123; arr[i] = res[i]; &#125; &#125; 6. 排序比较 排序 英文 平均 最坏 最好 空间 稳定性 插入排序 Insertion n2 n2 n 1 稳 折半插入 n2 n2 nlog2n 1 稳 希尔排序 Shell n1.3 n2 n 1 不稳 堆排序 Heap nlog2n nlog2n nlog2n 1 不稳 选择排序 Selection n2 n2 n2 1 不稳 冒泡排序 Bubble n2 n2 n 1 稳 快速排序 Quick nlog2n n2 nlog2n log2n 不稳 归并排序 Merge nlog2n nlog2n nlog2n n 稳 桶排序 Bucket n+k n2 n n+k 稳 计数排序 Counting n+k n+k n+k n+k 稳 基数排序 Radix n*k n*k n*k n+k 稳 经过一趟排序能够使某个关键字到达最终位置的排序：交换类排序（冒泡，快速排序）、选择类排序（简单选择，堆排序） 排序算法的关键字比较次数和原始序列无关：简单选择排序和折半插入排序 排序算法的排序趟数和原始序列有关：交换类排序（冒泡，快速排序）","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"blog.silverbeats.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"排序","slug":"排序","permalink":"blog.silverbeats.cn/tags/%E6%8E%92%E5%BA%8F/"}],"author":"silverbeats"},{"title":"hexo之yelee主题配置","slug":"hexo之yelee主题配置","date":"2020-09-13T11:53:59.000Z","updated":"2020-10-21T06:23:55.889Z","comments":true,"path":"hexo之yelee主题配置/","link":"","permalink":"blog.silverbeats.cn/hexo%E4%B9%8Byelee%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/","excerpt":"","text":"参考文章： 使用Github搭建Hexo技术博客托管在GitHub Pages上–安装教程 博客系统hexo yelee搭建历程 hexo在文章中添加图片 Hexo七牛插件安装与使用 hexo相关命令语法 1. 前期准备 github账号、安装git nodejs notepad++或者editplus，记事本也可以 typora（后期写md格式文章用的软件） 可选内容 修改node.js源 &#x2F;&#x2F; 设置 淘宝镜像源 npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org &#x2F;&#x2F; 查看使用的镜像源 npm config get registry &#x2F;&#x2F; 安装淘宝镜像源 npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org 2. 实操 2.1 安装Hexo框架 npm install -g hexo-cli &#x2F;&#x2F; 或者 cnpm install -g hexo-cli 2.2 创建Hexo项目 在本地，选择要创建项目的目录 打开Git Bash（或者cmd命令行，或者powershell），并进入该目录 输入并运行hexo init blog之后，会在当前目录下创建blog文件夹，并初始化相关文件 cd blog进入创建的项目，运行npm install下载相关依赖包 2.3 相关命令 #清理之前生成的旧文件 hexo clean #重新生成静态文件 下面是简写 hexo generate hexo g #本地预览 下面是简写 hexo server hexo s #合并写法 hexo clean | hexo g | hexo s #通过git提交到仓库,需要配置,见后文 hexo deploy hexo d 2.4 下载yelee主题 在当前目录下，输入命令git clone https://github.com/MOxFIVE/hexo-theme-yelee themes/yelee，倘若下载速度是龟速，不如直接用迅雷下zip压缩包来的快…… Hexo主题压缩包，百度云，密码abcd 下载完成之后，需要修改项目目录下的_config.yml文件，找到theme主题字样，将后面的默认主题landscape修改为yelee。倘若之后想要更换主题也是如此。 2.5 修改yelee主题_config.yml文件 2.5.1 首页不显示文章列表 启动后会发现左侧导航栏，点击主页后不显示文章列表 进入yelee模板页的 _config.yml search: on: true onload: true ## true: get search.xml file when the page has loaded ## false: get the file when search box gets focus 2.5.2 相关链接无法跳转 在themes/yelee/_config.yml中类似如下的内容。实际上当预览的时候会发现有相关的链接没有配置路由。 ## About Page: &#96;hexo new page about&#96; ## Tags Cloud Page: &#96;hexo new page tags&#96; menu: 主页: &#x2F; 所有文章: &#x2F;archives&#x2F; 随笔: &#x2F;note&#x2F; 标签云: &#x2F;tags&#x2F; 关于我: &#x2F;about&#x2F; 因为随笔、标签云、关于我这种链接，在此项目中是没有的，需要去创建。留意上方注释，已经说明如何创建。 #在项目根目录下操作, 根据需要创建系统页 hexo new page tags hexo new page about hexo new page categories 2.5.3 添加文章的字数统计和大概看完的时间 #项目根路径下操作 npm i --save hexo-wordcount 文件配置： 在yelee/layout/_partial/post/word.ejs下创建word.ejs文件： &lt;!--倘若出现tag标签和统计字数的文件有布局上的问题，可以对上下外边距进行调整--> &lt;div style=\"margin-top:10px;margin-bottom: 30px\"> &lt;span class=\"post-time\"> &lt;span class=\"post-meta-item-icon\"> &lt;i class=\"fa fa-keyboard-o\">&lt;/i> &lt;span class=\"post-meta-item-text\"> 字数统计: &lt;/span> &lt;span class=\"post-count\">&lt;%= wordcount(post.content) %>字&lt;/span> &lt;/span> &lt;/span> &lt;span class=\"post-time\"> &amp;nbsp; | &amp;nbsp; &lt;span class=\"post-meta-item-icon\"> &lt;i class=\"fa fa-hourglass-half\">&lt;/i> &lt;span class=\"post-meta-item-text\"> 阅读时长: &lt;/span> &lt;span class=\"post-count\">&lt;%= min2read(post.content) %>分&lt;/span> &lt;/span> &lt;/span> &lt;/div> 然后在 themes/yelee/layout/_partial/article.ejs中添加 &lt;div class=\"article-inner\"> &lt;% if (theme.fancybox)&#123; %> &lt;input type=\"hidden\" class=\"isFancy\" /> &lt;% &#125; %> &lt;% if (post.link || post.title)&#123; %> &lt;header class=\"article-header\"> &lt;%- partial('post/title', &#123;class_name: 'article-title'&#125;) %> &lt;!-- 开始添加字数统计,这里才是添加的东西--> &lt;% if(theme.word_count &amp;&amp; !post.no_word_count)&#123;%> &lt;%- partial('post/word') %> &lt;% &#125; %> &lt;!-- 添加完成 --> &lt;/header> 开启功能 在yelee主题的_config.yml中添加： word_count: true 2.5.4 配置本地搜索 # 项目根目录运行 npm install hexo-generator-search --save 然后配置文件themes/yelee/_config.yml中修改为： search: on: true onload: true ## true: get search.xml file when the page has loaded ## false: get the file when search box gets focus 2.5.5 添加网站运行时间 \\themes\\yelee\\layout\\_partial路径下找到footer.ejs添加如下代码： &lt;footer id=\"footer\"> &lt;div class=\"outer\"> &lt;div id=\"footer-info\"> &lt;div class=\"footer-left\"> &lt;/div> &lt;!--添加代码的位置,以及要添加的代码 &lt;span id=\"timeDate\">载入天数...&lt;/span>&lt;span id=\"times\">载入时分秒...&lt;/span> &lt;script> var now = new Date(); function createtime() &#123; var grt = new Date(\"09/13/2020 12:49:00\");//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime() + 250); days = (now - grt) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if (String(hnum).length == 1) &#123; hnum = \"0\" + hnum; &#125; minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if (String(mnum).length == 1) &#123; mnum = \"0\" + mnum; &#125; seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if (String(snum).length == 1) &#123; snum = \"0\" + snum; &#125; document.getElementById(\"timeDate\").innerHTML = \"本站已安全运行 \" + dnum + \" 天 \"; document.getElementById(\"times\").innerHTML = hnum + \" 小时 \" + mnum + \" 分 \" + snum + \" 秒\"; &#125; setInterval(\"createtime()\", 250); &lt;/script> --> &lt;div class=\"footer-right\">&lt;/div> &lt;/div> …… &lt;/footer> 2.5.6 文章底部不显示作者 倘若出现了这种情况，可以在主题的配置文件中添加： author: 作者名字 2.5.7 添加点击爱心效果 下载js文件，链接地址,密码bcde 在theme/yelee/source下创建resources目录并将js文件拷贝到此目录下 在/themes/yelee/layout/_partial/after-footer.ejs下添加代码 &lt;script type=\"text/javascript\" src=\"/resources/float.js\">&lt;/script> &lt;script type=\"text/javascript\" src=\"/resources/love.js\">&lt;/script> &lt;script type=\"text/javascript\" color=0,104,183 opacity=1 zindex=-1 count=50 src=\"/resources/particle.js\">&lt;/script> &lt;script type=\"text/javascript\" src=\"/resources/typewriter.js\">&lt;/script> 2.5.11 其它 主题文件的_config.yml还可以配置什么： 网站的ico图标 自己的头像 导航栏链接 背景图片 是否开启分享 是否需要评论、以及是否显示评论数量 文章的标题风格、字体大小 …… 2.6 修改hexo的_config.yml 2.6.1 Url持久化 可以发现 hexo 默认生成的文章地址路径是 【网站名称／年／月／日／文章名称】。 这种链接对搜索爬虫是很不友好的，它的 url 结构超过了三层，太深了。 安装 hexo-abbrlink 插件： npm install hexo-abbrlink --save 然后配置根目录的_config.yml permalink: :title&#x2F; #permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F; 2.6.2 添加二次元虚拟人物 获取： npm install --save hexo-helper-live2d 下载人物模型，官方： npm install live2d-widget-model-shizuku # 对应use: live2d-widget-model-unitychan npm install live2d-widget-model-hibiki # 对应use: live2d-widget-model-hibiki 配置： live2d: enable: true scriptFrom: local model: #只需要修改unitychan就可以更换虚拟人物 use: live2d-widget-model-unitychan display: position: right width: 150 height: 300 mobile: show: true 2.6.3 当文章中有图片时 图片在博文中十分常见，因博客部署在GitHub上，空间有限，推荐将图片、音频、视频等文件存放在七牛云这样的地方。 2.6.3.1 使用七牛云同步插件 注册账号登录，点击对象存储，创建存储空间，并绑定域名，绑定域名参考官网提供的说明 hexo安装七牛云同步插件：npm install hexo-qiniu-sync --save hexo的配置文件中进行七牛云配置 #plugins: # - hexo-qiniu-sync qiniu: offline: true # 离线,true会省流量 sync: true bucket: #这里需要填写第一步创建的存储空间的名字 # 这里将其注释掉，不注释，执行hexo g报错 # secret_file: sec&#x2F;qn.json or C: #登录自己的七牛云账号，点击右上角的投降，选择密钥管理，可以获得 access_key: your access_key secret_key: your secret_key #上传的资源子目录前缀.如设置，需与urlPrefix同步 dirPrefix: static #外链前缀，第一步绑定的加速域名 urlPrefix: http:&#x2F;&#x2F;自己的加速域名&#x2F;static #使用默认配置即可 up_host: http:&#x2F;&#x2F;upload.qiniu.com &#x2F;&#x2F;本地目录 local_dir: static #是否更新已经上传过的文件(仅文件大小不同或在上次上传后进行更新的才会重新上传) update_exist: true image: folder: images extend: js: folder: js css: folder: css 在hexo根目录下创建如下目录结构，之后将对应的想要存放到七牛云的文件放到对应的文件夹即可 static - images - js - css 在文章中插入图片 &#123;% qnimg 图片.图片格式 title: alt: &#39;class:&#39; extend:?imageView2&#x2F;2&#x2F;w&#x2F;450 %&#125; 将本地static目录下的文件同步到七牛云 hexo qiniu sync #或者 hexo qiniu s #或者 hexo qiniu sync2 #或者 hexo qiniu s2 2.6.3.2 使用picGo工具 同步插件在使用过程中发现，在文章使用过程中看不到预览，并且在生成过程中还是会把图片放到public目录，所以会推荐使用picGo，提取码cdef工具来上传，成功后会返回外链地址，方便使用。 3. 把本地的博客内容同步到 Github 上 因为博客托管在GitHub上，所以在建立博客仓库时，仓库的名字需要命名为：用户名.github.io这样就可以通过用户名.github.io来访问该站点了。 创建好仓库后，需要本地生成SSH秘钥，方便通过git来进行提交 命令行输入：ssh-keygen -t rsa -C &quot;你的邮箱地址&quot;,之后不停的回车，期间，留意秘钥保存的路径，一般是：C:\\Users\\你的计算机用户名\\.ssh，会生成两个文件： 私钥：id_rsa 公钥：id_rsa.pub 访问自己GitHub账户的setting/SSH keys，将公钥的内容复制粘贴到Key的位置（主义末尾不要留有空行），title内容随意。 安装两个跟部署相关的 hexo 插件 npm install hexo -server --save npm install hexo-deployer-git --save 编辑全局的hexo配置文件：_config.xml # Hexo Configuration ## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;configuration.html ## Source: https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo&#x2F; # Site 这一块区域主要是设置博客的主要说明，需要注意的是：每个冒号后面都是有一个空格，然后再书写自己的内容的s title: LearnFoever #网站标题 subtitle: #网站副标题 description: #描述 author: silverbeats email: 418116014@qq.com language: zh-CN timezone: #网站时区。Hexo 默认使用您电脑的时区 # URL 这一块一般可以设置的是 url 这个参数，比如我要设置绑定域名的，这里就需要填写我的域名信息 ## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39; url: http:&#x2F;&#x2F;silverbeats.github.io #倘若已经购买了域名的话可以填买的域名 root: &#x2F; #这里配置的url持久化 permalink: :title&#x2F; #:year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F; permalink_defaults: # Directory source_dir: source #源文件夹，这个文件夹用来存放内容。 public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件 tag_dir: tags #标签文件夹 archive_dir: archives #归档文件夹 category_dir: categories #分类文件夹 code_dir: downloads&#x2F;code #nclude code 文件夹 i18n_dir: :lang #国际化（i18n）文件夹 skip_render: #跳过指定文件的渲染，可使用 glob 表达式来匹配路径 # Writing new_post_name: :title.md #新建文章默认文件名 default_layout: post # 默认布局 titlecase: false # Transform title into titlecase external_link: true # 在新标签中打开一个外部链接，默认为true filename_case: 0 render_drafts: false #是否渲染_drafts目录下的文章，默认为false post_asset_folder: true #启动 Asset 文件夹 relative_link: false #把链接改为与根目录的相对位址，默认false future: true #显示未来的文章，默认false highlight: #代码块的设置 enable: true line_number: true auto_detect: false tab_replace: &#39;&#39; wrap: true hljs: false prismjs: enable: false preprocess: true line_number: true tab_replace: &#39;&#39; # Home page setting # path: Root path for your blogs index page. (default &#x3D; &#39;&#39;) # per_page: Posts displayed per page. (0 &#x3D; disable pagination) # order_by: Posts order. (Order by date descending by default) index_generator: path: &#39;&#39; per_page: 10 order_by: -date # Category &amp; Tag #分类和标签的设置 default_category: uncategorized #默认分类 category_map: tag_map: # Metadata elements ## https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;HTML&#x2F;Element&#x2F;meta meta_generator: true # Date &#x2F; Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http:&#x2F;&#x2F;momentjs.com&#x2F;docs&#x2F;#&#x2F;displaying&#x2F;format&#x2F; date_format: YYYY-MM-DD time_format: HH:mm:ss ## updated_option supports &#39;mtime&#39;, &#39;date&#39;, &#39;empty&#39; updated_option: &#39;mtime&#39; # Pagination ## Set per_page to 0 to disable pagination per_page: 10 pagination_dir: page # Include &#x2F; Exclude file(s) ## include:&#x2F;exclude: options only apply to the &#39;source&#x2F;&#39; folder include: exclude: ignore: # Extensions ## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F; ## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F; theme: yelee # next yelee search: path: search.xml field: all # Deployment ## 这里是重点，这里是修改发布地址，因为我们前面已经加了 SSH 密钥信息在 Github 设置里面了，所以只要我们电脑里面持有那两个密钥文件就可以无需密码地跟 Github 做同步。 ## 需要注意的是这里的 repo 采用的是 ssh 的地址，而不是 https 的。分支我们默认采用 master 分支，以后熟悉了要换其他也无所谓。 ## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html deploy: type: git repo: github: git@github.com:SilverBeats&#x2F;SilverBeats.github.io.git,master # hexo-neat 对静态文件进行压缩 neat_enable: true neat_html: enable: true exclude: neat_css: enable: true exclude: - &#39;*.min.css&#39; neat_js: enable: true mangle: true output: compress: exclude: - &#39;*.min.js&#39; #萌妹子 live2d: enable: true scriptFrom: local model: use: live2d-widget-model-hibiki display: position: right width: 150 height: 300 mobile: show: true","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"blog.silverbeats.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"blog.silverbeats.cn/tags/hexo/"},{"name":"git","slug":"git","permalink":"blog.silverbeats.cn/tags/git/"},{"name":"github","slug":"github","permalink":"blog.silverbeats.cn/tags/github/"},{"name":"nodejs","slug":"nodejs","permalink":"blog.silverbeats.cn/tags/nodejs/"}],"author":"silverbeats"}],"categories":[{"name":"java","slug":"java","permalink":"blog.silverbeats.cn/categories/java/"},{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"书籍","slug":"书籍","permalink":"blog.silverbeats.cn/categories/%E4%B9%A6%E7%B1%8D/"},{"name":"设计模式","slug":"java/设计模式","permalink":"blog.silverbeats.cn/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Mybatis","slug":"java/Mybatis","permalink":"blog.silverbeats.cn/categories/java/Mybatis/"},{"name":"算法设计与分析","slug":"算法/算法设计与分析","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"博客搭建","slug":"博客搭建","permalink":"blog.silverbeats.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"java","slug":"java","permalink":"blog.silverbeats.cn/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"blog.silverbeats.cn/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"数据结构","slug":"数据结构","permalink":"blog.silverbeats.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"书籍","slug":"书籍","permalink":"blog.silverbeats.cn/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"设计模式","slug":"设计模式","permalink":"blog.silverbeats.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"算法设计题目","slug":"算法设计题目","permalink":"blog.silverbeats.cn/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE/"},{"name":"Mybatis","slug":"Mybatis","permalink":"blog.silverbeats.cn/tags/Mybatis/"},{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"blog.silverbeats.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"串","slug":"串","permalink":"blog.silverbeats.cn/tags/%E4%B8%B2/"},{"name":"KMP","slug":"KMP","permalink":"blog.silverbeats.cn/tags/KMP/"},{"name":"分治法","slug":"分治法","permalink":"blog.silverbeats.cn/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"},{"name":"最短路径","slug":"最短路径","permalink":"blog.silverbeats.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"blog.silverbeats.cn/tags/Dijkstra/"},{"name":"Floyd","slug":"Floyd","permalink":"blog.silverbeats.cn/tags/Floyd/"},{"name":"hexo","slug":"hexo","permalink":"blog.silverbeats.cn/tags/hexo/"},{"name":"排序","slug":"排序","permalink":"blog.silverbeats.cn/tags/%E6%8E%92%E5%BA%8F/"},{"name":"git","slug":"git","permalink":"blog.silverbeats.cn/tags/git/"},{"name":"github","slug":"github","permalink":"blog.silverbeats.cn/tags/github/"},{"name":"nodejs","slug":"nodejs","permalink":"blog.silverbeats.cn/tags/nodejs/"}]}