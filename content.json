{"meta":{"title":"LearnForever","subtitle":"","description":"坚持学习每一天","author":"silverbeats","url":"blog.silverbeats.cn","root":"/"},"pages":[{"title":"schedule","date":"2020-09-15T10:47:30.000Z","updated":"2020-09-15T11:38:33.448Z","comments":false,"path":"schedule/index.html","permalink":"blog.silverbeats.cn/schedule/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-09-15T10:32:54.000Z","updated":"2020-09-15T11:38:48.370Z","comments":false,"path":"categories/index.html","permalink":"blog.silverbeats.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-09-15T10:33:05.000Z","updated":"2020-09-15T11:38:04.782Z","comments":false,"path":"tags/index.html","permalink":"blog.silverbeats.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"KMP","slug":"KMP","date":"2020-09-29T05:08:18.000Z","updated":"2020-09-29T16:15:07.252Z","comments":true,"path":"KMP/","link":"","permalink":"blog.silverbeats.cn/KMP/","excerpt":"","text":"1. KMP简介 KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n) 2. KMP图解 2.1 通览(编号从0开始) 2.1.1 情况一 以上述主串和模式串为例子，可知，i指针指向主串，j指针指向模式串 当主串i位置与模式串j位置字符一样，i，j向后移动一个位置 2.1.2 情况二 易知，当i=5，j=5时，主串与模式串发生不匹配，此时需要进行的操作就是KMP的精华所在。 找到不匹配位置之前的字符串的最大公共前后缀。易知，最长公共前后缀是{A,B}，长度是2 进行如上图下半部分的操作。将字符串向后挪动，让前缀处于后缀的位置 易知，此时指针i是不需要任何变动。 挪动后，i，j所指向的位置继续比较。 字符串是不可能挪动的，实际上改变的是指针j，易知，挪动后指针j指向模式串编号为2的位置 上图，指针j经过调整后，从模式串编号2开始，继续和主串进行比较，当j指向编号6时发生不匹配，进行上述提到的步骤，经过调整得到下图情况三。 2.1.3 情况三 每次移动指针j后，需要检查主串剩余长度是否≥模式串需要匹配的长度 2.1.4 综合 根据上面提到的情况进行汇总，也就是代码实现的需要用到的步骤 当主串i位置与模式串j位置字符一样，i，j向后移动一个位置 当出现不匹配时，需要寻找不匹配位置之前的串的最大公共前后缀长度，比如长度是n，并将j移动到编号为n的位置，这里需要结合next数组，详情见[Next数组](#3. Next数组) 移动指针j后，需要检查主串剩余长度是否≥模式串需要匹配的长度，不符合条件直接break，返回匹配失败 当j的位置超过了模式串的编号，说明匹配成功，返回模式串第一个字符在主串出现的位置 2.2 通览(编号从1开始) 整个过程与上面标号从0开始的过程大体一致，只有一个区别就是：调整指针j的值，指的位置是不匹配位置之前的字符串的最大公共前后缀长度+1 3. Next数组 通过上一节内容可以知道，KMP算法核心是指向模式串的指针j的移动，该指针的如何移动实际上与主串是什么无关，只与模式串有关。只需要将模式串研究明白，则可以对任意主串进行匹配。 因为要匹配任意主串，故很容易知道，模式串的每个位置都有可能和主串出现不匹配。这时，当模式串每个位置出现不匹配时，此时的指针j应该调整到哪个位置，需要研究。 模式串第一个位置不匹配，j应该重新指向模式串的哪个位置 模式串第二个位置不匹配，j应该重新指向模式串的哪个位置 …… 将j重新指向的位置整理记录下来，存储到数组中，就是Next数组，Next数组的下标代表着该模式串出现不匹配的位置，数组下标对应的值就是j重新指向的位置。 同时需要考虑另外一个问题，这个问题在上面的内容有所体现。就是模式串起始编号是0还是1。起始编号不同，Next数组不同，二者之间相差一个位置 在进行KMP算法之前，是需要先获取模式串的Next数组，以便使用。 3.1 起始位置：0 上图提供的示例不全，但足以说明当某个位置出现不匹配时，指针j重新定位的位置为：不匹配位置之前字符串的最大公共前后缀长度所对应的编号 首先，为什么首位是-1，因为模式串首位不匹配需要挪动的是指向主串的i指针，是特殊情况，这样在获取next数组值的时候发现是-1，就知道需要挪动i指针，然而在实现时，只需要判断j时候等于0即可，并不需要访问next[0]时候等于-1。 3.2 起始位置：1 4. NextVal数组 5. 代码 5.1 Next 5.1.1 模式串从0标号 代码实现所使用到的next数组并不是[上面](#3.1 起始位置：0)提到的next数组。这里的next数组是每一位的最长公共前后缀的长度。比如next[2]=2，表示模式串前三个包括第三个字符，它们的最长公共前后缀长度是2。所以，倘若是模式串j位置出现不匹配，那么j位置之前的字符的最长公共前后缀长度是next[j-1] 关于下面getNext方法，可以理解为自己匹配自己 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 获取该模式串每个位置的最大公共前后缀长度private int[] getNext(char[] pattern) &#123; // 模式串长度 int len = pattern.length; int[] next = new int[len]; next[0] = 0; // i代表最长前后缀长度 int i = 0, j; for(j = 1; j &lt; len; j++) &#123; while(pattern[i] != pattern[j] &amp;&amp; i &gt; 0) i = next[i - 1]; if(pattern[i] == pattern[j]) next[j] = ++i; else next[j] = 0; &#125; return next;&#125;// 模式串匹配kmp算法,匹配成功返回匹配的位置,失败则返回-1public int kmp(char[] str, char[] pattern) &#123; // 这里的next数组是每个位置的最长公共前后缀的长度 // 比如next[2]表示0、1、2三个位置组成的字符串公共前后缀的最大长度 int[] next = getNext(pattern); // 主串的长度mainLen,i指向主串比较的位置,j指向模式串比较的位置 int mainLen = str.length, i = 0, j = 0; while(i &lt; mainLen) &#123; // 情况三: 主串不够长 if(mainLen - i &lt; pattern.length - j) break; // 情况一: 主串的字符与模式串字符相等 if(str[i] == pattern[j]) &#123; i++; j++; // 当j指向的位置已经超过模式串长度时,说明匹配成功,则返回模式串在主串中匹配成功的位置 if(j &gt;= pattern.length) return i - pattern.length; &#125; else &#123; // 情况二: 出现不匹配 // 如果j是模式串0位置,特殊情况 if(j == 0) &#123; // 挪动主串指针i i++; &#125; else &#123; // 重定位到不匹配位置之前字符，最大公共前后缀长度 j = next[j - 1]; &#125; &#125; &#125; // 默认失败 return -1;&#125; 同时可以发现，倘若要得到上面提到的那种next数组，只需要将里面所有的元素后移一个位置，然后首位添-1即可。上图中最后面的1会被舍弃。 5.1.2 模式串从1标号 1234567891011121314151617181920212223// 获取模式串的next数组private int[] getNext(char[] pattern) &#123; // 模式串长度 int len = pattern.length; int[] next = new int[len]; next[1] = 0; // i代表最长前后缀长度 int i = 1, j; for(j = 2; j &lt; len; j++) &#123; while(pattern[i] != pattern[j] &amp;&amp; i &gt; 1) i = next[i - 1]==0?1:next[i-1]; if(pattern[i] == pattern[j]) next[j] = i++; else next[j] = 0; &#125; // 倘若写上了这一步,下面的kmp中的最后一个else只需要写j = next[j]即可 // 倘若没有这一步,下面的kmp中的最后一个else需要写成j = next[j - 1] + 1 for(int k = next.length - 1; k &gt; 1; k--) &#123; next[k] = next[k-1] + 1; &#125; return next;&#125; 12345678910111213141516171819202122232425262728public int kmp(char[] str, char[] pattern) &#123; // 获取该模式串的next数组 int[] next = getNext2(pattern); // 主串的长度mainLen,i指向主串比较的位置,j指向模式串比较的位置 int mainLen = str.length, i = 0, j = 1; while(i &lt; mainLen) &#123; if(mainLen - i &lt; pattern.length - j) break; // 主串的字符与模式串字符相等 if(str[i] == pattern[j]) &#123; i++; j++; // 当j指向的位置已经超过模式串长度时,说明匹配成功,则返回模式串在主串中匹配成功的位置 if(j &gt;= pattern.length) return i - pattern.length + 1; // 这里有变化 &#125; else &#123; // 如果模式串在j这个位置与主串i这个位置字符不相等,则需要通过next数组来重新定位指向模式串字符的j的值 if(j == 1) &#123; i++; &#125; else &#123; // 这里有变化,倘若getNext有最后一个for循环 j = next[j]; // 倘若getNext没有最后一个for循环需要下面这种写法 // j = next[j - 1] + 1; &#125; &#125; &#125; // 默认失败 return -1;&#125; 5.2 NextVal","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"串","slug":"串","permalink":"blog.silverbeats.cn/tags/%E4%B8%B2/"},{"name":"KMP","slug":"KMP","permalink":"blog.silverbeats.cn/tags/KMP/"}],"author":"silverbeats"},{"title":"算法设计与分析——分治法","slug":"算法设计与分析-分治法","date":"2020-09-19T23:48:47.000Z","updated":"2020-09-26T06:24:52.511Z","comments":true,"path":"算法设计与分析-分治法/","link":"","permalink":"blog.silverbeats.cn/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%88%86%E6%B2%BB%E6%B3%95/","excerpt":"","text":"分治法的基本思想是将一个规模为n的问题分解为k个规模较小的子问题，这些子问题互相独立且与原问题相同。递归的解决这些子问题，然后将各个子问题的解合并得到原问题。 1. 二分搜索法 最简单的想法是从头找到尾，进行遍历，时间复杂度为O(n)，而利用分治法思想，使用二分搜索法，可以将时间复杂度缩小为O(logn)，但是该方法有一个前提就是，这一个序列必须有序。 下面代码假设序列是非递减序列 递归写法 12345678910111213141516public int binarySearch(int[] arr, int from, int to, int target) &#123; // 这说明没有数字了,说明没找到,返回-1 if(to &lt; from) return -1; // 得到from至to中间位置的数字的下标 int midPos = (to + from) &gt;&gt; 1; // 如果找到了该数字,返回数组下标 if(arr[midPos] == target) &#123; return midPos; &#125; else if(arr[midPos] &gt; target) &#123; // 如果中间的数字比目标值大,说明目标值值在中间值的左边 return binarySearch(arr, from, midPos - 1, target); &#125; else &#123; // 如果中间的数字比目标值大,说明目标值值在中间值的右边 return binarySearch(arr, midPos + 1, to, target); &#125;&#125; 非递归写法 12345678910111213141516public int binarySearch2(int[] arr, int target) &#123; // 两个指针指向target存在区域的左右边界,圈定范围 int left = 0, right = arr.length - 1; while(left &lt;= right) &#123; // 得到该范围的中间位置 int midPos = (right + left) &gt;&gt; 1; // 说明找到了 if(arr[midPos] == target) return midPos; // 如果中间值大,说明目标值在中间值左边,右边界right指针挪到midPos的前一个 else if(arr[midPos] &gt; target) right = midPos - 1; // 如果中间值大,说明目标值在中间值左边,右边界left指针挪到midPos的后一个 else left = midPos + 1; &#125; // 找不到返回-1 return -1;&#125; 2. 大整数乘法 对于乘法，直接使用乘法的运算符会很方便，但是仅限于参加运算的整数能在计算机硬件对整数的表示范围内直接处理时才是合理的。当需要处理很大的整数时，无法在计算机硬件能直接表示的整数范围内进行处理，若用浮点数表示，只能得到近似值，计算结果中的有效位数也会受到限制。 同时，当XY分3块，4块乃至更多，只会越来越慢。当分两块时，初步版需要4次，改进版需要3次相乘；而分成3块，其初步版就需要9次，想要得到比分成2块改进版的3次更少的乘法次数是不可能的，更何况是16次乘法的分4块初步版。 同时下图所示的过程有前提条件： X,Y都是n位，且n是2的整数次幂，只有这样才能保证每次划分A,B,C,D四个部分位数保持一致 （A-B），(D-C)这个两个数也需要满足上面这一条要求。因为这两个数相乘也是需要递归使用同一个函数 然而前提条件很多，实际上在使用时，上面两个条件都很难达到。当落地时，是实现初步版，计算4次乘法。 这里进行说明，为什么X可以那样表示。 比如一个十进制数1234，一共4位，按照上面的样子进行划分成左右AB两部分，则1234 = 12 * 102 + 34，这里的10其实是进制 同理，案例中，XY都是二进制，如X = 1101，X = 11 * 22 + 01，1101的十进制是13，11的十进制是3，01的十进制是1，X = 3 * 4 + 1 = 13 2.1 O(n2)写法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 因为数字很大,无法用某个整数数据类型表示,需要转换成整型数组,方便处理public int[] NumToArr(String num) &#123; num = fliter(num); char[] temp = num.toCharArray(); int[] arr = new int[temp.length]; for (int i = 0; i &lt; temp.length; i++) &#123; arr[i] = Integer.parseInt(temp[i] + &quot;&quot;); &#125; return arr;&#125;// 倘若传进来的字符串num中有0开头,比如0123,,或者00123,需要将0去掉public String fliter(String num) &#123; int pos0 = num.indexOf(&#x27;0&#x27;); if(pos0 != 0) return num; StringBuilder sb = new StringBuilder(num); while(pos0 == 0) &#123; sb.deleteCharAt(pos0); pos0 = sb.indexOf(&#x27;0&#x27; + &quot;&quot;); &#125; return sb.toString();&#125;// O(n2)的大整数乘法public String LargeIntegerMultiplication(int[] num1, int[] num2) &#123; int len1 = num1.length; int len2 = num2.length; int[] res = new int[len1 * len2]; int p = res.length - 1; for(int i = len1 - 1; i &gt;= 0; i--) &#123; for(int j = len2 - 1; j &gt;= 0; j--) &#123; res[p--] += num2[j] * num1[i]; &#125; p++; &#125; // 处理进制 for(int k = res.length - 1; k &gt;= 0; k--) &#123; if(res[k] &gt;= 10) &#123; res[k - 1] = res[k] / 10; res[k] %= 10; &#125; &#125; // 从后向前充填res数组，可能没有填满，导致前几位有0 StringBuilder sb = new StringBuilder(); // 从头向后遍历当遇到第一次非0数字后,flag为true boolean flag = false; for (int k = 0; k &lt; res.length; k++) &#123; if (res[k] != 0) flag = true; if(flag) sb.append(res[k]); &#125; return sb.toString();&#125; 2.2 分治法版本的O(n2) 2.2.1 主体 这里使用字符串，方便截取获得ABCD 123456789101112131415161718192021222324252627282930313233343536373839404142// 大整数乘法public String largeLongMultiply(String num1, String num2) &#123; // 存储num1乘num2的结果的数组 int[] res; // 只要有一个字符串数字长度为1,那么就可以直接相乘了 if (num1.length() == 1 || num2.length() == 1) &#123; // 相乘 res = mult(num1, num2); &#125; else &#123; // 因为num1和num2长度不一定相同,假设num1长度为a,num2长度为b,同样分成两部分 // num1 = A*10^(a/2) + B // num2 = C*10^(b/2) + D // num1*num2 = AC*10^(a/2+b/2) + BD + AD10^(a/2) + BC*10^(b/2) // 开始截取字符串,得到ABCD int halfNum1 = num1.length() &gt;&gt; 1; int halfNum2 = num2.length() &gt;&gt; 1; String A = num1.substring(0, halfNum1), B = num1.substring(halfNum1), C = num2.substring(0, halfNum2), D = num2.substring(halfNum2); // 开始相乘 String AC = largeLongMultiply(A, C), BD = largeLongMultiply(B, D), AD = largeLongMultiply(A, D), BC = largeLongMultiply(B, C); // 位移,相加并得到最终结果 res = arrAddArr( strNumToArr(BD), arrAddArr( arrAddArr( move(strNumToArr(AC), halfNum1 + halfNum2), move(strNumToArr(AD), halfNum1) ), move(strNumToArr(BC), halfNum2) ) ); &#125; // 处理进制 decimalism(res); // 处理首位0,并转成字符串返回 return arrToStr(filterZero(res));&#125; 2.2.2 主体之外的函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// 只有当str1或者str2的length为1时才会执行这里private int[] mult(String str1, String str2) &#123; int[] a = new int[str1.length()]; int[] b = new int[str2.length()]; // 将两个字符串变为数组,并且每个元素都是int类型 for (int i = 0; i &lt; a.length; i++) a[i] = (int) str1.charAt(i) - 48; for (int i = 0; i &lt; b.length; i++) b[i] = (int) str2.charAt(i) - 48; int[] res = new int[Math.max(a.length, b.length) + 1]; // 二者进行相乘 if (a.length == 1) &#123; for (int i = 0; i &lt; b.length; i++) res[i] = b[i] * a[0]; &#125; else &#123; for (int i = 0; i &lt; a.length; i++) res[i] = a[i] * b[0]; &#125; // 返回乘积结果 return res;&#125;// 字符串数字变数组public int[] strNumToArr(String str) &#123; int len = str.length(); int[] arr = new int[len]; for (int i = 0; i &lt; len; i++) arr[i] = (int) str.charAt(i) - 48; return arr;&#125;// 数组变字符串private String arrToStr(int[] arr) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; arr.length; i++) &#123; sb.append(arr[i]); &#125; return sb.toString();&#125;// arr数组所代表的数字扩大n位private int[] move(int[] arr, int n) &#123; int len = arr.length; int[] res = new int[len + n]; System.arraycopy(arr, 0, res, 0, len); return res;&#125;// 两个数组相加private int[] arrAddArr(int[] arr1, int[] arr2) &#123; int len1 = arr1.length, len2 = arr2.length;//123,12 // 这里还需要长度＋1是因为：900 + 900 = 1800类似这种情况 // 另外两个相加的数组的长度不一定一样 int[] res = new int[Math.max(len1, len2) + 1]; int p = res.length - 1; int dist = len1 - len2; if (dist &lt; 0) &#123; // arr1短 for (int i = len1 - 1; i &gt;= 0; i--) &#123; res[p--] = arr1[i] + arr2[i - dist]; &#125; for (int i = -dist - 1; i &gt;= 0; i--) &#123; res[p--] = arr2[i]; &#125; &#125; else if (dist &gt; 0) &#123; // arr2短 for (int i = len2 - 1; i &gt;= 0; i--) &#123; res[p--] = arr1[i + dist] + arr2[i]; &#125; for (int i = dist - 1; i &gt;= 0; i--) &#123; res[p--] = arr1[i]; &#125; &#125; else &#123; for (int i = arr1.length - 1; i &gt;= 0; i--) &#123; res[p--] = arr1[i] + arr2[i]; &#125; &#125; // 处理进制 decimalism(res); // 再次考虑,当res[0]为0的情况 return filterZero(res);&#125;// 进制处理private void decimalism(int[] arr) &#123; // 处理进制 for (int k = arr.length - 1; k &gt; 0; k--) &#123; if (arr[k] &gt;= 10) &#123; arr[k - 1] += arr[k] / 10; arr[k] %= 10; &#125; &#125;&#125;// 处理数组arr首位为0的情况private int[] filterZero(int[] arr) &#123; if (arr[0] != 0) return arr; // 从头遍历arr,当出现第一个不为0的数字后,会变成true boolean flag = false; // 用来统计非0数字前面,0的个数 int k = 0; for (int i = 0; i &lt; arr.length &amp;&amp; !flag; i++) &#123; if (arr[i] != 0) flag = true; // 倘若还没有遇到第一个不为0的数字,计数+1 if (!flag) k++; &#125; // 比如[0,0,1,2,3],经过统计k=2,那么最终的finalRes长度应该是3 = arr.length - k int[] finalRes = new int[arr.length - k]; // 开始拷贝的位置下标应该是k System.arraycopy(arr, k, finalRes, 0, finalRes.length); return finalRes;&#125; 3. Strassen矩阵乘法 矩阵乘法，线性代数常见，假设两个矩阵同型AB，都是n×n的矩阵，C = AB，则在计算矩阵C时，C中每个元素都需要进行n次乘法和n-1次加法，最终求出C，n2个元素需要的计算时间复杂度是O(n3) 3.1 O(n3)写法 12345678910111213141516171819202122// 矩阵m1,a行b列;矩阵m2,c行d列public int[][] matrixMultiply(int[][] m1, int[][] m2) &#123; // m1的行数,m1的列数 int m1Col = m1.length, m1Row = m1[0].length; // m2的行数,m2的列数 int m2Col = m1.length, m2Row = m2[0].length; // 检查矩阵相乘的条件 if (m1Row != m2Col) throw new RuntimeException(&quot;矩阵无法相乘&quot;); // 新建一个存储结果的矩阵 int[][] res = new int[m1Col][m2Row]; // 遍历m1的第i行 for(int i = 0; i &lt; m1Col; i++) &#123; // 遍历m2的第j列 for(int j = 0; j &lt; m2Row; j++) &#123; // 遍历m2的第k行 for(int k = 0; k &lt; m2Col; k++) &#123; res[i][j] += m1[i][k] * m2[k][j]; &#125; &#125; &#125; return res;&#125; 3.2 分治思想 假设条件： 两个矩阵都是n×n n都是2的幂 4. 棋盘覆盖 5. 合并排序 其实就是归并排序，相关代码可以查看排序 6. 快速排序 相关代码可以查看排序 快速排序的运行时间与每次划分是否对称有关，划分的最坏情况就是一边1个元素，另一边n-1的元素，当每次都划分对称的时候，时间复杂度是O(nlogn)，当每次划分都最坏的时候，时间复杂度是O(n2)，在排序提到，对于快速排序来说，越有序越慢，因为越有序，每次划分出现最坏情况的可能性就越大。 为了尽可能每次划分都较为对称，可以采用随机选择策略的快速排序算法。快速排序对于基准的选择都是待排序序列的第一个元素，随机选择意思就是说，在进行快速排序之前，先从序列中随机挑一个元素与序列首位进行位置交换，这样快排时的基准就是随机的了。 123456789101112131415161718192021222324252627282930313233343536// 实现随机选择基准// (int)(Math.random()*(high - low + 1))范围：[0,high - low + 1)// (int)(Math.random()*(high - low + 1)) + low范围：[low,high + 1)，即[low, high]private int RandomizedPartition(int[] arr, int low, int high) &#123; // i是从low-high随机挑选出来的下标 int i = (int)(Math.random()*(high - low + 1)) + low; // 将i位置的元素与待排序范围的首位进行交换 int temp = arr[low]; arr[low] = arr[i]; arr[i] = temp; return QSort_Partition(arr, low, high);&#125;// 快速排序public void QSort(int[] arr, int low, int high) &#123; if (low &lt; high) &#123; int piovtpos = RandomizedPartition(arr, low, high); // 排左边 QSort(arr, low, piovtpos - 1); // 排右边 QSort(arr, piovtpos + 1, high); &#125;&#125;// 一趟快速排序// 参数1：数组,参数2：数组的起始位置,参数3：数组的终了位置,闭区间private int QSort_Partition(int[] arr, int left, int right) &#123; // 指定基准 int base = arr[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; arr[right] &gt;= base) right--; if (left &lt; right) arr[left] = arr[right]; while (left &lt; right &amp;&amp; arr[left] &lt; base) left++; if (left &lt; right) arr[right] = arr[left]; &#125; arr[left] = base; return left;&#125; 7. 线性时间选择 给定一串数字，从中选出第k小，时间复杂度要求是O(n)，即线性时间选择。 7.1 利用堆排序获得第k小 易知，倘若要知道第k小的关键字，那么只需要利用小根堆，进行k次堆调整，即可得到第k小的关键字。 其中adjustHeap函数的代码可见排序，其中adjustHeap函数是调整成大根堆，只需要将循环中两个if判断条件中的小于号改成大于号，即可实现调整为小根堆的功能 123456789101112131415161718public int heapSortFindK(int[] arr, int k) &#123; // 存储arr,目的是堆排序过程中不改变原数组 int[] temp = arr.clone(); int len = temp.length; // 首先构建小根堆 for (int pos = len / 2 - 1; pos &gt;= 0; --pos) &#123; //从第一个非叶子结点从下至上，从右至左调整结构 adjustHeap(temp, pos, len); &#125; // 经过上一步可以得到小根堆,现在开始排序 for (int j = len - 1; j &gt;= len - k; --j) &#123; //将堆顶元素与末尾元素进行交换 swap(temp, 0, j); //重新对堆进行调整 adjustHeap(temp, 0, j); &#125; return temp[len - k];&#125; 7.2 利用快速排序获得第k小 每一次快排都会选则一个基准，将其排到它的最终位置，而第k小在排好序的序列中排在第k位。所以，可以通过比较每次快排后基准的最终位置与k，来获取第k小 1234567891011121314public int QSortFindK(int[] arr, int k, int start, int end) &#123; // 首先,一趟快速排序,确定一个关键字的最终位置 int piovtpos = QSort_Partition(arr, start, end); // 易知，为了使快速排序的效率变高，可以利用上述随机策略法。 // int piovtpos = RandomizedPartition(arr, start, end); if(piovtpos + 1 == k) // 倘若该数字正好是第k小 return arr[piovtpos]; else if(piovtpos + 1 &gt; k) &#123; // 说明目标在该数字的左边 return QSortFindK(arr, k, start, piovtpos - 1); else return QSortFindK(arr, k, piovtpos + 1, end);&#125; 8. 最接近点对问题 9. 循环赛日程表","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"算法设计与分析","slug":"算法/算法设计与分析","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"}],"tags":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"分治法","slug":"分治法","permalink":"blog.silverbeats.cn/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"}],"author":"silverbeats"},{"title":"最短路径","slug":"最短路径","date":"2020-09-19T01:53:19.000Z","updated":"2020-09-29T05:13:51.006Z","comments":true,"path":"最短路径/","link":"","permalink":"blog.silverbeats.cn/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/","excerpt":"","text":"1. 迪杰斯特拉Dijkstra算法详解 1.1 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public void Dijkstra(int[][] graph, int start) &#123; // 当起点无法达到该点时,路径长度是无穷大,这里用整型最大值代替 int MAXDIST = Integer.MAX_VALUE; int vertexNum = graph.length; /* * 1. Dijkstra算法需要三个辅助数组 **/ boolean[] isVisited = new boolean[vertexNum]; int[] path = new int[vertexNum]; int[] dist = new int[vertexNum]; /* * 2. 初始化 **/ for (int i = 0; i &lt; vertexNum; i++) &#123; dist[i] = graph[start][i]; if (graph[start][i] &lt; MAXDIST) &#123; path[i] = start; &#125; else &#123; path[i] = -1; &#125; &#125; // start起点默认已经被访问 isVisited[start] = true; // start没有前驱结点,因为它是开始的位置 path[start] = -1; /* * 3. 迪杰斯特拉算法核心 **/ for (int i = 0; i &lt; vertexNum - 1; i++) &#123; // 存储最短路径 int minPath = MAXDIST; // 存储距离最小的点的数组下标 // 倘若这里minIndex不赋初始值,在后面isVisited[minIndex] = true会报错 // 因为后面的循环找最小值可能找不到 int minIndex = start; // 这个循环目的是:从未访问的节点中找到路径最短的那个 for (int j = 0; j &lt; vertexNum; j++) &#123; // 倘若这个节点没有访问,并且该点小于最短路径 if (!isVisited[j] &amp;&amp; dist[j] &lt; minPath) &#123; minPath = dist[j]; minIndex = j; &#125; &#125; if (minIndex != start) isVisited[minIndex] = true; for (int j = 0; j &lt; vertexNum; j++) &#123; if (!isVisited[j] &amp;&amp; graph[minIndex][j] != MAXDIST &amp;&amp; dist[minIndex] + graph[minIndex][j] &lt; dist[j] &amp;&amp; minIndex != start) &#123; dist[j] = dist[minIndex] + graph[minIndex][j]; path[j] = minIndex; &#125; &#125; &#125;&#125; 1.2 分段解读 1.2.1 完整过程图示 1.2.2 辅助数组说明 123456789// 用来记录每个节点是否被访问boolean[] isVisited = new boolean[vertexNum];// 用来存储到达某个点最短路径的前一个节点下标// 比如上图第1次循环,到达顶点4的最短路径是0-2-4,那么path[4]存放下标2// 这个数组的每个值会不断变动int[] path = new int[vertexNum];// 存放到某个顶点的最短路径长度// 比如顶点4,dist[4]从8,最后修改成7,这个数组的每个值会不断变动int[] dist = new int[vertexNum]; 1.2.3 初始化说明 1234567891011121314151617for (int i = 0; i &lt; vertexNum; i++) &#123; dist[i] = graph[start][i]; // 这一步其实可以不用,声明boolean数组时默认就是false // isVisited[i] = false; // start点到i有路径,这里面包含了start自己到自己 // path[start]=start,这是不对的,start没有前驱节点,应该存-1,循环结束之后会做处理 if (graph[start][i] &lt; MAXDIST) &#123; path[i] = start; &#125; else &#123; // 没有前驱节点的意思,当前以start为起点,到不了i这个点 path[i] = -1; &#125;&#125;// start起点默认已经被访问isVisited[start] = true;// start没有前驱结点,因为它是开始的位置path[start] = -1; 1.2.4 算法核心说明 12345678910111213141516171819202122232425for (int i = 0; i &lt; vertexNum; i++) &#123; // 存储最短路径 int minPath = MAXDIST; // 存储距离最小的点的数组下标 // 倘若这里minIndex不赋初始值,在后面isVisited[minIndex] = true会报错 // 因为后面的循环找最小值可能找不到 int minIndex = start; // 这个循环目的是:从未访问的节点中找到路径最短的那个 for (int j = 0; j &lt; vertexNum - 1; j++) &#123; // 倘若这个节点没有访问,并且该点小于最短路径 if (!isVisited[j] &amp;&amp; dist[j] &lt; minPath) &#123; minPath = dist[j]; minIndex = j; &#125; &#125; if (minIndex != start) isVisited[minIndex] = true; for (int j = 0; j &lt; vertexNum; j++) &#123; if (!isVisited[j] &amp;&amp; graph[minIndex][j] != MAXDIST &amp;&amp; dist[minIndex] + graph[minIndex][j] &lt; dist[j] &amp;&amp; minIndex != start) &#123; dist[j] = dist[minIndex] + graph[minIndex][j]; path[j] = minIndex; &#125; &#125;&#125; 内层循环第一个for比较简单，目的是找到一个点，该点满足：①未被访问，②有路径能访问，③到达改点路径值最小 内层循环第二个详解见下图： ❥(^_-)Tip： 当你使用某个数据类型的最大值作为无穷大，表示无该路径时，需要注意dist[minIndex] + graph[minIndex][j] &lt; dist[j]，倘若graph[minIndex][j]是无穷大，再加上一个数字后，会超出该类型的表示范围，变成一个负数，从而达成这个判断条件，执行if代码块中语句。这并不是我们想要的。所以需要在if中需要添加graph[minIndex][j] != MAXDIST这句话，避免上述情况发生 1.3 思考 首先，迪杰斯特拉算法能解决单源并且没有负权值边的最短路径问题，那么倘若出现负权值边，该算法不能求解出最短路径的原因是什么 1.3.1 尝试一下 当把1-&gt;2的权值改为-3后，继续走一遍之前的代码，就可以发现问题。 当i = 1时，即第二次循环，此时的minIndex为1，当j = 2时，根据if条件，因为isVisited[2]是之前访问过的点，所以不会执行if语句块中的代码，即便dist[minIndex] + graph[minIndex][j] &lt; dist[j]，5 + (-3) &lt; 3 那么倘若if中没有!isVisited[j]这个判断是否就可以了呢？ 根据上图，可以看到path数组是没有问题的，但是问题出在了dist[4]上。dist[4]应该为6，但却是7，这里是因为什么原因导致的？ 手动模拟一遍过程后不难发现，i=0的第一次循环修改了dist[4]和path[4]；在i=1的第二次循环，到达节点2的最短路径发生变化，但是没有任何的机会去修改以2为前驱的点的dist数组。 所以在第二个for循环中再添加一个循环，倘若某个点x的最短路径发生变化，去找以x为前驱的其他点y，看看y这个点的最短路径有没有因为x的变化而缩短。 12345678910111213for (int j = 0; j &lt; vertexNum; j++) &#123; if (graph[minIndex][j] != MAXDIST &amp;&amp; dist[minIndex] + graph[minIndex][j] &lt; dist[j] &amp;&amp; minIndex != start) &#123; dist[j] = dist[minIndex] + graph[minIndex][j]; path[j] = minIndex; // 在遍历一遍path数组 for(int k = 0; k &lt; vertexNum; k++) &#123; // 如果path数组的某个点的前驱节点正好是修改长度的点的话 if(path[k] == j &amp;&amp; dist[k] &gt; dist[j] + graph[j][k]) &#123; dist[k] = dist[j] + graph[j][k]; &#125; &#125; &#125;&#125; 之后的结果就没有问题了： 2. 弗洛伊德Floyd算法详解 其实倘若涉及到负权值，会选择用Floyd算法，而且，更为强大的是，Floyd能够求出各个顶点到其他点的最短距离。 我不能呼吸了……= = 2.1 完整代码 123456789101112131415161718public void Floyd(int[][] graph) &#123; int vertexNum = graph.length; // path数组,用来存储路径 int[][] path = new int[vertexNum][vertexNum]; // 初始化 for (int i = 0; i &lt; vertexNum; i++) &#123; for(int j = 0; j &lt; vertexNum; j++) path[i][j] = -1; &#125; for(int i = 0; i &lt; vertexNum; i++) &#123; for(int j = 0; j &lt; vertexNum; j++) &#123; for(int k = 0; k &lt; vertexNum; k++) &#123; if(graph[j][i] == Integer.MAX_VALUE || graph[i][k] == Integer.MAX_VALUE) continue; int temp = graph[j][i] + graph[i][k]; if(graph[j][k] &gt; temp) graph[j][k] = temp; &#125; &#125; &#125;&#125; 举例：顶点0到4的最短路径 graph(0,4)的数字是6，说明最短路径长度是6，那么该怎么走呢。这是需要看path数组 path(0,4)为2，说明想要到顶点4需要经过顶点2，路径0-&gt;2-&gt;4，此时再看path(0,2)为1，说明想要从0到2需要经过顶点1，路径变为0-&gt;1-&gt;2-&gt;4 关于代码的详细描述过程，见文章：Floyd-傻子也能看懂的弗洛伊德算法（转）","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"最短路径","slug":"最短路径","permalink":"blog.silverbeats.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"blog.silverbeats.cn/tags/Dijkstra/"},{"name":"Floyd","slug":"Floyd","permalink":"blog.silverbeats.cn/tags/Floyd/"}],"author":"silverbeats"},{"title":"hexo相关命令语法","slug":"hexo相关命令语法","date":"2020-09-17T04:44:15.000Z","updated":"2020-09-20T00:03:02.202Z","comments":true,"path":"hexo相关命令语法/","link":"","permalink":"blog.silverbeats.cn/hexo%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E8%AF%AD%E6%B3%95/","excerpt":"","text":"1. 相关命令 12345678910111213141516171819202122232425#初始化一个hexo博客hexo init blog#创建新页面hexo new page 页面名#清理之前生成的旧文件hexo clean#重新生成静态文件 下面是简写hexo generatehexo g#本地预览 下面是简写hexo serverhexo s#合并写法hexo clean | hexo g | hexo s#通过git提交到仓库,需要配置hexo项目的_config.yml文件hexo deployhexo d#当安装七牛云同步插件后,可以通过如下命令将hexo根目录下的static文件夹同步到七牛云hexo qiniu sync#或者hexo qiniu s#或者hexo qiniu sync2#或者hexo qiniu s2 2. 引用站内文章 1&#123;% post_link 文章文件名（不要后缀） 文章标题（可选） %&#125; 3. 引用图片 3.1 引用七牛云图片 1&#123;% qnimg 图片.格式 alt:这是图片 title:这是图片 %&#125; 不过这种方式引用图片，还是相当于本地存储，之后引用的图片会出现在需要上传的public目录中，还是会占用空间。 3.2 引用本地图片 倘若hexo项目的配置文件中将post_asset_folder设置为true，可以通过以下方式来引入图片，需要将example放入source/_post下的文章同名文件夹下。 1234&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125;&#123;% asset_img example.jpg This is an example image %&#125;","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"blog.silverbeats.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"blog.silverbeats.cn/tags/hexo/"}],"author":"silverbeats"},{"title":"排序","slug":"排序","date":"2020-09-16T14:17:31.000Z","updated":"2020-09-29T05:14:55.462Z","comments":true,"path":"排序/","link":"","permalink":"blog.silverbeats.cn/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"1. 插入排序 1.1 直接插入排序 直接插入排序，思想较为简单。 可以类比平常打扑克抓牌的过程。每次抓一张牌时，都会将这张牌与之前手里的牌（之前手里的牌是有序的）进行比较（从左向右比，或者从右向左比），得到一个最终的插入位置，然后插入。 12345678910111213141516171819// 直接插入排序, 假定前面是有序的，从乱序的后面取一个数插入有序的前面public void insertSort(int[] arr) &#123; int len = arr.length; if (len == 0 || len == 1) return; // 进行插入排序 for (int i = 1; i &lt; len; i++) &#123; for (int j = i; j &gt; 0; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; swap(arr, j, j - 1); &#125; &#125; &#125;&#125;// 交换private void swap(int[] arr, int a, int b) &#123; int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp;&#125; 上面的代码可以再简化一下： 12345678910// 直接插入排序, 假定前面是有序的，从乱序的后面取一个数插入有序的前面public void insertSort(int[] arr) &#123; int len = arr.length; if (len == 0 || len == 1) return; // 进行插入排序 for (int i = 1; i &lt; len; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j - 1]; j--) swap(arr, j, j - 1); &#125;&#125; 1.2 折半插入排序 直接插入排序确定位置是通过将待排序的元素，与前面有序的序列一个个比较过去，从而得到最终的插入位置。那么，因为是顺序存储，利用数组实现排序，可以对前面的有序序列使用折半查找来确定最终插入位置。 12345678910111213141516171819202122232425public void binaryInsertSort(int[] arr) &#123; int len = arr.length; if (len == 0 || len == 1) return; // low high mid用于折半查找 int low, high, mid; for (int i = 1; i &lt; arr.length; i++) &#123; low = 0; high = i - 1; while (low &lt;= high) &#123; // (high+low)/2 这样的写法可能会超出int的表示范围 mid = low + ((high - low) &gt;&gt; 1); if (arr[mid] &lt; arr[i]) low = mid + 1; else high = mid - 1; &#125; // high + 1就是插入的位置 int temp = arr[i]; // 找到插入位置后,对元素进行挪动 for (int j = i - 1; j &gt; high; j--) arr[j + 1] = arr[j]; // 将待排序的元素插入找到的位置 arr[high + 1] = temp; &#125;&#125; 1.3 希尔排序 希尔排序又称为缩小增量排序，当增量为1时，其实就是直接插入排序。增量的选取一般两种方案： 希尔提出，对数组长度不断折半。比如数组长度是32，则增量dk分别是：16,8,4,2,1 帕佩尔诺夫和斯塔舍维奇提出，dk = 2k + 1，dk &lt; 数组长度，k ≥ 0。比如数组长度是32，此时k 只能从4开始，则k = 4，dk = 17；k = 3，dk = 9；k = 2，dk = 5；k = 1，dk = 3；此时还需要额外添加dk = 1，算是一个兜底作用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 希尔排序public int[] shellSort(int[] arr) &#123; int len = arr.length; if (len == 0 || len == 1) return arr; int dk = len &gt;&gt; 1; while (dk != 0) &#123; shell_InsertSort(arr, dk); // shell_BinaryInsertSort(arr, dk); dk = dk &gt;&gt; 1; &#125; return arr;&#125;/** * @Title: shell_InsertSort * @Description: 希尔排序，直接插入法进行排序 * @param ar: 数组 * @param dk: 间隔 * @return: void */private void shell_InsertSort(int[] arr, int dk) &#123; int len = arr.length; int i, j; for (i = dk; i &lt; len; i++) &#123; int temp = arr[i]; for (j = i - dk; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= dk) &#123; arr[j + dk] = arr[j]; arr[j] = temp; &#125; &#125;&#125;/** * @Title: shell_BinaryInsertSort * @Description: 希尔排序，折半插入法进行排序 * @param arr: 数组 * @param dk: 间隔 * @return: void */private void shell_BinaryInsertSort(int[] arr, int dk) &#123; int i, j, high, low, mid, temp; for (i = dk; i &lt; arr.length; i++) &#123; low = i % dk; high = i - dk; while (low &lt;= high) &#123; mid = low + (high - low) / 2; if (arr[mid] &lt; arr[i]) low = mid + dk; else high = mid - dk; &#125; temp = arr[i]; // high + dk 即为插入的位置 for (j = i - dk; j &gt; high; j -= dk) arr[j + dk] = arr[j]; arr[high + dk] = temp; &#125;&#125; 后面那个通过折半插入法进行排序纯属练手，效率远远不及直接插入法希尔排序 前者，规模1W，20次，19ms 前者，规模10W，20次，187ms 后者，规模1W，20次，129ms 后者，规模10W，20次，10761ms 估计是在dk较小的时候，序列基本有序，折半插入的话是不管有没有序都得比较那么多次，而直接插入是越有序越快。 2. 选择排序 2.1 堆排序 堆又分大根堆和小根堆，倘若要升序，选择大根堆，倘若要降序，选择小根堆。 大根堆：根节点的数字不小于左右孩子的值 小根堆：根节点的值不大于左右孩子的值 堆排序是把一个数组，看做是一颗完全二叉树，排序步骤： 先对乱序的数组建立大根堆，可以得到数组的第一个元素（看做完全二叉树的话就是根节点）就是最大的 将其与数组最后面的那个值交换，然后重新调整，变为大根堆 依次类推 1234567891011121314151617181920212223242526272829303132333435363738394041// 堆排序public void heapSort(int[] arr) &#123; // 首先构建大根堆 for(int pos = arr.length/2 - 1; pos &gt;= 0; --pos) &#123; //从第一个非叶子结点从下至上，从右至左调整结构 adjustHeap(arr, pos, arr.length); &#125; // 经过上一步可以得到大根堆,现在开始排序 for(int j = arr.length - 1; j &gt; 0; --j) &#123; //将堆顶元素与末尾元素进行交换 swap(arr,0, j); //重新对堆进行调整 adjustHeap(arr,0, j); &#125;&#125;// 调整为大根堆// arr是要调整的数组, i是要调整的数组下标, length是调整的范围private void adjustHeap(int[] arr, int pos, int length) &#123; // 临时存储被调整的数组数据 int temp = arr[pos]; // pos是被调整元素的数组下标, 2*pos+1 是其左孩子 2*pos + 2是其右孩子 for(int i = pos*2 + 1; i &lt; length; i = i*2 + 1) &#123; /* 前面的判断条件保证它的右孩子是无序的, 在堆排序过程中会将最大值不断放到后面, length就是限制条件,可以通过这个条件让有序的右孩子不被波及 这个if保证i的下标对应的值是两个孩子中最大的那一个 */ if(i + 1 &lt; length &amp;&amp; arr[i] &lt; arr[i + 1]) &#123; i++; &#125; // 如果根节点小于它的孩子,则交换 if(temp &lt; arr[i]) &#123; // 交换根节点和它孩子的值 swap(arr, pos, i); // 因为经过了调整,当被调整的节点挪了位置,可能会导致后面的序列出问题,所以需要让pos定到i这个位置 pos = i; &#125; else &#123; break; &#125; &#125;&#125; 2.2 简单选择排序 思路简单：每次选择最大排到后面，或者每次选择最小的排到最前面 123456789101112public void selectSort(int[] arr) &#123; // 每次过滤一遍数组将最小值放到前面 int i, j, min; for (i = 0; i &lt; arr.length - 1; i++) &#123; min = i; // 假定第i个位置最小 for (j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) min = j; &#125; if (i != min) swap(arr, i, min); &#125;&#125; 下面是另外一种做法，是每次将最小的放到最前面，最大的放到最后面 12345678910111213141516171819public void selectSort_2(int[] arr) &#123; // 每次过滤一遍数组将最小值放到前面 // 将最大的数字放到最后面 int i, j, min, max, lastPos; for (i = 0; i &lt;= arr.length &gt;&gt; 1; i++) &#123; min = max = i; lastPos = arr.length - i - 1; for (j = i + 1; j &lt;= lastPos; j++) &#123; if (arr[j] &lt; arr[min]) min = j; if (arr[j] &gt; arr[max]) max = j; &#125; if (i != min) swap(arr, i, min); if (lastPos != max) swap(arr, max, lastPos); &#125;&#125; 前者，规模10W，20次，54408ms，2720ms/次 后者，规模10W，20次，53938ms，2697ms/次 呵呵…… 简单选择排序有两个版本，一种是如同上面的两种写法一样，将最大值（最小值）与序列最后（第一）个进行调换位置，这个版本成为交换版 另一种版本是将最大值（最小值）插入到序列的最后（最前）面，成为插入版。 区别在于： 交换版不稳定，插入版稳定 倘若序列顺序存储，插入版会涉及到大批量的元素挪动，不如交换版来的划算 倘若序列是链式存储，插入版会划算一些 3. 交换排序 3.1 冒泡排序 冒泡排序很经典，每次排序都能讲最大的数字排到最后，或者将最小的数字排到最前面 听说冒泡是毒瘤，比较次数和交换次数超级多 12345678910111213141516public int[] bubbleSort(int[] arr) &#123; int len = arr.length; if (len == 0 || len == 1) return arr; for (int i = 0; i &lt; len; i++) &#123; // 倘若内循环没有进行交换,则整个序列有序,会直接终止整个排序,是一个优化的地方 boolean flag = false; for (int j = 0; j &lt; len - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; swap(arr, j, j + 1); flag = true; &#125; &#125; if (!flag) break; &#125; return arr;&#125; 继续发挥，双向冒泡 1234567891011121314151617181920212223242526// 双向冒泡public void bubble2Ways(int[] arr) &#123; int left = 0, right = arr.length - 1; boolean flag; while(left &lt; right) &#123; flag = false; // 从左往右将最大的数字挪到最右边 for(int i = left; i &lt; right; ++i) &#123; if(arr[i] &gt; arr[i + 1])&#123; swap(arr, i, i + 1); flag = true; &#125; &#125; // 挪到结束后right-- --right; // 从右往左将最小的数字挪到最左边 for(int j = right; j &gt; 0; --j) &#123; if(arr[j] &lt; arr[j - 1])&#123; swap(arr, j, j - 1); flag = true; &#125; &#125; ++left; if(!flag)break; &#125;&#125; 前者，规模1W，20次，1362ms，68ms/次 后者，规模1W，20次，1445ms，72ms/次 前者，规模10W，20次，303042ms，5min，15152ms/次 后者，规模10W，20次，202945ms，3min23s，10147ms/次 ……还是有点提高的 3.2 快速排序 利用分而治之的思想。每一次快速排序会实现这样的结果： 该数字的左边都比它小 该数字的右边都不小于它 每一次排序都会确定一个数的最终位置 123456789101112131415161718192021222324// 快速排序public void QSort(int[] arr, int low, int high) &#123; if (low &lt; high) &#123; int piovtpos = this.QSort_Partition(arr, low, high); // 排左边 QSort(arr, low, piovtpos - 1); // 排右边 QSort(arr, piovtpos + 1, high); &#125;&#125;// 一趟快速排序// 参数1：数组,参数2：数组的起始位置,参数3：数组的终了位置,闭区间private int QSort_Partition(int[] arr, int left, int right) &#123; // 指定基准 int base = arr[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; arr[right] &gt;= base) right--; if (left &lt; right) arr[left] = arr[right]; while (left &lt; right &amp;&amp; arr[left] &lt; base) left++; if (left &lt; right) arr[right] = arr[left]; &#125; arr[left] = base; return left;&#125; 平均时间复杂度为nlogn的算法中，如：堆排序，快速排序，希尔排序，归并排序中，快速排序前面系数最小 规模1W，20次，15ms 规模10W，20次，359ms 快速排序有其特点：越有序越慢，越无序越快 4. 二路归并排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @Title: mergeSort * @Description: 归并排序 * @param arr: int类型数组 * @return: void */public void mergeSort(int[] arr, int leftStart, int rightBound) &#123; if(leftStart == rightBound)return; if(leftStart &gt; rightBound || leftStart &lt; 0 || rightBound &lt; 0)throw new RuntimeException(&quot;error&quot;); int mid = leftStart + ((rightBound - leftStart) &gt;&gt; 1); mergeSort(arr,leftStart,mid); mergeSort(arr,mid+1,rightBound); merge(arr, leftStart, mid+1, rightBound);&#125;/** * @Title: merge * @Description:一次归并,将两个有序的数组合并，仍有序 * @param arr 数组 * @param leftStart 第一个数组的左边界开始的位置 * @param rightStart 第二个数组的左边界开始的位置 * @param rightBound 第二个数组的右边界结束的位置 * @return: void */private void merge(int[] arr, int leftStart, int rightStart, int rightBound) &#123; // 合并思想：新建一个数组，每次将小的数字放到新建的数组中 int i = leftStart, j = rightStart, k = 0; int[] tempArr = new int[rightBound - leftStart + 1]; while(i &lt; rightStart &amp;&amp; j&lt;= rightBound) tempArr[k++] = arr[i] &lt;= arr[j]?arr[i++]:arr[j++]; // 倘若还有剩余 while(i &lt; rightStart) tempArr[k++] = arr[i++]; while(j &lt;= rightBound) tempArr[k++] = arr[j++]; // 此时tempArr就是合并好有序的数组，对原始数组进行覆盖 for(int p = leftStart; p &lt;= rightBound; p++) arr[p] = tempArr[p - leftStart]; // 对原数组进行覆盖可以使用System.arraycopy,可以提高效率 /* if (i &lt; rightStart) &#123; System.arraycopy(arr, i, tempArr, k, rightStart - i); k += (rightStart - i); &#125; if (j &lt;= rightBound) &#123; System.arraycopy(arr, j, tempArr, k, rightBound - j + 1); &#125; System.arraycopy(tempArr, 0, arr, leftStart, tempArr.length); */&#125; 规模1W，20次，32ms 规模10W，20次，241ms 5. 桶排序 5.1 基数排序 5.1.1 完整代码（只适用于非负数） 1234567891011121314151617181920212223242526272829303132// 基数排序public void radixSort(int[] arr) &#123; int len = arr.length; int arrMax = getMinMax(arr)[1]; // 从个位开始,对数组进行排序 // exp = 1, 按照个位 // exp = 10, 按照十位 // exp = 100, 按照百位 for (int exp = 1; arrMax / exp &gt; 0; exp *= 10) &#123; int i; // 存储被排序数组的临时数组 int[] output = new int[arr.length]; // 桶,因为不管是什么数字,个数十位不管是哪一位,都是0-9，所以桶数组的长度是10 int[] buckets = new int[10]; // 将数据出现的次数进行统计 for (i = 0; i &lt; len; i++) &#123; buckets[(arr[i] / exp) % 10]++; &#125; // 转为累加数组。目的是让更改后的buckets[i]的值，是该数据在output中的位置 for (i = 1; i &lt; 10; i++) &#123; buckets[i] += buckets[i - 1]; &#125; // 将数据存储到临时数组output中 for (i = len - 1; i &gt;= 0; i--) &#123; output[buckets[(arr[i] / exp) % 10] - 1] = arr[i]; buckets[(arr[i] / exp) % 10]--; &#125; // 将排序好的数组赋值给arr for (i = 0; i &lt; len; i++) arr[i] = output[i]; &#125;&#125; 5.1.2 分段说明 分段说明举例说明的乱序数组为：{53, 3, 542, 748, 14, 214, 154, 63, 616}，为了更好的说明过程，for循环的说明将会以个位排序，演示整个过程 5.1.2.1 外层循环 arrMax是整个数组中最大的数字，同时也是位数最多的那个数字，比如arrMax是748，那么需要进行3次循环，分别对整个数组的个位，十位，百位来进行排序，故，外层循环的次数是由arrMax的位数来决定的。 123for (int exp = 1; arrMax / exp &gt; 0; exp *= 10) &#123; …… &#125; exp = 1，arrMax = 748/1 = 748&gt; 0，对个位进行排序 exp = 10，arrMax = 748/10 = 74 &gt; 0，对十位进行排序 exp = 100，arrMax = 748/100 = 8 &gt; 0，对百位进行排序 exp = 1000，arrMax = 748/1000 = 0 &gt; 0，false，中止外层循环 5.1.2.2 内部循环两个辅助数组的作用 首先，先来看一下，我们熟知的基数排序的过程： 很清楚能知道，其中一个辅助数组为buckets长度为10，即为上面的桶。但问题是，模拟的时候，是将每个数字放入桶中，然后取出的顺序是放入的先后顺序一致，颇有一种每个桶里面放的都是一个队列，先进先出，这样想倒是很符合，很自然，可以声明一个Object[]数组，之后每个位置存储一个队列，队列不需要自己实现，可以使用java.util包下的Queue实现类，之后操作就比较简单了，完全就和手动模拟的过程是一致的。（倘若用C语言，这样想能恶心死你= =） 但上面这种考虑虽然简单，但空间复杂度肯定是小不了的，这里给出的是另外一种比较巧妙的解决方案。可见后面更为详细的过程图。 1234// 存储被排序数组的临时数组int[] output = new int[arr.length];// 桶,因为不管是什么数字,个数十位不管是哪一位,都是0-9，所以桶数组的长度是10int[] buckets = new int[10]; 5.1.2.3 内部四for第一for: 将数据出现的次数进行统计 (arr[i]/exp)%10的目的是要获得目标位置的数字。 首先，将需要的那一位变为个位，比如214，想要取得十位1，此时的exp = 10，先要除exp，得到21，这样想要的十位数字1就挪到了个位，之后让21 % 10，即可得到想要的十位数字1 这里的for循环其实目的是统计每个数字的exp位（exp = 1 表示每个数字的个位，exp = 10 表示每个数字的十位……）出现的次数。 123for (i = 0; i &lt; len; i++) &#123; buckets[(arr[i] / exp) % 10]++;&#125; 以个排序演示完整过程，出现次数：为待排序数组，每个数字的个位出现的次数 5.1.2.4 内部四for第二for: 转为累加数组 1234// 转为累加数组。目的是让更改后的buckets[i]的值，是该数据在output中的位置for (i = 1; i &lt; 10; i++) &#123; buckets[i] += buckets[i - 1];&#125; 这个累加数组中的值，就代表了每个数字最终应该存储的位置。比如53这个数字，当按照个位排完序，应该在哪里？ 首先，我们应该能想到应该要遍历待排序数组，然后按照某种规则放入用来临时存储的output数组中。那么问题来了，应该正向遍历，还是逆向遍历？ 假设是正向遍历，遍历到每个数字都需要考虑一些问题： 有多少个数字在我前面 和我拥有相同的个位，有多少个，还有多少个没有被安排进临时数组 比如，第一个数字53，首先，获取53的个位数字3，对应到buckets数组中发现buckets[3] = 4，说明最后一个个位为3的数字应该排在第四个。通过buckets[2] = 1，说明能排在个位3前面的数字只有1个，能推出，在最后的排序结果中，以3为个位的数字应该排在序列的第2,3,4位置。问题来了，如何确定到底是那个位置，同时还要保证相同个位的数字之间相对位置不变。 假设是逆序，它天然就能保证在最终结果序列中，相同个位之间相对顺序不变。比如063。 buckets[3] = 4，让063排第4位，buckets[3] = 3 buckets[3] = 3，让003排第3位，buckets[3] = 2 buckets[2] = 2，让053排第2位，buckets[3] = 1 这个逻辑写起来就会很轻松。 5.1.2.5 内部四for第三for: 将数据存储到临时数组output中 这里是整个排序中最不好懂的一部分。但是当你看到上面的说明，这里就会比较容易去理解。为了方便理解，将源代码中的两行代码拆分。 12345678910111213 // 将数据存储到临时数组output中for (i = len - 1; i &gt;= 0; i--) &#123; // 获取这个数字的exp位 int pos = (arr[i] / exp) % 10; // 对应到buckets数组 int b = buckets[pos]; // 数组下标从0开始,需要减1,才是arr[i]应该存储的地方 output[--b] = arr[i]; // 让桶的数字自减 buckets[pos]--; //output[buckets[(arr[i] / exp) % 10] - 1] = arr[i]; //buckets[(arr[i] / exp) % 10]--;&#125; 第1次：616，获取个位6，buckets[6] = 8，需要减1才是存放处，output[8 - 1] = 616，桶的数字减1，buckets[6] = 7 第2次：063，获取个位3，buckets[3] = 4，需要减1才是存放处，output[4 - 1] = 063，桶的数字减1，buckets[3] = 3 第3次：154，获取个位4，buckets[4] = 7，需要减1才是存放处，output[7 - 1] = 154，桶的数字减1，buckets[4] = 6 第4次：214，获取个位4，buckets[4] = 6，需要减1才是存放处，output[6 - 1] = 124，桶的数字减1，buckets[4] = 5 第5次：014，获取个位4，buckets[4] = 5，需要减1才是存放处，output[5 - 1] = 014，桶的数字减1，buckets[4] = 4 第6次：748，获取个位8，buckets[8] = 9，需要减1才是存放处，output[9 - 1] = 748，桶的数字减1，buckets[8] = 8 第7次：542，获取个位2，buckets[2] = 1，需要减1才是存放处，output[1 - 1] = 542，桶的数字减1，buckets[2] = 0 第8次：003，获取个位3，buckets[3] = 3，需要减1才是存放处，output[3 - 1] = 003，桶的数字减1，buckets[3] = 2 第9次：053，获取个位3，buckets[3] = 2，需要减1才是存放处，output[2 - 1] = 053，桶的数字减1，buckets[3] = 1 5.1.3 完整代码（适用于负数） 1234567891011121314151617181920212223242526272829303132public void radixSort(int[] arr) &#123; int len = arr.length; if(len == 1 ||len == 0) return; int[] temp = getMinMax(arr); // 应该是位数最多的那一个 int arrMax = Math.max(Math.abs(temp[0]), Math.abs(temp[1])); for (int exp = 1; arrMax / exp != 0; exp *= 10) &#123; int i; // 存储被排序数组的临时数组 int[] output = new int[len]; // 桶,因为要考虑负数,桶编号从-9~9,，所以桶数组的长度是19 int[] buckets = new int[19]; // 将数据出现的次数进行统计,其中buckets数组下标0-8代表-9~-1,下标9代表0,10-18代表1-9 for (i = 0; i &lt; len; i++) &#123; //获取这一位 int bit = arr[i]/exp % 10; buckets[bit + 9]++; &#125; // 转为累加数组。目的是让更改后的buckets[i]的值，是该数据在output中的位置 for (i = 1; i &lt; buckets.length; i++) &#123; buckets[i] += buckets[i - 1]; &#125; // 将数据存储到临时数组output中 for (i = len - 1; i &gt;= 0; i--) &#123; output[buckets[(arr[i] / exp) % 10 + 9] - 1] = arr[i]; buckets[(arr[i] / exp) % 10 + 9]--; &#125; // 将排序好的数组赋值给arr for (i = 0; i &lt; len; i++) arr[i] = output[i]; &#125;&#125; 首先和上面不包含负数的基数排序相比，变动的地方如下： arrMax 12int[] temp = getMinMax(arr);int arrMax = Math.max(Math.abs(temp[0]), Math.abs(temp[1])); 实际上，arrMax的意义其实没有变化，都指的是这一串数字当中位数最多的那个数字，至于是正的还是负的，这无所谓，只要它位数最多。 所以，倘若这串数字包含负数，在获取位数最多的那个数字，可以这样获取。 其中getMinMax是获取arr中的最小值和最大值，返回值{min，max} 桶数组大小变动 12345678910111213int[] buckets = new int[19];// 将数据出现的次数进行统计,其中buckets数组下标0-8代表-9~-1,下标9代表0,10-18代表1-9for (i = 0; i &lt; len; i++) &#123; //获取这一位 int bit = arr[i]/exp % 10; buckets[bit + 9]++;&#125;……// 将数据存储到临时数组output中for (i = len - 1; i &gt;= 0; i--) &#123; output[buckets[(arr[i] / exp) % 10 + 9] - 1] = arr[i]; buckets[(arr[i] / exp) % 10 + 9]--;&#125; 因为要考虑到负数，应该有：-9，-8，-7，-6，……，0，1，2，……，9共计19个桶 因为数组下标是从0开始的，所以在第一个计数的for循环，当在得到该数字的某一位时，需要+9 同时在第三个for循环，在获取某个桶的值的时候，也需要+9 5.2 计数排序 利用桶，空间换时间，在面对在一定范围内的大量重复数字的场景下，很适用。 比如一个省的高考成绩排名，可以声明一个长度为751的计数数组，其数组下标为0-750，代表每个分数。之后遍历整个省的所有人，统计每个分数的出现的次数，然后再遍历计数数组，即可实现有序。 1234567891011121314151617181920212223242526/** * @Title: countSort * @Description:计数排序,适用于数字的范围小，排序量大的数组 * @param arr 数组 * @param min 该数组中的最小值 * @param max 该数组中的最大值 * @return: int[] */public void countSort(int[] arr, int min, int max) &#123; // arr的最小值到最大值之间的数字，即为countArr的下标 int[] countArr = new int[max - min + 1]; // 统计arr中每个数字出现的次数 for (int j = 0; j &lt; arr.length; j++) countArr[arr[j] - min]++; int[] res = new int[arr.length]; // 将countArr变为累加数组,这一步主要是实现算法稳定 for (int m = 1; m &lt; countArr.length; m++) countArr[m] += countArr[m - 1]; // 这一步参见基数排序的过程示意图 for(int k = arr.length - 1; k &gt;= 0; k--) res[--countArr[arr[k] - min]] = arr[k]; // 将排序好的数组赋值给arr for(int i = 0; i &lt; arr.length; i++) &#123; arr[i] = res[i]; &#125;&#125; 6. 排序比较 排序 英文 平均 最坏 最好 空间 稳定性 插入排序 Insertion n2 n2 n 1 稳 折半插入 n2 n2 nlog2n 1 稳 希尔排序 Shell n1.3 n2 n 1 不稳 堆排序 Heap nlog2n nlog2n nlog2n 1 不稳 选择排序 Selection n2 n2 n2 1 不稳 冒泡排序 Bubble n2 n2 n 1 稳 快速排序 Quick nlog2n n2 nlog2n log2n 不稳 归并排序 Merge nlog2n nlog2n nlog2n n 稳 桶排序 Bucket n+k n2 n n+k 稳 计数排序 Counting n+k n+k n+k n+k 稳 基数排序 Radix n*k n*k n*k n+k 稳 经过一趟排序能够使某个关键字到达最终位置的排序：交换类排序（冒泡，快速排序）、选择类排序（简单选择，堆排序） 排序算法的关键字比较次数和原始序列无关：简单选择排序和折半插入排序 排序算法的排序趟数和原始序列有关：交换类排序（冒泡，快速排序）","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"排序","slug":"排序","permalink":"blog.silverbeats.cn/tags/%E6%8E%92%E5%BA%8F/"}],"author":"silverbeats"},{"title":"hexo之yelee主题配置","slug":"hexo之yelee主题配置","date":"2020-09-13T11:53:59.000Z","updated":"2020-09-21T23:28:58.841Z","comments":true,"path":"hexo之yelee主题配置/","link":"","permalink":"blog.silverbeats.cn/hexo%E4%B9%8Byelee%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/","excerpt":"","text":"参考文章： 使用Github搭建Hexo技术博客托管在GitHub Pages上–安装教程 博客系统hexo yelee搭建历程 hexo在文章中添加图片 Hexo七牛插件安装与使用 hexo相关命令语法 1. 前期准备 github账号、安装git nodejs notepad++或者editplus，记事本也可以 typora（后期写md格式文章用的软件） 可选内容 修改node.js源 123456// 设置 淘宝镜像源npm config set registry https://registry.npm.taobao.org// 查看使用的镜像源npm config get registry// 安装淘宝镜像源npm install -g cnpm --registry=https://registry.npm.taobao.org 2. 实操 2.1 安装Hexo框架 123npm install -g hexo-cli// 或者cnpm install -g hexo-cli 2.2 创建Hexo项目 在本地，选择要创建项目的目录 打开Git Bash（或者cmd命令行，或者powershell），并进入该目录 输入并运行hexo init blog之后，会在当前目录下创建blog文件夹，并初始化相关文件 cd blog进入创建的项目，运行npm install下载相关依赖包 2.3 相关命令 12345678910111213#清理之前生成的旧文件hexo clean#重新生成静态文件 下面是简写hexo generatehexo g#本地预览 下面是简写hexo serverhexo s#合并写法hexo clean | hexo g | hexo s#通过git提交到仓库,需要配置,见后文hexo deployhexo d 2.4 下载yelee主题 在当前目录下，输入命令git clone https://github.com/MOxFIVE/hexo-theme-yelee themes/yelee，倘若下载速度是龟速，不如直接用迅雷下zip压缩包来的快…… Hexo主题压缩包，百度云，密码abcd 下载完成之后，需要修改项目目录下的_config.yml文件，找到theme主题字样，将后面的默认主题landscape修改为yelee。倘若之后想要更换主题也是如此。 2.5 修改_config.yml文件 2.5.1 首页不显示文章列表 启动后会发现左侧导航栏，点击主页后不显示文章列表 进入yelee模板页的 _config.yml 12345search: on: true onload: true ## true: get search.xml file when the page has loaded ## false: get the file when search box gets focus 2.5.2 相关链接无法跳转 在themes/yelee/_config.yml中类似如下的内容。实际上当预览的时候会发现有相关的链接没有配置路由。 12345678## About Page: `hexo new page about`## Tags Cloud Page: `hexo new page tags`menu: 主页: / 所有文章: /archives/ 随笔: /note/ 标签云: /tags/ 关于我: /about/ 因为随笔、标签云、关于我这种链接，在此项目中是没有的，需要去创建。留意上方注释，已经说明如何创建。 1234#在项目根目录下操作, 根据需要创建系统页hexo new page tagshexo new page abouthexo new page categories 2.5.3 添加文章的字数统计和大概看完的时间 12#项目根路径下操作npm i --save hexo-wordcount 文件配置： 在yelee/layout/_partial/post/word.ejs下创建word.ejs文件： 123456789101112131415161718&lt;!--倘若出现tag标签和统计字数的文件有布局上的问题，可以对上下外边距进行调整--&gt;&lt;div style&#x3D;&quot;margin-top:10px;margin-bottom: 30px&quot;&gt; &lt;span class&#x3D;&quot;post-time&quot;&gt; &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt; &lt;i class&#x3D;&quot;fa fa-keyboard-o&quot;&gt;&lt;&#x2F;i&gt; &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt; 字数统计: &lt;&#x2F;span&gt; &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; wordcount(post.content) %&gt;字&lt;&#x2F;span&gt; &lt;&#x2F;span&gt; &lt;&#x2F;span&gt; &lt;span class&#x3D;&quot;post-time&quot;&gt; &amp;nbsp; | &amp;nbsp; &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt; &lt;i class&#x3D;&quot;fa fa-hourglass-half&quot;&gt;&lt;&#x2F;i&gt; &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt; 阅读时长: &lt;&#x2F;span&gt; &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; min2read(post.content) %&gt;分&lt;&#x2F;span&gt; &lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;&#x2F;div&gt; 然后在 themes/yelee/layout/_partial/article.ejs中添加 12345678910111213&lt;div class&#x3D;&quot;article-inner&quot;&gt; &lt;% if (theme.fancybox)&#123; %&gt; &lt;input type&#x3D;&quot;hidden&quot; class&#x3D;&quot;isFancy&quot; &#x2F;&gt; &lt;% &#125; %&gt; &lt;% if (post.link || post.title)&#123; %&gt; &lt;header class&#x3D;&quot;article-header&quot;&gt; &lt;%- partial(&#39;post&#x2F;title&#39;, &#123;class_name: &#39;article-title&#39;&#125;) %&gt; &lt;!-- 开始添加字数统计,这里才是添加的东西--&gt; &lt;% if(theme.word_count &amp;&amp; !post.no_word_count)&#123;%&gt; &lt;%- partial(&#39;post&#x2F;word&#39;) %&gt; &lt;% &#125; %&gt; &lt;!-- 添加完成 --&gt; &lt;&#x2F;header&gt; 开启功能 在yelee主题的_config.yml中添加： 1word_count: true 2.5.4 配置本地搜索 12# 项目根目录运行npm install hexo-generator-search --save 然后配置文件themes/yelee/_config.yml中修改为： 12345search: on: true onload: true ## true: get search.xml file when the page has loaded ## false: get the file when search box gets focus 2.5.5 添加网站运行时间 \\themes\\yelee\\layout\\_partial路径下找到footer.ejs添加如下代码： 123456789101112131415161718192021222324252627&lt;footer id&#x3D;&quot;footer&quot;&gt; &lt;div class&#x3D;&quot;outer&quot;&gt; &lt;div id&#x3D;&quot;footer-info&quot;&gt; &lt;div class&#x3D;&quot;footer-left&quot;&gt; &lt;&#x2F;div&gt; &lt;!--添加代码的位置,以及要添加的代码 &lt;span id&#x3D;&quot;timeDate&quot;&gt;载入天数...&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;times&quot;&gt;载入时分秒...&lt;&#x2F;span&gt; &lt;script&gt; var now &#x3D; new Date(); function createtime() &#123; var grt &#x3D; new Date(&quot;09&#x2F;13&#x2F;2020 12:49:00&quot;);&#x2F;&#x2F;此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime() + 250); days &#x3D; (now - grt) &#x2F; 1000 &#x2F; 60 &#x2F; 60 &#x2F; 24; dnum &#x3D; Math.floor(days); hours &#x3D; (now - grt) &#x2F; 1000 &#x2F; 60 &#x2F; 60 - (24 * dnum); hnum &#x3D; Math.floor(hours); if (String(hnum).length &#x3D;&#x3D; 1) &#123; hnum &#x3D; &quot;0&quot; + hnum; &#125; minutes &#x3D; (now - grt) &#x2F; 1000 &#x2F; 60 - (24 * 60 * dnum) - (60 * hnum); mnum &#x3D; Math.floor(minutes); if (String(mnum).length &#x3D;&#x3D; 1) &#123; mnum &#x3D; &quot;0&quot; + mnum; &#125; seconds &#x3D; (now - grt) &#x2F; 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum &#x3D; Math.round(seconds); if (String(snum).length &#x3D;&#x3D; 1) &#123; snum &#x3D; &quot;0&quot; + snum; &#125; document.getElementById(&quot;timeDate&quot;).innerHTML &#x3D; &quot;本站已安全运行 &quot; + dnum + &quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML &#x3D; hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; &#125; setInterval(&quot;createtime()&quot;, 250); &lt;&#x2F;script&gt; --&gt; &lt;div class&#x3D;&quot;footer-right&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; ……&lt;&#x2F;footer&gt; 2.5.6 Url持久化 可以发现 hexo 默认生成的文章地址路径是 【网站名称／年／月／日／文章名称】。 这种链接对搜索爬虫是很不友好的，它的 url 结构超过了三层，太深了。 安装 hexo-abbrlink 插件： 1npm install hexo-abbrlink --save 然后配置根目录的_config.yml 12permalink: :title/#permalink: :year/:month/:day/:title/ 2.5.7 添加二次元虚拟人物 获取： 1npm install --save hexo-helper-live2d 下载人物模型，官方： 12345npm install live2d-widget-model-shizuku # 对应use: live2d-widget-model-unitychannpm install live2d-widget-model-hibiki# 对应use: live2d-widget-model-hibiki 配置： 123456789101112live2d: enable: true scriptFrom: local model: #只需要修改unitychan就可以更换虚拟人物 use: live2d-widget-model-unitychan display: position: right width: 150 height: 300 mobile: show: true 2.5.8 当文章中有图片时 图片在博文中十分常见，因博客部署在GitHub上，空间有限，推荐将图片、音频、视频等文件存放在七牛云这样的地方。 2.5.8.1 使用七牛云同步插件 注册账号登录，点击对象存储，创建存储空间，并绑定域名，绑定域名参考官网提供的说明 hexo安装七牛云同步插件：npm install hexo-qiniu-sync --save hexo的配置文件中进行七牛云配置 12345678910111213141516171819202122232425262728#plugins:# - hexo-qiniu-syncqiniu: offline: true # 离线,true会省流量 sync: true bucket: #这里需要填写第一步创建的存储空间的名字 # 这里将其注释掉，不注释，执行hexo g报错 # secret_file: sec/qn.json or C: #登录自己的七牛云账号，点击右上角的投降，选择密钥管理，可以获得 access_key: your access_key secret_key: your secret_key // 上传的资源子目录前缀.如设置，需与urlPrefix同步 dirPrefix: static //外链前缀，第一步绑定的加速域名 urlPrefix: http://自己的加速域名/static //使用默认配置即可 up_host: http://upload.qiniu.com //本地目录 local_dir: static // 是否更新已经上传过的文件(仅文件大小不同或在上次上传后进行更新的才会重新上传) update_exist: true image: folder: images extend: js: folder: js css: folder: css 在hexo根目录下创建如下目录结构，之后将对应的想要存放到七牛云的文件放到对应的文件夹即可 1234static - images - js - css 在文章中插入图片 1&#123;% qnimg 图片.图片格式 title: alt: &#39;class:&#39; extend:?imageView2&#x2F;2&#x2F;w&#x2F;450 %&#125; 将本地static目录下的文件同步到七牛云 1234567hexo qiniu sync#或者hexo qiniu s#或者hexo qiniu sync2#或者hexo qiniu s2 2.5.8.2 使用picGo工具 同步插件在使用过程中发现，在文章使用过程中看不到预览，并且在生成过程中还是会把图片放到public目录，所以会推荐使用picGo，提取码cdef工具来上传，成功后会返回外链地址，方便使用。 2.5.9 文章底部不显示作者 倘若出现了这种情况，可以在主题的配置文件中添加： 1author: 作者名字 2.5.10 添加点击爱心效果 下载js文件，链接地址,密码bcde 在theme/yelee/source下创建resources目录并将js文件拷贝到此目录下 在/themes/yelee/layout/_partial/after-footer.ejs下添加代码 1234&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;resources&#x2F;float.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;resources&#x2F;love.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; color&#x3D;0,104,183 opacity&#x3D;1 zindex&#x3D;-1 count&#x3D;50 src&#x3D;&quot;&#x2F;resources&#x2F;particle.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;resources&#x2F;typewriter.js&quot;&gt;&lt;&#x2F;script&gt; 2.5.11 其它 主题文件的_config.yml还可以配置什么： 网站的ico图标 自己的头像 导航栏链接 背景图片 是否开启分享 是否需要评论、以及是否显示评论数量 文章的标题风格、字体大小 …… 3. 把本地的博客内容同步到 Github 上 因为博客托管在GitHub上，所以在建立博客仓库时，仓库的名字需要命名为：用户名.github.io这样就可以通过用户名.github.io来访问该站点了。 创建好仓库后，需要本地生成SSH秘钥，方便通过git来进行提交 命令行输入：ssh-keygen -t rsa -C &quot;你的邮箱地址&quot;,之后不停的回车，期间，留意秘钥保存的路径，一般是：C:\\Users\\你的计算机用户名\\.ssh，会生成两个文件： 私钥：id_rsa 公钥：id_rsa.pub 访问自己GitHub账户的setting/SSH keys，将公钥的内容复制粘贴到Key的位置（主义末尾不要留有空行），title内容随意。 安装两个跟部署相关的 hexo 插件 12npm install hexo -server --savenpm install hexo-deployer-git --save 编辑全局的hexo配置文件：_config.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 这一块区域主要是设置博客的主要说明，需要注意的是：每个冒号后面都是有一个空格，然后再书写自己的内容的stitle: LearnFoever #网站标题subtitle: #网站副标题description: #描述author: silverbeatsemail: 418116014@qq.comlanguage: zh-CNtimezone: #网站时区。Hexo 默认使用您电脑的时区# URL 这一块一般可以设置的是 url 这个参数，比如我要设置绑定域名的，这里就需要填写我的域名信息## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;url: http://silverbeats.github.io #倘若已经购买了域名的话可以填买的域名root: /#这里配置的url持久化permalink: :title/ #:year/:month/:day/:title/ permalink_defaults:# Directorysource_dir: source #源文件夹，这个文件夹用来存放内容。public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #nclude code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，可使用 glob 表达式来匹配路径# Writingnew_post_name: :title.md #新建文章默认文件名default_layout: post # 默认布局titlecase: false # Transform title into titlecaseexternal_link: true # 在新标签中打开一个外部链接，默认为truefilename_case: 0 render_drafts: false #是否渲染_drafts目录下的文章，默认为falsepost_asset_folder: true #启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址，默认falsefuture: true #显示未来的文章，默认falsehighlight: #代码块的设置 enable: true line_number: true auto_detect: false tab_replace: &#x27;&#x27; wrap: true hljs: falseprismjs: enable: false preprocess: true line_number: true tab_replace: &#x27;&#x27;# Home page setting# path: Root path for your blogs index page. (default = &#x27;&#x27;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &#x27;&#x27; per_page: 10 order_by: -date# Category &amp; Tag #分类和标签的设置default_category: uncategorized #默认分类category_map:tag_map:# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;updated_option: &#x27;mtime&#x27;# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Include / Exclude file(s)## include:/exclude: options only apply to the &#x27;source/&#x27; folderinclude:exclude:ignore:# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yelee # next yeleesearch: path: search.xml field: all# Deployment## 这里是重点，这里是修改发布地址，因为我们前面已经加了 SSH 密钥信息在 Github 设置里面了，所以只要我们电脑里面持有那两个密钥文件就可以无需密码地跟 Github 做同步。## 需要注意的是这里的 repo 采用的是 ssh 的地址，而不是 https 的。分支我们默认采用 master 分支，以后熟悉了要换其他也无所谓。## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:SilverBeats/SilverBeats.github.io.git,master# hexo-neat 对静态文件进行压缩neat_enable: trueneat_html: enable: true exclude: neat_css: enable: true exclude: - &#x27;*.min.css&#x27;neat_js: enable: true mangle: true output: compress: exclude: - &#x27;*.min.js&#x27;#萌妹子live2d: enable: true scriptFrom: local model: use: live2d-widget-model-hibiki display: position: right width: 150 height: 300 mobile: show: true","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"blog.silverbeats.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"blog.silverbeats.cn/tags/hexo/"},{"name":"git","slug":"git","permalink":"blog.silverbeats.cn/tags/git/"},{"name":"github","slug":"github","permalink":"blog.silverbeats.cn/tags/github/"},{"name":"nodejs","slug":"nodejs","permalink":"blog.silverbeats.cn/tags/nodejs/"}],"author":"silverbeats"}],"categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法设计与分析","slug":"算法/算法设计与分析","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"博客搭建","slug":"博客搭建","permalink":"blog.silverbeats.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"串","slug":"串","permalink":"blog.silverbeats.cn/tags/%E4%B8%B2/"},{"name":"KMP","slug":"KMP","permalink":"blog.silverbeats.cn/tags/KMP/"},{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"分治法","slug":"分治法","permalink":"blog.silverbeats.cn/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"},{"name":"最短路径","slug":"最短路径","permalink":"blog.silverbeats.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"blog.silverbeats.cn/tags/Dijkstra/"},{"name":"Floyd","slug":"Floyd","permalink":"blog.silverbeats.cn/tags/Floyd/"},{"name":"hexo","slug":"hexo","permalink":"blog.silverbeats.cn/tags/hexo/"},{"name":"排序","slug":"排序","permalink":"blog.silverbeats.cn/tags/%E6%8E%92%E5%BA%8F/"},{"name":"git","slug":"git","permalink":"blog.silverbeats.cn/tags/git/"},{"name":"github","slug":"github","permalink":"blog.silverbeats.cn/tags/github/"},{"name":"nodejs","slug":"nodejs","permalink":"blog.silverbeats.cn/tags/nodejs/"}]}