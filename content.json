{"meta":{"title":"LearnForever","subtitle":"","description":"坚持学习每一天","author":"silverbeats","url":"blog.silverbeats.cn","root":"/"},"pages":[{"title":"schedule","date":"2020-09-15T10:47:30.000Z","updated":"2020-09-15T11:38:33.448Z","comments":false,"path":"schedule/index.html","permalink":"blog.silverbeats.cn/schedule/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-09-15T10:32:54.000Z","updated":"2020-09-15T11:38:48.370Z","comments":false,"path":"categories/index.html","permalink":"blog.silverbeats.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-09-15T10:33:05.000Z","updated":"2020-09-15T11:38:04.782Z","comments":false,"path":"tags/index.html","permalink":"blog.silverbeats.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mybatis","slug":"Mybatis","date":"2020-10-18T08:39:50.000Z","updated":"2020-10-18T10:34:50.437Z","comments":true,"path":"Mybatis/","link":"","permalink":"blog.silverbeats.cn/Mybatis/","excerpt":"","text":"1. 简介 1.1 什么是Mybatis MyBatis本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github MyBatis 是一款优秀的持久层框架 它支持自定义 SQL、存储过程以及高级映射。 MyBatis免除了几乎所有的 JDBC代码以及设置参数和获取结果集的工作。MyBatis可以通过简单的XML或注解来配置和映射原始类型、接口和 Java的POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 1.2 获得Mybatis Maven仓库 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.3&lt;/version&gt;&lt;/dependency&gt; GitHub 中文文档 1.2 使用Mybatis的原因 简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。 解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 提供映射标签，支持对象与数据库的orm字段关系映射 提供对象关系映射标签，支持对象关系组建维护 提供xml标签，支持编写动态sql 2. 第一个Mybatis程序 2.1 环境搭建 搭建数据库 123456789101112CREATE DATABASE `mybatistest`;USE `mybatistest`;CREATE TABLE `user` ( `id` INT(20) NOT NULL PRIMARY KEY, `name` VARCHAR(30) DEFAULT NULL, `pwd` VARCHAR(30) DEFAULT NULL)ENGINE=INNODB DEFAULT CHARSET=utf8;INSERT INTO `user` VALUES(1,&quot;张三&quot;, &quot;123456&quot;),(2,&quot;李四&quot;, &quot;1234567&quot;),(3,&quot;王五&quot;, &quot;1234568&quot;) 创建Maven项目 删除src目录 导入Maven依赖 1234567891011121314151617181920&lt;dependencies&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.18&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--Junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.2 创建一个模块 在resources文件夹下，创建Mybatis核心配置文件 123456789101112131415161718&lt;!--configuration核心配置文件--&gt;&lt;configuration&gt; &lt;!--多个环境--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!--开发环境--&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!--事务管理--&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!--数据库相关--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatistest?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 编写Mybatis的工具类 123456789101112131415161718192021package com.silverbeats.utils;public class MybatisUtil &#123; private static SqlSessionFactory sqlSessionFactory; static &#123; // 使用Mybatis第一步：获取SQLSessionFactory对象 try &#123; String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。 // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession // 实例来直接执行已映射的 SQL 语句 public static SqlSession getSqlSession() &#123; return sqlSessionFactory.openSession(); &#125;&#125; 2.3 编写代码 实体类 12345678package com.silverbeats.pojo;public class User &#123; private int id; private String name; private String pwd; // 以及空参、有参、get、set、toString方法&#125; Dao接口 123public interface UserMapper &#123; List&lt;User&gt; getUserList();&#125; 接口实现类 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--命名空间 绑定一个对应的dao接口也就是mapper接口--&gt;&lt;mapper namespace=&quot;com.silverbeats.dao.UserMapper&quot;&gt; &lt;!--id对应绑定接口的方法,resultType返回类型要写全类名--&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.silverbeats.pojo.User&quot;&gt; select * from mybatistest.user &lt;/select&gt;&lt;/mapper&gt; 2.4 Junit测试 根据上面的内容进行测试一定出现下面的异常 12绑定异常org.apache.ibatis.binding.BindingException: Type interface com.silverbeats.dao.UserMapper is not known to the MapperRegistry 这是因为在Maybatis核心配置文件中缺少内容 1234&lt;!--每一个Mapper.xml都需要在Mybatis核心配置文件中注册,这里就是MapperRegistry--&gt;&lt;mappers&gt; &lt;mapper resource=&quot;com/silverbeats/dao/UserMapper.xml&quot;/&gt;&lt;/mappers&gt; 但是运行单元测试还是会出现下面的异常，表示找不到配置文件 1234567java.lang.ExceptionInInitializerError at com.silverbeats.dao.UserMapperTest.test(UserMapperTest.java:15) ……Caused by: org.apache.ibatis.exceptions.PersistenceException: ### Error building SqlSession.### The error may exist in com&#x2F;silverbeats&#x2F;dao&#x2F;UserMapper.xml### Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.io.IOException: Could not find resource com&#x2F;silverbeats&#x2F;dao&#x2F;UserMapper.xml 这是因为Maven项目中资源导出的问题，需要在父工程或者子工程的pom.xml导入如下代码（保险起见都父子工程导入） 1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 123456789101112131415161718192021@Testpublic void test() &#123; // 获得SqlSession对象 SqlSession sqlSession = MybatisUtil.getSqlSession(); try &#123; // 方式一：执行sql UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = userMapper.getUserList(); // 方法2 // List&lt;User&gt; userList = sqlSession.selectList(&quot;com.silverbeats.dao.UserMapper.getUserList&quot;); // 打印数据 for (User user : userList) &#123; System.out.println(user); &#125; &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭SqlSession sqlSession.close(); &#125;&#125; 2.5 总结 上面的第一个程序中，一共创建了6个文件 子工程resources/mybatis-config.xml Mybatis核心配置文件 子工程java目录下建包，dao目录下User实体类对应的接口UserMapper dao目录下实体类接口UserMapper对应的配置文件UserMapper.xml，并且每个xml配置文件都需要在Mybatis核心配置文件中进行注册 pojo目录下，User实体类，JavaBean utils目录下，MybatisUtil工具类，加载核心配置文件，返回sqlSession test目录下，对应目录结构，创建了Junit测试类 其中，在后期使用过程中，有一些文件是不需要修改的： MybatisUtil类不需要修改 User实体类不需要变动，除非数据库对应的字段发生变化 当需要向数据库添加新的表时，只需要在dao目录下创建对应的Mapper、Mapper.xml并在Mybatis-config.xml进行注册，以及pojo下的实体类即可 3. CRUD 在UserMapper.xml书写sql，进行CRUD 3.1 select标签 编写接口 1234// 查询全部用户List&lt;User&gt; getUserList();// 根据id查询用户User getUserById(int id); 编写对应Mapper.xml的sql 12345678&lt;!--普通查询--&gt;&lt;select id=&quot;getUserList&quot; resultType=&quot;com.silverbeats.pojo.User&quot;&gt; select * from mybatistest.user;&lt;/select&gt;&lt;!--带有条件的查询--&gt;&lt;select id=&quot;getUserById&quot; resultType=&quot;com.silverbeats.pojo.User&quot; parameterType=&quot;int&quot;&gt; select * from mybatistest.user where id = #&#123;id&#125;;&lt;/select&gt; id 绑定的namespace中的方法名 resultType sql语句执行的返回值 parameterType 参数类型 12345678@Testpublic void getUserById() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.getUserById(2); System.out.println(user); sqlSession.close();&#125; 3.2 insert标签 编写接口 12345// 插入用户int addUser(User user);// 删除用户int deleteUser(int id); 编写对应Mapper.xml的sql 123&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.silverbeats.pojo.User&quot;&gt; insert into mybatistest.user (id, name, pwd) values(#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;);&lt;/insert&gt; 123456789101112@Testpublic void addUser() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int res = userMapper.addUser(new User(4, &quot;胡娜&quot;, &quot;asdf&quot;)); // 插入成功，提交事务 if(res &gt; 0) &#123; sqlSession.commit(); &#125; sqlSession.close();&#125; 3.3 update标签 编写接口 12// 修改用户int updateUser(User user); 编写对应Mapper.xml的sql 123&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.silverbeats.pojo.User&quot;&gt; update mybatistest.user set name=#&#123;name&#125;, pwd=#&#123;pwd&#125; where id = #&#123;id&#125;;&lt;/update&gt; 123456789101112@Testpublic void updateUser() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int res = userMapper.updateUser(new User(4, &quot;胡娜12&quot;, &quot;asdf&quot;)); // 更新成功，提交事务 if(res &gt; 0) &#123; sqlSession.commit(); &#125; sqlSession.close();&#125; 3.4 delete标签 编写接口 12// 删除用户int deleteUser(int id); 编写对应Mapper.xml的sql 123&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from mybatistest.user where id = #&#123;id&#125;;&lt;/delete&gt; 123456789101112@Testpublic void deleteUser() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int res = userMapper.deleteUser(4); // 插入成功，提交事务 if(res &gt; 0) &#123; sqlSession.commit(); &#125; sqlSession.close();&#125; 3.5 Map 倘若实体类或者数据库中的表字段过多，可以考虑使用Map集合来解决 12// 用map插入用户int addUser2(Map&lt;String, Object&gt; map); 1234&lt;!--通过map添加--&gt;&lt;insert id=&quot;addUser2&quot; parameterType=&quot;map&quot;&gt; insert into mybatistest.user (id, name, pwd) values(#&#123;userid&#125;, #&#123;userName&#125;, #&#123;password&#125;);&lt;/insert&gt; 1234567891011121314@Testpublic void addUser2() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;userid&quot;, 7); map.put(&quot;userName&quot;, &quot;呼啦啦&quot;); map.put(&quot;password&quot;, &quot;lliiww&quot;); userMapper.addUser2(map); sqlSession.commit(); sqlSession.close();&#125; Map传递参数，直接在sql中取出对应的key即可，parameterType=“map” 对象传递参数，直接在sql中取对象的属性即可，parameterType=“com.silverbeats.pojo.User” 在只有一个基本类型参数的情况下，可以直接在sql中取到 多个参数用Map，或者注解 4. 配置解析 配置文档 4.1 核心配置文件mybatis-config.xml 标签书写顺序 The content of element type “configuration” must match “(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)”. 4.2 properties 属性 可以通过properties 属性来实现引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置 在[上面的程序](#2. 第一个Mybatis程序)的核心配置文件中，可以将其中的driver、url、username、password写到properties文件中 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatistest?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghaiusername=rootpassword=root 然后在核心配置文件中引入该properties文件 12345678910111213141516171819&lt;configuration&gt; &lt;!--引入外部配置文件--&gt; &lt;properties resource=&quot;db.properties&quot; /&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--每一个Mapper.xml都需要在Mybatis核心配置文件中注册--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/silverbeats/dao/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 同时properties标签内可以使用property标签来添加属性，比如将username和password用property传递，url和driver用properties文件 12driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatistest?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai 1234&lt;properties resource=&quot;db.properties&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;/properties&gt; 这样也可以达到相同的效果。 倘若是下面这种情况 1password=root 123&lt;properties resource=&quot;db.properties&quot;&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt;&lt;/properties&gt; 会优先使用properties文件中的password值 4.3 settings 设置 settings 设置文档 4.4 typeAliases 类型别名 在核心配置文件中给实体类起别名，这样，可以在Mapper.xml中的resultType和parameterType直接使用这个别名即可，而不需要写全类名 1234&lt;!--给实体类起别名--&gt;&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.silverbeats.pojo.User&quot; alias=&quot;User&quot; /&gt;&lt;/typeAliases&gt; 也可以指定一个包名，Mybatis会在包名下面搜索需要的JavaBean，在没有注解的情况下，扫描到的Bean别名模式是类名小写 123&lt;typeAliases&gt; &lt;package name=&quot;com.silverbeats.pojo&quot;/&gt;&lt;/typeAliases&gt; 第三种起别名方式为加注解 12@Alias(&quot;hulala&quot;)public class User &#123;&#125; 上面三个方式都可以给实体类起别名，优先级不同，第一种直接给实体类起别名优先级最高，其次是注解，最后是指定包名给实体类起别名 4.5 environments 环境变量 MyBatis 可以配置成适应多种环境，尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境 1234567891011121314&lt;!--通过修改default的值来切换环境--&gt;&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt; &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt; &lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; transactionManager事务管理器 JDBC 默认 MANAGED dataSource数据源，dataSource元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源，三种内建的数据源类型 UNPOOLED 这个数据源的实现会每次请求时打开和关闭连接。虽然有点慢，但对那些数据库连接可用性要求不高的简单应用程序来说，是一个很好的选择。 性能表现则依赖于使用的数据库，对某些数据库来说，使用连接池并不重要，这个配置就很适合这种情形 POOLED 默认 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这种处理方式很流行，能使并发 Web 应用快速响应请求 JNDI 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用 4.6 映射器Mappers 既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要来定义 SQL 映射语句了。 但首先，我们需要告诉 MyBatis 到哪里去找到这些语句。 在自动查找资源方面，Java 并没有提供一个很好的解决方案，所以最好的办法是直接告诉 MyBatis 到哪里去找映射文件。 你可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 file:/// 形式的 URL），或类名和包名等。例如： 123456&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt; &lt;mapper resource=&quot;org/mybatis/builder/BlogMapper.xml&quot;/&gt; &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;&lt;/mappers&gt; 123456&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt; &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt; &lt;mapper url=&quot;file:///var/mappers/BlogMapper.xml&quot;/&gt; &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt;&lt;/mappers&gt; 下面两个方法需要注意： 接口和它的Mapper配置文件必须同名 接口和它的Mapper配置文件必须同包 123456&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt; &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt; &lt;mapper class=&quot;org.mybatis.builder.BlogMapper&quot;/&gt; &lt;mapper class=&quot;org.mybatis.builder.PostMapper&quot;/&gt;&lt;/mappers&gt; 1234&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt; &lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt; 4.7 其他 typeHandlers 类型处理器 objectFactory 对象工厂 plugins 插件 Mybatis-generator-core Mybatis-plus 通用mapper 5. 生命周期和作用域 作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题 对象生命周期和依赖注入框架 依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。 如果对如何通过依赖注入框架使用 MyBatis 感兴趣，可以研究一下 MyBatis-Spring 或 MyBatis-Guice 两个子项目。 5.1 SqlSessionFactoryBuilder 可实例化 一旦创建了 SqlSessionFactory，就不再需要它了 作用域：局部变量 5.2 SqlSessionFactory 一旦创建，一直存在 可以想象为：数据库连接池 单例模式或静态单例模式 作用域：全局作用域 5.3 SqlSession 每个线程都应该有它自己的 SqlSession 实例，可以理解为连接到连接池的一个请求，需要自行请求和关闭 SqlSession 的实例不是线程安全的，因此是不能被共享的 用完就关闭，否则会出现资源占用 最佳的作用域是请求或方法作用域 6. 解决属性名和字段名不一致的问题 当实体类中的私有属性，比如password，而在数据库中对应的字段名是pwd，倘若通过id查询，是不会获得对应的值的。 因为在Mapper.xml中对应的sql是这样写的： 1234select * from mybatistest.user where id = #&#123;id&#125;;-- 实际上是：select id,name,pwd from mybatistest.user where id = #&#123;id&#125;;-- 目标就是，如何将查询到的pwd值给到password 解决方法 起别名 1select id,name,pwd as password from mybatistest.user where id = #&#123;id&#125;; resultMap结果集映射，在Mapper.xml中写 12345678910111213&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!--column和property值一样，可省略--&gt; &lt;!--column对应数据库的列--&gt; &lt;!--property对应实体类的属性值--&gt; &lt;result column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;!--column和property值一样，可省略--&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot; /&gt;&lt;/resultMap&gt;&lt;!--此时不需要resultType--&gt;&lt;select id=&quot;getUserById&quot; resultMap=&quot;UserMap&quot; parameterType=&quot;int&quot;&gt; select * from mybatistest.user where id = #&#123;id&#125;;&lt;/select&gt; 7. 日志 7.1 日志工厂 如果一个数据库操作出现异常，需要排错，日志就是最好的助手。 在核心配置文件中配置logImpl，指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J LOG4J 【掌握】【需要导包】 LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING【掌握】【可以直接用】 NO_LOGGING 123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt; 7.2 LOG4J Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIXSyslog守护进程等； 可以控制每一条日志的输出格式 可以定义每一条日志信息的级别，能够更加细致地控制日志的生成过程 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 导入LOG4J包 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; log4j.properties 12345678910111213141516171819202122232425#将登记为DEBUG的日志信息输出到console和file两个目的地log4j.rootLogger = debug,console,file#控制台输出的相关配置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.out log4j.appender.console.Threshold = DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern = [%c]-%m%n#文件输出相关配置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File = ./logs/log.loglog4j.appender.file.MaxFileSize = 10mb##输出DEBUG级别以上的日志log4j.appender.file.Threshold = DEBUGlog4j.appender.file.layout = org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n#日志输出级别log4j.logger.org.mybatis = DEBUGlog4j.logger.java.sql = DEBUGlog4j.logger.java.sql.Statement = DEBUGlog4j.logger.java.sql.ResultSet = DEBUGlog4j.logger.java.sql.PrepareStatement= DEBUG 配置核心文件 123&lt;settings &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;&lt;/settings&gt; 8. 分页 8.1 limit分页 分页的原因：减少数据的处理量，提高效率 1select * from 表 limit startIndex, pageSize; 接口 12// 测试分页List&lt;User&gt; getUsers(Map&lt;String, Integer&gt; map); Mapper.xml 123&lt;select id=&quot;getUsers&quot; resultMap=&quot;UserMap&quot; parameterType=&quot;map&quot;&gt; select * from mybatistest.user limit #&#123;startIndex&#125;, #&#123;pageSize&#125;;&lt;/select&gt; 测试 12345678910111213@Testpublic void testLimit() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put(&quot;startIndex&quot;, 1); map.put(&quot;pageSize&quot;, 2); List&lt;User&gt; userList = userMapper.getUsers(map); for (User user : userList) &#123; logger.info(user); &#125; sqlSession.close();&#125; 8.2 RowBounds分页 接口 12// 使用RowBounds查询List&lt;User&gt; getUsersByRowBounds(); Mapper.xml 123&lt;select id=&quot;getUsers&quot; resultMap=&quot;UserMap&quot;&gt;select * from mybatistest.user;&lt;/select&gt; 测试 123456789101112@Testpublic void testRoundBounds() &#123;SqlSession sqlSession = MybatisUtil.getSqlSession();// RowBounds实现RowBounds rowBounds = new RowBounds(0, 3);// 通过java代码层面实现分页List&lt;User&gt; selectList = sqlSession.selectList(&quot;com.silverbeats.dao.UserMapper.getUsersByRowBounds&quot;,null, rowBounds);for (User user : selectList) &#123;logger.info(user);&#125;sqlSession.close();&#125; 8.3 分页插件 pagehelper 9. 使用注解 接口 12345678910111213141516@Select(&quot;select * from user&quot;)List&lt;User&gt; getUsers();// 方法存在多个参数,所有参数前面必须要有@Param@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)User getUserById(@Param(&quot;id&quot;) int id);// 插入用户@Select(&quot;insert into mybatistest.user (id, name, pwd) values(#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;)&quot;)void insertUser(@Param(&quot;id&quot;) int id, @Param(&quot;name&quot;) String name,@Param(&quot;pwd&quot;) String password);@Select(&quot;insert into mybatistest.user (id, name, pwd) values(#&#123;id&#125;, #&#123;name&#125;, #&#123;password&#125;)&quot;)void addUser(User user);// 更新@Update(&quot;update user set name = #&#123;name&#125; where id = #&#123;id&#125;&quot;)int updateUser(User user);// 删除@Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)int deleteUser(@Param(&quot;id&quot;) int id); @Param()注解 基本类型的参数或者String类型，需要加上注解 如果只有一个基本类型，可以忽略 引用类型不需要加 在sql引用的就是这里设定的属性名 核心配置xml 1234&lt;!--绑定接口--&gt;&lt;mappers&gt; &lt;mapper class=&quot;com.silverbeats.dao.UserMapper&quot;/&gt;&lt;/mappers&gt; 10. Lombok Lombok项目是一个Java库，它会自动插入您的编辑器和构建工具中，从而使您的Java更加生动有趣。永远不要再写另一个getter或equals方法，带有一个注释的您的类有一个功能全面的生成器，自动执行记录变量等。 idea中安装插件 项目中导入lombok的jar包 12345@data: 可以添加无参构造、get、set、toString、hashCode、equals@ToString: 重写toString方法@AllArgsConstructor: 添加有参构造@NoArgsConstructor: 添加无参构造@EqualsAndHashCode: 添加hashCode、equals方法 11. 复杂查询环境 搭建环境，创建学生表和老师表 123456789101112131415161718192021CREATE TABLE `teacher` ( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO teacher(`id`, `name`) VALUES (1, &#x27;乌拉拉&#x27;); CREATE TABLE `student` ( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAULT NULL, `tid` INT(10) DEFAULT NULL, PRIMARY KEY (`id`), KEY `fktid` (`tid`), CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;1&#x27;, &#x27;小明&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;2&#x27;, &#x27;小红&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;3&#x27;, &#x27;小张&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;4&#x27;, &#x27;小李&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;5&#x27;, &#x27;小王&#x27;, &#x27;1&#x27;); 11.1 多对一 多个学生关联一个老师 123456789101112131415@Data@AllArgsConstructor@NoArgsConstructorpublic class Student &#123; private int id; private String name; private Teacher teacher;&#125;@Data@AllArgsConstructor@NoArgsConstructorpublic class Teacher &#123; private int id; private String name;&#125; 12-- 在mybatis实现下面的sqlselect * from student s, teacher t where s.tid = t.id; ①先获取所有学生的信息 ②根据学生的tid获取对应老师的信息 按照查询嵌套 12345678910111213&lt;select id=&quot;getStudentInfo&quot; resultMap=&quot;studentTeacher&quot;&gt; select * from student;&lt;/select&gt;&lt;resultMap id=&quot;studentTeacher&quot; type=&quot;student&quot;&gt; &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;association column=&quot;tid&quot; property=&quot;teacher&quot; javaType=&quot;teacher&quot; select=&quot;getTeacher&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt; select * from teacher where id = #&#123;tid&#125;;&lt;/select&gt; 按照结果嵌套 123456789101112&lt;select id=&quot;getStudentInfo2&quot; resultMap=&quot;studentTeacher2&quot;&gt; select s.id sid, s.name sname, t.name tname from student s, teacher t where s.tid = t.id;&lt;/select&gt;&lt;resultMap id=&quot;studentTeacher2&quot; type=&quot;student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;teacher&quot;&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt; 11.2 一对多 一个老师关联多个学生 12345678910111213141516@Data@AllArgsConstructor@NoArgsConstructorpublic class Student &#123; private int id; private String name; private int tid;&#125;@Data@AllArgsConstructor@NoArgsConstructorpublic class Teacher &#123; private int id; private String name; private List&lt;Student&gt; students;&#125; 12// 获取指定老师下的学生信息和老师信息Teacher getTeacherById(@Param(&quot;tid&quot;) int id); 按照结果嵌套 123456789101112131415&lt;!--获取指定老师下的学生信息和老师信息--&gt;&lt;select id=&quot;getTeacherById&quot; resultMap=&quot;teacherStudent&quot;&gt; select s.id sid, s.name sname, t.name tname, t.id tid from student s, teacher t where s.tid = tid and tid = #&#123;tid&#125;&lt;/select&gt;&lt;resultMap id=&quot;teacherStudent&quot; type=&quot;teacher&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;tid&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;collection property=&quot;students&quot; ofType=&quot;student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 按照查询嵌套 1234567891011&lt;select id=&quot;getTeacherById&quot; resultMap=&quot;teacherStudent&quot;&gt; select * from teacher where id = #&#123;tid&#125;;&lt;/select&gt;&lt;resultMap id=&quot;teacherStudent&quot; type=&quot;teacher&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;student&quot; select=&quot;getStudentsByTeacherId&quot; column=&quot;id&quot; /&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentsByTeacherId&quot; resultType=&quot;student&quot;&gt; select * from student where tid = #&#123;tid&#125;&lt;/select&gt; 12. 动态sql 根据不同的条件生成不同的sql 环境 1234567CREATE TABLE `blog`( `id` VARCHAR(50) NOT NULL COMMENT &#x27;博客id&#x27;, `title` VARCHAR(100) NOT NULL COMMENT &#x27;博客标题&#x27;, `author` VARCHAR(30) NOT NULL COMMENT &#x27;博客作者&#x27;, `create_time` DATETIME NOT NULL COMMENT &#x27;创建时间&#x27;, `views` INT(30) NOT NULL COMMENT &#x27;浏览量&#x27;)ENGINE=INNODB DEFAULT CHARSET=utf8 1234567891011121314151617181920212223242526public void addBlog() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); Blog blog = new Blog(); blog.setId(IDUtils.getID()); blog.setTitle(&quot;Mybatis&quot;); blog.setAuthor(&quot;狂神说&quot;); blog.setCreateTime(new Date()); blog.setViews(9999); mapper.addBlog(blog); blog.setId(IDUtils.getID()); blog.setTitle(&quot;Java&quot;); mapper.addBlog(blog); blog.setId(IDUtils.getID()); blog.setTitle(&quot;Spring&quot;); mapper.addBlog(blog); blog.setId(IDUtils.getID()); blog.setTitle(&quot;微服务&quot;); mapper.addBlog(blog); sqlSession.close();&#125; 123456&lt;mapper namespace=&quot;com.silverbeats.dao.BlogMapper&quot;&gt; &lt;insert id=&quot;addBlog&quot; parameterType=&quot;blog&quot;&gt; insert into blog(id, title, author, create_time, views) values(#&#123;id&#125;,#&#123;title&#125;,#&#123;author&#125;,#&#123;createTime&#125;,#&#123;views&#125;); &lt;/insert&gt;&lt;/mapper&gt; 实体类 12345678910@Data@NoArgsConstructor@AllArgsConstructorpublic class Blog &#123; private String id; private String author; private String title; private Date createTime; private int view;&#125; 12.1 iF 接口 12// 查询blogList&lt;Blog&gt; queryBlogIF(Map map); Mapper.xml 123456789&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog where 1=1 &lt;if test=&quot;title != null&quot;&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/select&gt; 测试 123456789101112@Testpublic void testIf() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); HashMap map = new HashMap(); map.put(&quot;title&quot;, &quot;Spring&quot;); List&lt;Blog&gt; blogs = mapper.queryBlogIF(map); for (Blog blog : blogs) &#123; System.out.println(blog); &#125; sqlSession.close();&#125; 12.2 choose(when、otherwise) choose标签，当满足第一个when的条件就不会再往下走了 1234567891011&lt;!--测试choose--&gt;&lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt;title = #&#123;title&#125;&lt;/when&gt; &lt;when test=&quot;author != null&quot;&gt;and author = #&#123;author&#125;&lt;/when&gt; &lt;otherwise&gt;and views = #&#123;views&#125;&lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 12.3 trim（where、set） where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。 12345678&lt;!--测试where--&gt;&lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;if test=&quot;title != null&quot;&gt;title = #&#123;title&#125;&lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt;and author = #&#123;author&#125;&lt;/if&gt; &lt;/where&gt;&lt;/select&gt; set 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。 123456789&lt;!--测试set--&gt;&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt; update blog &lt;set&gt; &lt;if test=&quot;title != null&quot;&gt;title = #&#123;title&#125;,&lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt;author = #&#123;author&#125;,&lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125;;&lt;/update&gt; 12.4 foreach foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！ 123456789&lt;!--测试foreach--&gt;&lt;select id=&quot;queryForeach&quot; parameterType=&quot;ArrayList&quot; resultType=&quot;blog&quot;&gt; select * from blog where views in &lt;foreach item=&quot;item&quot; collection=&quot;list&quot; index=&quot;index&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; 实质：循环字符串拼接 collection：需要遍历的集合 item：被遍历集合的每个元素 index：被遍历元素的索引 open：开始的字符 close：结束的字符 separator：分隔符 1234567891011121314// 测试foreachList&lt;Blog&gt; queryForeach(@Param(&quot;list&quot;) List&lt;Integer&gt; list);/*----------------------------------------------------------*/@Testpublic void TestForeach() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1000); list.add(2000); list.add(7000); List&lt;Blog&gt; blogs = mapper.queryForeach(list); sqlSession.close();&#125; 12.5 sql片段 有的时候，会将公共的部分抽取出来，方便反复使用 12345678910111213141516&lt;!--测试sql片段--&gt;&lt;sql id=&quot;if_title_author&quot;&gt; &lt;if test=&quot;title != null&quot;&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/sql&gt;&lt;!--测试where--&gt;&lt;select id=&quot;queryBlogWhere&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;include refid=&quot;if_title_author&quot; /&gt; &lt;/where&gt;&lt;/select&gt; 最好基于单表来定义sql片段 sql片段中不要存在where标签 13. 缓存 读写分离，主从复制 经常查询并且不经常改变的数据可以使用缓存 13.1 Mybatis的缓存 Mybatis包含了一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存，缓存可以极大地提升查询效率 Mybatis系统中默认定义了两级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启，（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存 为了提高扩展性，Mybatis定义了缓存接口Cache，可以通过实现Cache接口来自定义二级缓存 13.2 一级缓存 12345678910@Testpublic void test() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user1 = mapper.queryUserById(1); System.out.println(&quot;=================&quot;); User user2 = mapper.queryUserById(1); System.out.println(user1 == user2); sqlSession.close();&#125; 可以看到，只有一次SQL查询，并且user1和user2是同一个对象 缓存失效的情况 查询不同的东西 增删改操作，可能会改编原来的数据，所以会刷新缓存 1234567891011121314151617@Testpublic void test() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user1 = mapper.queryUserById(1); System.out.println(&quot;=================&quot;); System.out.println(&quot;更新id=2的用户&quot;); HashMap map = new HashMap(); map.put(&quot;id&quot;, 2); map.put(&quot;name&quot;, &quot;嗯哼2&quot;); mapper.updateUserById(map); System.out.println(&quot;=================&quot;); User user2 = mapper.queryUserById(1); System.out.println(user1 == user2); sqlSession.close();&#125; 查询不同的Mapper.xml 手动清理缓存 12345678910111213@Testpublic void test() &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user1 = mapper.queryUserById(1); System.out.println(&quot;=================&quot;); System.out.println(&quot;清理缓存&quot;); sqlSession.clearCache(); System.out.println(&quot;=================&quot;); User user2 = mapper.queryUserById(1); System.out.println(user1 == user2); sqlSession.close();&#125; 13.3 二级缓存 二级缓存也称全局缓存，是基于namespace级别的缓存，一个名称空间对应一个二级缓存 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中 如果当前会话关闭了，这个会话对应的一级缓存就没了，但是目标是：一级缓存消失，会将其中的数据保存到二级缓存中 新的会话查询信息，就可以从二级缓存中获取内容 不同的mapper查出的数据可以放在自己对应的缓存（map）中 步骤： 开启全局缓存 123&lt;settings&gt;&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 在Mapper.xml中添加cache标签 1234&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt; 12345678910111213141516171819@Testpublic void test() &#123; SqlSession sqlSession1 = MybatisUtil.getSqlSession(); SqlSession sqlSession2 = MybatisUtil.getSqlSession(); UserMapper mapper1 = sqlSession1.getMapper(UserMapper.class); UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class); User user1 = mapper1.queryUserById(1); System.out.println(&quot;关闭sqlSession1&quot;); sqlSession1.close(); User user2 = mapper2.queryUserById(1); System.out.println(&quot;=================&quot;); System.out.println(user1); System.out.println(user2); System.out.println(user1 == user2); sqlSession2.close();&#125; 这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。 可用的清除策略有： LRU – 最近最少使用：移除最长时间不被使用的对象。 FIFO – 先进先出：按对象进入缓存的顺序来移除它们。 SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。 WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。 默认的清除策略是 LRU。 flushInterval（刷新间隔）属性可以被设置为任意的正整数，设置的值应该是一个以毫秒为单位的合理时间量。 默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新。 size（引用数目）属性可以被设置为任意正整数，要注意欲缓存对象的大小和运行环境中可用的内存资源。默认值是 1024。 readOnly（只读）属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。 13.4 缓存原理 缓存顺序： 先找二级缓存 再找一级缓存 最后查询数据库","categories":[{"name":"java","slug":"java","permalink":"blog.silverbeats.cn/categories/java/"},{"name":"Mybatis","slug":"java/Mybatis","permalink":"blog.silverbeats.cn/categories/java/Mybatis/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"blog.silverbeats.cn/tags/Mybatis/"}],"author":"silverbeats"},{"title":"算法设计与分析-动态规划","slug":"算法设计与分析-动态规划","date":"2020-10-02T08:27:27.000Z","updated":"2020-10-02T09:18:31.493Z","comments":true,"path":"算法设计与分析-动态规划/","link":"","permalink":"blog.silverbeats.cn/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"动态规划和分治法类似，其基本思想也是将待求解问题分解成若干个子问题。不同点在于，适用于动态规划的问题，其子问题往往不是相互独立，倘若使用分治法，会进行大量的重复计算。比如斐波那契数列求解问题，当计算Fib(10)时，会需要用到Fib(9)和Fib(8)，而计算Fib(9)也需要用到Fib(8)，实际上Fib(8)只需要计算一次即可，倘若使用分治法会对其进行两次的计算。（然而实际上，计算斐波那契数列不会用到这种求解方式，可以使用迭代解决，或者直接使用通项公式求解） 动态规划通常可以按下面四个步骤设计： 找出最优解的性质，并刻画其结构特征 递归定义最优解 以自底向上的方式计算出最优解 根据计算最优时得到的信息，构造最优解 动态规划往往是利用空间换时间 1. 矩阵连乘 矩阵的乘法有结合律，不同的计算顺序所耗费的代价不同。比如： 矩阵1 矩阵2 矩阵3 A10×100 A100×5 A5×50 计算顺序1：（矩阵1×矩阵2）×矩阵3 所需要的乘法次数：10×5×100 + 10×50×5 = 7500次 所需要的加法次数：10×5×99 + 10×50×4 = 6950次 计算顺序2：矩阵1×（矩阵2×矩阵3） 所需要的乘法次数：100×50×5 + 10×50×100 = 750000次 所需要的加法次数：100×50×4 + 10×50×99 = 497000次 这里不做矩阵相乘的O(n3)写法，相关代码可以参考算法设计与分析——分治法Strassen矩阵乘法。 2. 最长公共子序列 3. 最大子段和 4. 凸多边形最优三角剖分 5. 多边形游戏 6. 图像压缩 7. 电路布线 8. 流水作业调度 9. 背包问题 10. 最优二叉搜索树","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"算法设计与分析","slug":"算法/算法设计与分析","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"}],"tags":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"blog.silverbeats.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"silverbeats"},{"title":"KMP","slug":"KMP","date":"2020-09-29T05:08:18.000Z","updated":"2020-09-29T16:15:07.252Z","comments":true,"path":"KMP/","link":"","permalink":"blog.silverbeats.cn/KMP/","excerpt":"","text":"1. KMP简介 KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n) 2. KMP图解 2.1 通览(编号从0开始) 2.1.1 情况一 以上述主串和模式串为例子，可知，i指针指向主串，j指针指向模式串 当主串i位置与模式串j位置字符一样，i，j向后移动一个位置 2.1.2 情况二 易知，当i=5，j=5时，主串与模式串发生不匹配，此时需要进行的操作就是KMP的精华所在。 找到不匹配位置之前的字符串的最大公共前后缀。易知，最长公共前后缀是{A,B}，长度是2 进行如上图下半部分的操作。将字符串向后挪动，让前缀处于后缀的位置 易知，此时指针i是不需要任何变动。 挪动后，i，j所指向的位置继续比较。 字符串是不可能挪动的，实际上改变的是指针j，易知，挪动后指针j指向模式串编号为2的位置 上图，指针j经过调整后，从模式串编号2开始，继续和主串进行比较，当j指向编号6时发生不匹配，进行上述提到的步骤，经过调整得到下图情况三。 2.1.3 情况三 每次移动指针j后，需要检查主串剩余长度是否≥模式串需要匹配的长度 2.1.4 综合 根据上面提到的情况进行汇总，也就是代码实现的需要用到的步骤 当主串i位置与模式串j位置字符一样，i，j向后移动一个位置 当出现不匹配时，需要寻找不匹配位置之前的串的最大公共前后缀长度，比如长度是n，并将j移动到编号为n的位置，这里需要结合next数组，详情见[Next数组](#3. Next数组) 移动指针j后，需要检查主串剩余长度是否≥模式串需要匹配的长度，不符合条件直接break，返回匹配失败 当j的位置超过了模式串的编号，说明匹配成功，返回模式串第一个字符在主串出现的位置 2.2 通览(编号从1开始) 整个过程与上面标号从0开始的过程大体一致，只有一个区别就是：调整指针j的值，指的位置是不匹配位置之前的字符串的最大公共前后缀长度+1 3. Next数组 通过上一节内容可以知道，KMP算法核心是指向模式串的指针j的移动，该指针的如何移动实际上与主串是什么无关，只与模式串有关。只需要将模式串研究明白，则可以对任意主串进行匹配。 因为要匹配任意主串，故很容易知道，模式串的每个位置都有可能和主串出现不匹配。这时，当模式串每个位置出现不匹配时，此时的指针j应该调整到哪个位置，需要研究。 模式串第一个位置不匹配，j应该重新指向模式串的哪个位置 模式串第二个位置不匹配，j应该重新指向模式串的哪个位置 …… 将j重新指向的位置整理记录下来，存储到数组中，就是Next数组，Next数组的下标代表着该模式串出现不匹配的位置，数组下标对应的值就是j重新指向的位置。 同时需要考虑另外一个问题，这个问题在上面的内容有所体现。就是模式串起始编号是0还是1。起始编号不同，Next数组不同，二者之间相差一个位置 在进行KMP算法之前，是需要先获取模式串的Next数组，以便使用。 3.1 起始位置：0 上图提供的示例不全，但足以说明当某个位置出现不匹配时，指针j重新定位的位置为：不匹配位置之前字符串的最大公共前后缀长度所对应的编号 首先，为什么首位是-1，因为模式串首位不匹配需要挪动的是指向主串的i指针，是特殊情况，这样在获取next数组值的时候发现是-1，就知道需要挪动i指针，然而在实现时，只需要判断j时候等于0即可，并不需要访问next[0]时候等于-1。 3.2 起始位置：1 4. NextVal数组 5. 代码 5.1 Next 5.1.1 模式串从0标号 代码实现所使用到的next数组并不是[上面](#3.1 起始位置：0)提到的next数组。这里的next数组是每一位的最长公共前后缀的长度。比如next[2]=2，表示模式串前三个包括第三个字符，它们的最长公共前后缀长度是2。所以，倘若是模式串j位置出现不匹配，那么j位置之前的字符的最长公共前后缀长度是next[j-1] 关于下面getNext方法，可以理解为自己匹配自己 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 获取该模式串每个位置的最大公共前后缀长度private int[] getNext(char[] pattern) &#123; // 模式串长度 int len = pattern.length; int[] next = new int[len]; next[0] = 0; // i代表最长前后缀长度 int i = 0, j; for(j = 1; j &lt; len; j++) &#123; while(pattern[i] != pattern[j] &amp;&amp; i &gt; 0) i = next[i - 1]; if(pattern[i] == pattern[j]) next[j] = ++i; else next[j] = 0; &#125; return next;&#125;// 模式串匹配kmp算法,匹配成功返回匹配的位置,失败则返回-1public int kmp(char[] str, char[] pattern) &#123; // 这里的next数组是每个位置的最长公共前后缀的长度 // 比如next[2]表示0、1、2三个位置组成的字符串公共前后缀的最大长度 int[] next = getNext(pattern); // 主串的长度mainLen,i指向主串比较的位置,j指向模式串比较的位置 int mainLen = str.length, i = 0, j = 0; while(i &lt; mainLen) &#123; // 情况三: 主串不够长 if(mainLen - i &lt; pattern.length - j) break; // 情况一: 主串的字符与模式串字符相等 if(str[i] == pattern[j]) &#123; i++; j++; // 当j指向的位置已经超过模式串长度时,说明匹配成功,则返回模式串在主串中匹配成功的位置 if(j &gt;= pattern.length) return i - pattern.length; &#125; else &#123; // 情况二: 出现不匹配 // 如果j是模式串0位置,特殊情况 if(j == 0) &#123; // 挪动主串指针i i++; &#125; else &#123; // 重定位到不匹配位置之前字符，最大公共前后缀长度 j = next[j - 1]; &#125; &#125; &#125; // 默认失败 return -1;&#125; 同时可以发现，倘若要得到上面提到的那种next数组，只需要将里面所有的元素后移一个位置，然后首位添-1即可。上图中最后面的1会被舍弃。 5.1.2 模式串从1标号 1234567891011121314151617181920212223// 获取模式串的next数组private int[] getNext(char[] pattern) &#123; // 模式串长度 int len = pattern.length; int[] next = new int[len]; next[1] = 0; // i代表最长前后缀长度 int i = 1, j; for(j = 2; j &lt; len; j++) &#123; while(pattern[i] != pattern[j] &amp;&amp; i &gt; 1) i = next[i - 1]==0?1:next[i-1]; if(pattern[i] == pattern[j]) next[j] = i++; else next[j] = 0; &#125; // 倘若写上了这一步,下面的kmp中的最后一个else只需要写j = next[j]即可 // 倘若没有这一步,下面的kmp中的最后一个else需要写成j = next[j - 1] + 1 for(int k = next.length - 1; k &gt; 1; k--) &#123; next[k] = next[k-1] + 1; &#125; return next;&#125; 12345678910111213141516171819202122232425262728public int kmp(char[] str, char[] pattern) &#123; // 获取该模式串的next数组 int[] next = getNext2(pattern); // 主串的长度mainLen,i指向主串比较的位置,j指向模式串比较的位置 int mainLen = str.length, i = 0, j = 1; while(i &lt; mainLen) &#123; if(mainLen - i &lt; pattern.length - j) break; // 主串的字符与模式串字符相等 if(str[i] == pattern[j]) &#123; i++; j++; // 当j指向的位置已经超过模式串长度时,说明匹配成功,则返回模式串在主串中匹配成功的位置 if(j &gt;= pattern.length) return i - pattern.length + 1; // 这里有变化 &#125; else &#123; // 如果模式串在j这个位置与主串i这个位置字符不相等,则需要通过next数组来重新定位指向模式串字符的j的值 if(j == 1) &#123; i++; &#125; else &#123; // 这里有变化,倘若getNext有最后一个for循环 j = next[j]; // 倘若getNext没有最后一个for循环需要下面这种写法 // j = next[j - 1] + 1; &#125; &#125; &#125; // 默认失败 return -1;&#125; 5.2 NextVal","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"串","slug":"串","permalink":"blog.silverbeats.cn/tags/%E4%B8%B2/"},{"name":"KMP","slug":"KMP","permalink":"blog.silverbeats.cn/tags/KMP/"}],"author":"silverbeats"},{"title":"算法设计与分析——分治法","slug":"算法设计与分析-分治法","date":"2020-09-19T23:48:47.000Z","updated":"2020-10-02T08:26:01.088Z","comments":true,"path":"算法设计与分析-分治法/","link":"","permalink":"blog.silverbeats.cn/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%88%86%E6%B2%BB%E6%B3%95/","excerpt":"","text":"分治法的基本思想是将一个规模为n的问题分解为k个规模较小的子问题，这些子问题互相独立且与原问题相同。递归的解决这些子问题，然后将各个子问题的解合并得到原问题。 1. 二分搜索法 最简单的想法是从头找到尾，进行遍历，时间复杂度为O(n)，而利用分治法思想，使用二分搜索法，可以将时间复杂度缩小为O(logn)，但是该方法有一个前提就是，这一个序列必须有序。 下面代码假设序列是非递减序列 递归写法 12345678910111213141516public int binarySearch(int[] arr, int from, int to, int target) &#123; // 这说明没有数字了,说明没找到,返回-1 if(to &lt; from) return -1; // 得到from至to中间位置的数字的下标 int midPos = (to + from) &gt;&gt; 1; // 如果找到了该数字,返回数组下标 if(arr[midPos] == target) &#123; return midPos; &#125; else if(arr[midPos] &gt; target) &#123; // 如果中间的数字比目标值大,说明目标值值在中间值的左边 return binarySearch(arr, from, midPos - 1, target); &#125; else &#123; // 如果中间的数字比目标值大,说明目标值值在中间值的右边 return binarySearch(arr, midPos + 1, to, target); &#125;&#125; 非递归写法 12345678910111213141516public int binarySearch2(int[] arr, int target) &#123; // 两个指针指向target存在区域的左右边界,圈定范围 int left = 0, right = arr.length - 1; while(left &lt;= right) &#123; // 得到该范围的中间位置 int midPos = (right + left) &gt;&gt; 1; // 说明找到了 if(arr[midPos] == target) return midPos; // 如果中间值大,说明目标值在中间值左边,右边界right指针挪到midPos的前一个 else if(arr[midPos] &gt; target) right = midPos - 1; // 如果中间值大,说明目标值在中间值左边,右边界left指针挪到midPos的后一个 else left = midPos + 1; &#125; // 找不到返回-1 return -1;&#125; 2. 大整数乘法 对于乘法，直接使用乘法的运算符会很方便，但是仅限于参加运算的整数能在计算机硬件对整数的表示范围内直接处理时才是合理的。当需要处理很大的整数时，无法在计算机硬件能直接表示的整数范围内进行处理，若用浮点数表示，只能得到近似值，计算结果中的有效位数也会受到限制。 同时，当XY分3块，4块乃至更多，只会越来越慢。当分两块时，初步版需要4次，改进版需要3次相乘；而分成3块，其初步版就需要9次，想要得到比分成2块改进版的3次更少的乘法次数是不可能的，更何况是16次乘法的分4块初步版。 同时下图所示的过程有前提条件： X,Y都是n位，且n是2的整数次幂，只有这样才能保证每次划分A,B,C,D四个部分位数保持一致 （A-B），(D-C)这个两个数也需要满足上面这一条要求。因为这两个数相乘也是需要递归使用同一个函数 然而前提条件很多，实际上在使用时，上面两个条件都很难达到。当落地时，是实现初步版，计算4次乘法。 这里进行说明，为什么X可以那样表示。 比如一个十进制数1234，一共4位，按照上面的样子进行划分成左右AB两部分，则1234 = 12 * 102 + 34，这里的10其实是进制 同理，案例中，XY都是二进制，如X = 1101，X = 11 * 22 + 01，1101的十进制是13，11的十进制是3，01的十进制是1，X = 3 * 4 + 1 = 13 2.1 O(n2)写法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 因为数字很大,无法用某个整数数据类型表示,需要转换成整型数组,方便处理public int[] NumToArr(String num) &#123; num = fliter(num); char[] temp = num.toCharArray(); int[] arr = new int[temp.length]; for (int i = 0; i &lt; temp.length; i++) &#123; arr[i] = Integer.parseInt(temp[i] + &quot;&quot;); &#125; return arr;&#125;// 倘若传进来的字符串num中有0开头,比如0123,,或者00123,需要将0去掉public String fliter(String num) &#123; int pos0 = num.indexOf(&#x27;0&#x27;); if(pos0 != 0) return num; StringBuilder sb = new StringBuilder(num); while(pos0 == 0) &#123; sb.deleteCharAt(pos0); pos0 = sb.indexOf(&#x27;0&#x27; + &quot;&quot;); &#125; return sb.toString();&#125;// O(n2)的大整数乘法public String LargeIntegerMultiplication(int[] num1, int[] num2) &#123; int len1 = num1.length; int len2 = num2.length; int[] res = new int[len1 * len2]; int p = res.length - 1; for(int i = len1 - 1; i &gt;= 0; i--) &#123; for(int j = len2 - 1; j &gt;= 0; j--) &#123; res[p--] += num2[j] * num1[i]; &#125; p++; &#125; // 处理进制 for(int k = res.length - 1; k &gt;= 0; k--) &#123; if(res[k] &gt;= 10) &#123; res[k - 1] = res[k] / 10; res[k] %= 10; &#125; &#125; // 从后向前充填res数组，可能没有填满，导致前几位有0 StringBuilder sb = new StringBuilder(); // 从头向后遍历当遇到第一次非0数字后,flag为true boolean flag = false; for (int k = 0; k &lt; res.length; k++) &#123; if (res[k] != 0) flag = true; if(flag) sb.append(res[k]); &#125; return sb.toString();&#125; 2.2 分治法版本的O(n2) 2.2.1 主体 这里使用字符串，方便截取获得ABCD 123456789101112131415161718192021222324252627282930313233343536373839404142// 大整数乘法public String largeLongMultiply(String num1, String num2) &#123; // 存储num1乘num2的结果的数组 int[] res; // 只要有一个字符串数字长度为1,那么就可以直接相乘了 if (num1.length() == 1 || num2.length() == 1) &#123; // 相乘 res = mult(num1, num2); &#125; else &#123; // 因为num1和num2长度不一定相同,假设num1长度为a,num2长度为b,同样分成两部分 // num1 = A*10^(a/2) + B // num2 = C*10^(b/2) + D // num1*num2 = AC*10^(a/2+b/2) + BD + AD10^(a/2) + BC*10^(b/2) // 开始截取字符串,得到ABCD int halfNum1 = num1.length() &gt;&gt; 1; int halfNum2 = num2.length() &gt;&gt; 1; String A = num1.substring(0, halfNum1), B = num1.substring(halfNum1), C = num2.substring(0, halfNum2), D = num2.substring(halfNum2); // 开始相乘 String AC = largeLongMultiply(A, C), BD = largeLongMultiply(B, D), AD = largeLongMultiply(A, D), BC = largeLongMultiply(B, C); // 位移,相加并得到最终结果 res = arrAddArr( strNumToArr(BD), arrAddArr( arrAddArr( move(strNumToArr(AC), halfNum1 + halfNum2), move(strNumToArr(AD), halfNum1) ), move(strNumToArr(BC), halfNum2) ) ); &#125; // 处理进制 decimalism(res); // 处理首位0,并转成字符串返回 return arrToStr(filterZero(res));&#125; 2.2.2 主体之外的函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// 只有当str1或者str2的length为1时才会执行这里private int[] mult(String str1, String str2) &#123; int[] a = new int[str1.length()]; int[] b = new int[str2.length()]; // 将两个字符串变为数组,并且每个元素都是int类型 for (int i = 0; i &lt; a.length; i++) a[i] = (int) str1.charAt(i) - 48; for (int i = 0; i &lt; b.length; i++) b[i] = (int) str2.charAt(i) - 48; int[] res = new int[Math.max(a.length, b.length) + 1]; // 二者进行相乘 if (a.length == 1) &#123; for (int i = 0; i &lt; b.length; i++) res[i] = b[i] * a[0]; &#125; else &#123; for (int i = 0; i &lt; a.length; i++) res[i] = a[i] * b[0]; &#125; // 返回乘积结果 return res;&#125;// 字符串数字变数组public int[] strNumToArr(String str) &#123; int len = str.length(); int[] arr = new int[len]; for (int i = 0; i &lt; len; i++) arr[i] = (int) str.charAt(i) - 48; return arr;&#125;// 数组变字符串private String arrToStr(int[] arr) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; arr.length; i++) &#123; sb.append(arr[i]); &#125; return sb.toString();&#125;// arr数组所代表的数字扩大n位private int[] move(int[] arr, int n) &#123; int len = arr.length; int[] res = new int[len + n]; System.arraycopy(arr, 0, res, 0, len); return res;&#125;// 两个数组相加private int[] arrAddArr(int[] arr1, int[] arr2) &#123; int len1 = arr1.length, len2 = arr2.length;//123,12 // 这里还需要长度＋1是因为：900 + 900 = 1800类似这种情况 // 另外两个相加的数组的长度不一定一样 int[] res = new int[Math.max(len1, len2) + 1]; int p = res.length - 1; int dist = len1 - len2; if (dist &lt; 0) &#123; // arr1短 for (int i = len1 - 1; i &gt;= 0; i--) &#123; res[p--] = arr1[i] + arr2[i - dist]; &#125; for (int i = -dist - 1; i &gt;= 0; i--) &#123; res[p--] = arr2[i]; &#125; &#125; else if (dist &gt; 0) &#123; // arr2短 for (int i = len2 - 1; i &gt;= 0; i--) &#123; res[p--] = arr1[i + dist] + arr2[i]; &#125; for (int i = dist - 1; i &gt;= 0; i--) &#123; res[p--] = arr1[i]; &#125; &#125; else &#123; for (int i = arr1.length - 1; i &gt;= 0; i--) &#123; res[p--] = arr1[i] + arr2[i]; &#125; &#125; // 处理进制 decimalism(res); // 再次考虑,当res[0]为0的情况 return filterZero(res);&#125;// 进制处理private void decimalism(int[] arr) &#123; // 处理进制 for (int k = arr.length - 1; k &gt; 0; k--) &#123; if (arr[k] &gt;= 10) &#123; arr[k - 1] += arr[k] / 10; arr[k] %= 10; &#125; &#125;&#125;// 处理数组arr首位为0的情况private int[] filterZero(int[] arr) &#123; if (arr[0] != 0) return arr; // 从头遍历arr,当出现第一个不为0的数字后,会变成true boolean flag = false; // 用来统计非0数字前面,0的个数 int k = 0; for (int i = 0; i &lt; arr.length &amp;&amp; !flag; i++) &#123; if (arr[i] != 0) flag = true; // 倘若还没有遇到第一个不为0的数字,计数+1 if (!flag) k++; &#125; // 比如[0,0,1,2,3],经过统计k=2,那么最终的finalRes长度应该是3 = arr.length - k int[] finalRes = new int[arr.length - k]; // 开始拷贝的位置下标应该是k System.arraycopy(arr, k, finalRes, 0, finalRes.length); return finalRes;&#125; 3. Strassen矩阵乘法 矩阵乘法，线性代数常见，假设两个矩阵同型AB，都是n×n的矩阵，C = AB，则在计算矩阵C时，C中每个元素都需要进行n次乘法和n-1次加法，最终求出C，n2个元素需要的计算时间复杂度是O(n3) 3.1 O(n3)写法 12345678910111213141516171819202122// 矩阵m1,a行b列;矩阵m2,c行d列public int[][] matrixMultiply(int[][] m1, int[][] m2) &#123; // m1的行数,m1的列数 int m1Col = m1.length, m1Row = m1[0].length; // m2的行数,m2的列数 int m2Col = m1.length, m2Row = m2[0].length; // 检查矩阵相乘的条件 if (m1Row != m2Col) throw new RuntimeException(&quot;矩阵无法相乘&quot;); // 新建一个存储结果的矩阵 int[][] res = new int[m1Col][m2Row]; // 遍历m1的第i行 for(int i = 0; i &lt; m1Col; i++) &#123; // 遍历m2的第j列 for(int j = 0; j &lt; m2Row; j++) &#123; // 遍历m2的第k行 for(int k = 0; k &lt; m2Col; k++) &#123; res[i][j] += m1[i][k] * m2[k][j]; &#125; &#125; &#125; return res;&#125; 3.2 分治思想 假设条件： 两个矩阵都是n×n n都是2的幂 4. 棋盘覆盖 5. 合并排序 其实就是归并排序，相关代码可以查看排序 6. 快速排序 相关代码可以查看排序 快速排序的运行时间与每次划分是否对称有关，划分的最坏情况就是一边1个元素，另一边n-1的元素，当每次都划分对称的时候，时间复杂度是O(nlogn)，当每次划分都最坏的时候，时间复杂度是O(n2)，在排序提到，对于快速排序来说，越有序越慢，因为越有序，每次划分出现最坏情况的可能性就越大。 为了尽可能每次划分都较为对称，可以采用随机选择策略的快速排序算法。快速排序对于基准的选择都是待排序序列的第一个元素，随机选择意思就是说，在进行快速排序之前，先从序列中随机挑一个元素与序列首位进行位置交换，这样快排时的基准就是随机的了。 123456789101112131415161718192021222324252627282930313233343536// 实现随机选择基准// (int)(Math.random()*(high - low + 1))范围：[0,high - low + 1)// (int)(Math.random()*(high - low + 1)) + low范围：[low,high + 1)，即[low, high]private int RandomizedPartition(int[] arr, int low, int high) &#123; // i是从low-high随机挑选出来的下标 int i = (int)(Math.random()*(high - low + 1)) + low; // 将i位置的元素与待排序范围的首位进行交换 int temp = arr[low]; arr[low] = arr[i]; arr[i] = temp; return QSort_Partition(arr, low, high);&#125;// 快速排序public void QSort(int[] arr, int low, int high) &#123; if (low &lt; high) &#123; int piovtpos = RandomizedPartition(arr, low, high); // 排左边 QSort(arr, low, piovtpos - 1); // 排右边 QSort(arr, piovtpos + 1, high); &#125;&#125;// 一趟快速排序// 参数1：数组,参数2：数组的起始位置,参数3：数组的终了位置,闭区间private int QSort_Partition(int[] arr, int left, int right) &#123; // 指定基准 int base = arr[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; arr[right] &gt;= base) right--; if (left &lt; right) arr[left] = arr[right]; while (left &lt; right &amp;&amp; arr[left] &lt; base) left++; if (left &lt; right) arr[right] = arr[left]; &#125; arr[left] = base; return left;&#125; 7. 线性时间选择 给定一串数字，从中选出第k小，时间复杂度要求是O(n)，即线性时间选择。 7.1 利用堆排序获得第k小 易知，倘若要知道第k小的关键字，那么只需要利用小根堆，进行k次堆调整，即可得到第k小的关键字。 其中adjustHeap函数的代码可见排序，其中adjustHeap函数是调整成大根堆，只需要将循环中两个if判断条件中的小于号改成大于号，即可实现调整为小根堆的功能 123456789101112131415161718public int heapSortFindK(int[] arr, int k) &#123; // 存储arr,目的是堆排序过程中不改变原数组 int[] temp = arr.clone(); int len = temp.length; // 首先构建小根堆 for (int pos = len / 2 - 1; pos &gt;= 0; --pos) &#123; //从第一个非叶子结点从下至上，从右至左调整结构 adjustHeap(temp, pos, len); &#125; // 经过上一步可以得到小根堆,现在开始排序 for (int j = len - 1; j &gt;= len - k; --j) &#123; //将堆顶元素与末尾元素进行交换 swap(temp, 0, j); //重新对堆进行调整 adjustHeap(temp, 0, j); &#125; return temp[len - k];&#125; 7.2 利用快速排序获得第k小 每一次快排都会选则一个基准，将其排到它的最终位置，而第k小在排好序的序列中排在第k位。所以，可以通过比较每次快排后基准的最终位置与k，来获取第k小 1234567891011121314public int QSortFindK(int[] arr, int k, int start, int end) &#123; // 首先,一趟快速排序,确定一个关键字的最终位置 int piovtpos = QSort_Partition(arr, start, end); // 易知，为了使快速排序的效率变高，可以利用上述随机策略法。 // int piovtpos = RandomizedPartition(arr, start, end); if(piovtpos + 1 == k) // 倘若该数字正好是第k小 return arr[piovtpos]; else if(piovtpos + 1 &gt; k) &#123; // 说明目标在该数字的左边 return QSortFindK(arr, k, start, piovtpos - 1); else return QSortFindK(arr, k, piovtpos + 1, end);&#125; 8. 最接近点对问题 平面中有n个点，求出哪两个点之间的距离是最短的。很容易想到O(n2)的写法，倘若利用分治法，可以将时间复杂度降低为O(nlog2n) 9. 循环赛日程表","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"算法设计与分析","slug":"算法/算法设计与分析","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"}],"tags":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"分治法","slug":"分治法","permalink":"blog.silverbeats.cn/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"}],"author":"silverbeats"},{"title":"最短路径","slug":"最短路径","date":"2020-09-19T01:53:19.000Z","updated":"2020-09-29T05:13:51.006Z","comments":true,"path":"最短路径/","link":"","permalink":"blog.silverbeats.cn/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/","excerpt":"","text":"1. 迪杰斯特拉Dijkstra算法详解 1.1 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public void Dijkstra(int[][] graph, int start) &#123; // 当起点无法达到该点时,路径长度是无穷大,这里用整型最大值代替 int MAXDIST = Integer.MAX_VALUE; int vertexNum = graph.length; /* * 1. Dijkstra算法需要三个辅助数组 **/ boolean[] isVisited = new boolean[vertexNum]; int[] path = new int[vertexNum]; int[] dist = new int[vertexNum]; /* * 2. 初始化 **/ for (int i = 0; i &lt; vertexNum; i++) &#123; dist[i] = graph[start][i]; if (graph[start][i] &lt; MAXDIST) &#123; path[i] = start; &#125; else &#123; path[i] = -1; &#125; &#125; // start起点默认已经被访问 isVisited[start] = true; // start没有前驱结点,因为它是开始的位置 path[start] = -1; /* * 3. 迪杰斯特拉算法核心 **/ for (int i = 0; i &lt; vertexNum - 1; i++) &#123; // 存储最短路径 int minPath = MAXDIST; // 存储距离最小的点的数组下标 // 倘若这里minIndex不赋初始值,在后面isVisited[minIndex] = true会报错 // 因为后面的循环找最小值可能找不到 int minIndex = start; // 这个循环目的是:从未访问的节点中找到路径最短的那个 for (int j = 0; j &lt; vertexNum; j++) &#123; // 倘若这个节点没有访问,并且该点小于最短路径 if (!isVisited[j] &amp;&amp; dist[j] &lt; minPath) &#123; minPath = dist[j]; minIndex = j; &#125; &#125; if (minIndex != start) isVisited[minIndex] = true; for (int j = 0; j &lt; vertexNum; j++) &#123; if (!isVisited[j] &amp;&amp; graph[minIndex][j] != MAXDIST &amp;&amp; dist[minIndex] + graph[minIndex][j] &lt; dist[j] &amp;&amp; minIndex != start) &#123; dist[j] = dist[minIndex] + graph[minIndex][j]; path[j] = minIndex; &#125; &#125; &#125;&#125; 1.2 分段解读 1.2.1 完整过程图示 1.2.2 辅助数组说明 123456789// 用来记录每个节点是否被访问boolean[] isVisited = new boolean[vertexNum];// 用来存储到达某个点最短路径的前一个节点下标// 比如上图第1次循环,到达顶点4的最短路径是0-2-4,那么path[4]存放下标2// 这个数组的每个值会不断变动int[] path = new int[vertexNum];// 存放到某个顶点的最短路径长度// 比如顶点4,dist[4]从8,最后修改成7,这个数组的每个值会不断变动int[] dist = new int[vertexNum]; 1.2.3 初始化说明 1234567891011121314151617for (int i = 0; i &lt; vertexNum; i++) &#123; dist[i] = graph[start][i]; // 这一步其实可以不用,声明boolean数组时默认就是false // isVisited[i] = false; // start点到i有路径,这里面包含了start自己到自己 // path[start]=start,这是不对的,start没有前驱节点,应该存-1,循环结束之后会做处理 if (graph[start][i] &lt; MAXDIST) &#123; path[i] = start; &#125; else &#123; // 没有前驱节点的意思,当前以start为起点,到不了i这个点 path[i] = -1; &#125;&#125;// start起点默认已经被访问isVisited[start] = true;// start没有前驱结点,因为它是开始的位置path[start] = -1; 1.2.4 算法核心说明 12345678910111213141516171819202122232425for (int i = 0; i &lt; vertexNum; i++) &#123; // 存储最短路径 int minPath = MAXDIST; // 存储距离最小的点的数组下标 // 倘若这里minIndex不赋初始值,在后面isVisited[minIndex] = true会报错 // 因为后面的循环找最小值可能找不到 int minIndex = start; // 这个循环目的是:从未访问的节点中找到路径最短的那个 for (int j = 0; j &lt; vertexNum - 1; j++) &#123; // 倘若这个节点没有访问,并且该点小于最短路径 if (!isVisited[j] &amp;&amp; dist[j] &lt; minPath) &#123; minPath = dist[j]; minIndex = j; &#125; &#125; if (minIndex != start) isVisited[minIndex] = true; for (int j = 0; j &lt; vertexNum; j++) &#123; if (!isVisited[j] &amp;&amp; graph[minIndex][j] != MAXDIST &amp;&amp; dist[minIndex] + graph[minIndex][j] &lt; dist[j] &amp;&amp; minIndex != start) &#123; dist[j] = dist[minIndex] + graph[minIndex][j]; path[j] = minIndex; &#125; &#125;&#125; 内层循环第一个for比较简单，目的是找到一个点，该点满足：①未被访问，②有路径能访问，③到达改点路径值最小 内层循环第二个详解见下图： ❥(^_-)Tip： 当你使用某个数据类型的最大值作为无穷大，表示无该路径时，需要注意dist[minIndex] + graph[minIndex][j] &lt; dist[j]，倘若graph[minIndex][j]是无穷大，再加上一个数字后，会超出该类型的表示范围，变成一个负数，从而达成这个判断条件，执行if代码块中语句。这并不是我们想要的。所以需要在if中需要添加graph[minIndex][j] != MAXDIST这句话，避免上述情况发生 1.3 思考 首先，迪杰斯特拉算法能解决单源并且没有负权值边的最短路径问题，那么倘若出现负权值边，该算法不能求解出最短路径的原因是什么 1.3.1 尝试一下 当把1-&gt;2的权值改为-3后，继续走一遍之前的代码，就可以发现问题。 当i = 1时，即第二次循环，此时的minIndex为1，当j = 2时，根据if条件，因为isVisited[2]是之前访问过的点，所以不会执行if语句块中的代码，即便dist[minIndex] + graph[minIndex][j] &lt; dist[j]，5 + (-3) &lt; 3 那么倘若if中没有!isVisited[j]这个判断是否就可以了呢？ 根据上图，可以看到path数组是没有问题的，但是问题出在了dist[4]上。dist[4]应该为6，但却是7，这里是因为什么原因导致的？ 手动模拟一遍过程后不难发现，i=0的第一次循环修改了dist[4]和path[4]；在i=1的第二次循环，到达节点2的最短路径发生变化，但是没有任何的机会去修改以2为前驱的点的dist数组。 所以在第二个for循环中再添加一个循环，倘若某个点x的最短路径发生变化，去找以x为前驱的其他点y，看看y这个点的最短路径有没有因为x的变化而缩短。 12345678910111213for (int j = 0; j &lt; vertexNum; j++) &#123; if (graph[minIndex][j] != MAXDIST &amp;&amp; dist[minIndex] + graph[minIndex][j] &lt; dist[j] &amp;&amp; minIndex != start) &#123; dist[j] = dist[minIndex] + graph[minIndex][j]; path[j] = minIndex; // 在遍历一遍path数组 for(int k = 0; k &lt; vertexNum; k++) &#123; // 如果path数组的某个点的前驱节点正好是修改长度的点的话 if(path[k] == j &amp;&amp; dist[k] &gt; dist[j] + graph[j][k]) &#123; dist[k] = dist[j] + graph[j][k]; &#125; &#125; &#125;&#125; 之后的结果就没有问题了： 2. 弗洛伊德Floyd算法详解 其实倘若涉及到负权值，会选择用Floyd算法，而且，更为强大的是，Floyd能够求出各个顶点到其他点的最短距离。 我不能呼吸了……= = 2.1 完整代码 123456789101112131415161718public void Floyd(int[][] graph) &#123; int vertexNum = graph.length; // path数组,用来存储路径 int[][] path = new int[vertexNum][vertexNum]; // 初始化 for (int i = 0; i &lt; vertexNum; i++) &#123; for(int j = 0; j &lt; vertexNum; j++) path[i][j] = -1; &#125; for(int i = 0; i &lt; vertexNum; i++) &#123; for(int j = 0; j &lt; vertexNum; j++) &#123; for(int k = 0; k &lt; vertexNum; k++) &#123; if(graph[j][i] == Integer.MAX_VALUE || graph[i][k] == Integer.MAX_VALUE) continue; int temp = graph[j][i] + graph[i][k]; if(graph[j][k] &gt; temp) graph[j][k] = temp; &#125; &#125; &#125;&#125; 举例：顶点0到4的最短路径 graph(0,4)的数字是6，说明最短路径长度是6，那么该怎么走呢。这是需要看path数组 path(0,4)为2，说明想要到顶点4需要经过顶点2，路径0-&gt;2-&gt;4，此时再看path(0,2)为1，说明想要从0到2需要经过顶点1，路径变为0-&gt;1-&gt;2-&gt;4 关于代码的详细描述过程，见文章：Floyd-傻子也能看懂的弗洛伊德算法（转）","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"最短路径","slug":"最短路径","permalink":"blog.silverbeats.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"blog.silverbeats.cn/tags/Dijkstra/"},{"name":"Floyd","slug":"Floyd","permalink":"blog.silverbeats.cn/tags/Floyd/"}],"author":"silverbeats"},{"title":"hexo相关命令语法","slug":"hexo相关命令语法","date":"2020-09-17T04:44:15.000Z","updated":"2020-09-20T00:03:02.202Z","comments":true,"path":"hexo相关命令语法/","link":"","permalink":"blog.silverbeats.cn/hexo%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E8%AF%AD%E6%B3%95/","excerpt":"","text":"1. 相关命令 12345678910111213141516171819202122232425#初始化一个hexo博客hexo init blog#创建新页面hexo new page 页面名#清理之前生成的旧文件hexo clean#重新生成静态文件 下面是简写hexo generatehexo g#本地预览 下面是简写hexo serverhexo s#合并写法hexo clean | hexo g | hexo s#通过git提交到仓库,需要配置hexo项目的_config.yml文件hexo deployhexo d#当安装七牛云同步插件后,可以通过如下命令将hexo根目录下的static文件夹同步到七牛云hexo qiniu sync#或者hexo qiniu s#或者hexo qiniu sync2#或者hexo qiniu s2 2. 引用站内文章 1&#123;% post_link 文章文件名（不要后缀） 文章标题（可选） %&#125; 3. 引用图片 3.1 引用七牛云图片 1&#123;% qnimg 图片.格式 alt:这是图片 title:这是图片 %&#125; 不过这种方式引用图片，还是相当于本地存储，之后引用的图片会出现在需要上传的public目录中，还是会占用空间。 3.2 引用本地图片 倘若hexo项目的配置文件中将post_asset_folder设置为true，可以通过以下方式来引入图片，需要将example放入source/_post下的文章同名文件夹下。 1234&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125;&#123;% asset_img example.jpg This is an example image %&#125;","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"blog.silverbeats.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"blog.silverbeats.cn/tags/hexo/"}],"author":"silverbeats"},{"title":"排序","slug":"排序","date":"2020-09-16T14:17:31.000Z","updated":"2020-09-29T05:14:55.462Z","comments":true,"path":"排序/","link":"","permalink":"blog.silverbeats.cn/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"1. 插入排序 1.1 直接插入排序 直接插入排序，思想较为简单。 可以类比平常打扑克抓牌的过程。每次抓一张牌时，都会将这张牌与之前手里的牌（之前手里的牌是有序的）进行比较（从左向右比，或者从右向左比），得到一个最终的插入位置，然后插入。 12345678910111213141516171819// 直接插入排序, 假定前面是有序的，从乱序的后面取一个数插入有序的前面public void insertSort(int[] arr) &#123; int len = arr.length; if (len == 0 || len == 1) return; // 进行插入排序 for (int i = 1; i &lt; len; i++) &#123; for (int j = i; j &gt; 0; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; swap(arr, j, j - 1); &#125; &#125; &#125;&#125;// 交换private void swap(int[] arr, int a, int b) &#123; int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp;&#125; 上面的代码可以再简化一下： 12345678910// 直接插入排序, 假定前面是有序的，从乱序的后面取一个数插入有序的前面public void insertSort(int[] arr) &#123; int len = arr.length; if (len == 0 || len == 1) return; // 进行插入排序 for (int i = 1; i &lt; len; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j - 1]; j--) swap(arr, j, j - 1); &#125;&#125; 1.2 折半插入排序 直接插入排序确定位置是通过将待排序的元素，与前面有序的序列一个个比较过去，从而得到最终的插入位置。那么，因为是顺序存储，利用数组实现排序，可以对前面的有序序列使用折半查找来确定最终插入位置。 12345678910111213141516171819202122232425public void binaryInsertSort(int[] arr) &#123; int len = arr.length; if (len == 0 || len == 1) return; // low high mid用于折半查找 int low, high, mid; for (int i = 1; i &lt; arr.length; i++) &#123; low = 0; high = i - 1; while (low &lt;= high) &#123; // (high+low)/2 这样的写法可能会超出int的表示范围 mid = low + ((high - low) &gt;&gt; 1); if (arr[mid] &lt; arr[i]) low = mid + 1; else high = mid - 1; &#125; // high + 1就是插入的位置 int temp = arr[i]; // 找到插入位置后,对元素进行挪动 for (int j = i - 1; j &gt; high; j--) arr[j + 1] = arr[j]; // 将待排序的元素插入找到的位置 arr[high + 1] = temp; &#125;&#125; 1.3 希尔排序 希尔排序又称为缩小增量排序，当增量为1时，其实就是直接插入排序。增量的选取一般两种方案： 希尔提出，对数组长度不断折半。比如数组长度是32，则增量dk分别是：16,8,4,2,1 帕佩尔诺夫和斯塔舍维奇提出，dk = 2k + 1，dk &lt; 数组长度，k ≥ 0。比如数组长度是32，此时k 只能从4开始，则k = 4，dk = 17；k = 3，dk = 9；k = 2，dk = 5；k = 1，dk = 3；此时还需要额外添加dk = 1，算是一个兜底作用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 希尔排序public int[] shellSort(int[] arr) &#123; int len = arr.length; if (len == 0 || len == 1) return arr; int dk = len &gt;&gt; 1; while (dk != 0) &#123; shell_InsertSort(arr, dk); // shell_BinaryInsertSort(arr, dk); dk = dk &gt;&gt; 1; &#125; return arr;&#125;/** * @Title: shell_InsertSort * @Description: 希尔排序，直接插入法进行排序 * @param ar: 数组 * @param dk: 间隔 * @return: void */private void shell_InsertSort(int[] arr, int dk) &#123; int len = arr.length; int i, j; for (i = dk; i &lt; len; i++) &#123; int temp = arr[i]; for (j = i - dk; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= dk) &#123; arr[j + dk] = arr[j]; arr[j] = temp; &#125; &#125;&#125;/** * @Title: shell_BinaryInsertSort * @Description: 希尔排序，折半插入法进行排序 * @param arr: 数组 * @param dk: 间隔 * @return: void */private void shell_BinaryInsertSort(int[] arr, int dk) &#123; int i, j, high, low, mid, temp; for (i = dk; i &lt; arr.length; i++) &#123; low = i % dk; high = i - dk; while (low &lt;= high) &#123; mid = low + (high - low) / 2; if (arr[mid] &lt; arr[i]) low = mid + dk; else high = mid - dk; &#125; temp = arr[i]; // high + dk 即为插入的位置 for (j = i - dk; j &gt; high; j -= dk) arr[j + dk] = arr[j]; arr[high + dk] = temp; &#125;&#125; 后面那个通过折半插入法进行排序纯属练手，效率远远不及直接插入法希尔排序 前者，规模1W，20次，19ms 前者，规模10W，20次，187ms 后者，规模1W，20次，129ms 后者，规模10W，20次，10761ms 估计是在dk较小的时候，序列基本有序，折半插入的话是不管有没有序都得比较那么多次，而直接插入是越有序越快。 2. 选择排序 2.1 堆排序 堆又分大根堆和小根堆，倘若要升序，选择大根堆，倘若要降序，选择小根堆。 大根堆：根节点的数字不小于左右孩子的值 小根堆：根节点的值不大于左右孩子的值 堆排序是把一个数组，看做是一颗完全二叉树，排序步骤： 先对乱序的数组建立大根堆，可以得到数组的第一个元素（看做完全二叉树的话就是根节点）就是最大的 将其与数组最后面的那个值交换，然后重新调整，变为大根堆 依次类推 1234567891011121314151617181920212223242526272829303132333435363738394041// 堆排序public void heapSort(int[] arr) &#123; // 首先构建大根堆 for(int pos = arr.length/2 - 1; pos &gt;= 0; --pos) &#123; //从第一个非叶子结点从下至上，从右至左调整结构 adjustHeap(arr, pos, arr.length); &#125; // 经过上一步可以得到大根堆,现在开始排序 for(int j = arr.length - 1; j &gt; 0; --j) &#123; //将堆顶元素与末尾元素进行交换 swap(arr,0, j); //重新对堆进行调整 adjustHeap(arr,0, j); &#125;&#125;// 调整为大根堆// arr是要调整的数组, i是要调整的数组下标, length是调整的范围private void adjustHeap(int[] arr, int pos, int length) &#123; // 临时存储被调整的数组数据 int temp = arr[pos]; // pos是被调整元素的数组下标, 2*pos+1 是其左孩子 2*pos + 2是其右孩子 for(int i = pos*2 + 1; i &lt; length; i = i*2 + 1) &#123; /* 前面的判断条件保证它的右孩子是无序的, 在堆排序过程中会将最大值不断放到后面, length就是限制条件,可以通过这个条件让有序的右孩子不被波及 这个if保证i的下标对应的值是两个孩子中最大的那一个 */ if(i + 1 &lt; length &amp;&amp; arr[i] &lt; arr[i + 1]) &#123; i++; &#125; // 如果根节点小于它的孩子,则交换 if(temp &lt; arr[i]) &#123; // 交换根节点和它孩子的值 swap(arr, pos, i); // 因为经过了调整,当被调整的节点挪了位置,可能会导致后面的序列出问题,所以需要让pos定到i这个位置 pos = i; &#125; else &#123; break; &#125; &#125;&#125; 2.2 简单选择排序 思路简单：每次选择最大排到后面，或者每次选择最小的排到最前面 123456789101112public void selectSort(int[] arr) &#123; // 每次过滤一遍数组将最小值放到前面 int i, j, min; for (i = 0; i &lt; arr.length - 1; i++) &#123; min = i; // 假定第i个位置最小 for (j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) min = j; &#125; if (i != min) swap(arr, i, min); &#125;&#125; 下面是另外一种做法，是每次将最小的放到最前面，最大的放到最后面 12345678910111213141516171819public void selectSort_2(int[] arr) &#123; // 每次过滤一遍数组将最小值放到前面 // 将最大的数字放到最后面 int i, j, min, max, lastPos; for (i = 0; i &lt;= arr.length &gt;&gt; 1; i++) &#123; min = max = i; lastPos = arr.length - i - 1; for (j = i + 1; j &lt;= lastPos; j++) &#123; if (arr[j] &lt; arr[min]) min = j; if (arr[j] &gt; arr[max]) max = j; &#125; if (i != min) swap(arr, i, min); if (lastPos != max) swap(arr, max, lastPos); &#125;&#125; 前者，规模10W，20次，54408ms，2720ms/次 后者，规模10W，20次，53938ms，2697ms/次 呵呵…… 简单选择排序有两个版本，一种是如同上面的两种写法一样，将最大值（最小值）与序列最后（第一）个进行调换位置，这个版本成为交换版 另一种版本是将最大值（最小值）插入到序列的最后（最前）面，成为插入版。 区别在于： 交换版不稳定，插入版稳定 倘若序列顺序存储，插入版会涉及到大批量的元素挪动，不如交换版来的划算 倘若序列是链式存储，插入版会划算一些 3. 交换排序 3.1 冒泡排序 冒泡排序很经典，每次排序都能讲最大的数字排到最后，或者将最小的数字排到最前面 听说冒泡是毒瘤，比较次数和交换次数超级多 12345678910111213141516public int[] bubbleSort(int[] arr) &#123; int len = arr.length; if (len == 0 || len == 1) return arr; for (int i = 0; i &lt; len; i++) &#123; // 倘若内循环没有进行交换,则整个序列有序,会直接终止整个排序,是一个优化的地方 boolean flag = false; for (int j = 0; j &lt; len - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; swap(arr, j, j + 1); flag = true; &#125; &#125; if (!flag) break; &#125; return arr;&#125; 继续发挥，双向冒泡 1234567891011121314151617181920212223242526// 双向冒泡public void bubble2Ways(int[] arr) &#123; int left = 0, right = arr.length - 1; boolean flag; while(left &lt; right) &#123; flag = false; // 从左往右将最大的数字挪到最右边 for(int i = left; i &lt; right; ++i) &#123; if(arr[i] &gt; arr[i + 1])&#123; swap(arr, i, i + 1); flag = true; &#125; &#125; // 挪到结束后right-- --right; // 从右往左将最小的数字挪到最左边 for(int j = right; j &gt; 0; --j) &#123; if(arr[j] &lt; arr[j - 1])&#123; swap(arr, j, j - 1); flag = true; &#125; &#125; ++left; if(!flag)break; &#125;&#125; 前者，规模1W，20次，1362ms，68ms/次 后者，规模1W，20次，1445ms，72ms/次 前者，规模10W，20次，303042ms，5min，15152ms/次 后者，规模10W，20次，202945ms，3min23s，10147ms/次 ……还是有点提高的 3.2 快速排序 利用分而治之的思想。每一次快速排序会实现这样的结果： 该数字的左边都比它小 该数字的右边都不小于它 每一次排序都会确定一个数的最终位置 123456789101112131415161718192021222324// 快速排序public void QSort(int[] arr, int low, int high) &#123; if (low &lt; high) &#123; int piovtpos = this.QSort_Partition(arr, low, high); // 排左边 QSort(arr, low, piovtpos - 1); // 排右边 QSort(arr, piovtpos + 1, high); &#125;&#125;// 一趟快速排序// 参数1：数组,参数2：数组的起始位置,参数3：数组的终了位置,闭区间private int QSort_Partition(int[] arr, int left, int right) &#123; // 指定基准 int base = arr[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; arr[right] &gt;= base) right--; if (left &lt; right) arr[left] = arr[right]; while (left &lt; right &amp;&amp; arr[left] &lt; base) left++; if (left &lt; right) arr[right] = arr[left]; &#125; arr[left] = base; return left;&#125; 平均时间复杂度为nlogn的算法中，如：堆排序，快速排序，希尔排序，归并排序中，快速排序前面系数最小 规模1W，20次，15ms 规模10W，20次，359ms 快速排序有其特点：越有序越慢，越无序越快 4. 二路归并排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @Title: mergeSort * @Description: 归并排序 * @param arr: int类型数组 * @return: void */public void mergeSort(int[] arr, int leftStart, int rightBound) &#123; if(leftStart == rightBound)return; if(leftStart &gt; rightBound || leftStart &lt; 0 || rightBound &lt; 0)throw new RuntimeException(&quot;error&quot;); int mid = leftStart + ((rightBound - leftStart) &gt;&gt; 1); mergeSort(arr,leftStart,mid); mergeSort(arr,mid+1,rightBound); merge(arr, leftStart, mid+1, rightBound);&#125;/** * @Title: merge * @Description:一次归并,将两个有序的数组合并，仍有序 * @param arr 数组 * @param leftStart 第一个数组的左边界开始的位置 * @param rightStart 第二个数组的左边界开始的位置 * @param rightBound 第二个数组的右边界结束的位置 * @return: void */private void merge(int[] arr, int leftStart, int rightStart, int rightBound) &#123; // 合并思想：新建一个数组，每次将小的数字放到新建的数组中 int i = leftStart, j = rightStart, k = 0; int[] tempArr = new int[rightBound - leftStart + 1]; while(i &lt; rightStart &amp;&amp; j&lt;= rightBound) tempArr[k++] = arr[i] &lt;= arr[j]?arr[i++]:arr[j++]; // 倘若还有剩余 while(i &lt; rightStart) tempArr[k++] = arr[i++]; while(j &lt;= rightBound) tempArr[k++] = arr[j++]; // 此时tempArr就是合并好有序的数组，对原始数组进行覆盖 for(int p = leftStart; p &lt;= rightBound; p++) arr[p] = tempArr[p - leftStart]; // 对原数组进行覆盖可以使用System.arraycopy,可以提高效率 /* if (i &lt; rightStart) &#123; System.arraycopy(arr, i, tempArr, k, rightStart - i); k += (rightStart - i); &#125; if (j &lt;= rightBound) &#123; System.arraycopy(arr, j, tempArr, k, rightBound - j + 1); &#125; System.arraycopy(tempArr, 0, arr, leftStart, tempArr.length); */&#125; 规模1W，20次，32ms 规模10W，20次，241ms 5. 桶排序 5.1 基数排序 5.1.1 完整代码（只适用于非负数） 1234567891011121314151617181920212223242526272829303132// 基数排序public void radixSort(int[] arr) &#123; int len = arr.length; int arrMax = getMinMax(arr)[1]; // 从个位开始,对数组进行排序 // exp = 1, 按照个位 // exp = 10, 按照十位 // exp = 100, 按照百位 for (int exp = 1; arrMax / exp &gt; 0; exp *= 10) &#123; int i; // 存储被排序数组的临时数组 int[] output = new int[arr.length]; // 桶,因为不管是什么数字,个数十位不管是哪一位,都是0-9，所以桶数组的长度是10 int[] buckets = new int[10]; // 将数据出现的次数进行统计 for (i = 0; i &lt; len; i++) &#123; buckets[(arr[i] / exp) % 10]++; &#125; // 转为累加数组。目的是让更改后的buckets[i]的值，是该数据在output中的位置 for (i = 1; i &lt; 10; i++) &#123; buckets[i] += buckets[i - 1]; &#125; // 将数据存储到临时数组output中 for (i = len - 1; i &gt;= 0; i--) &#123; output[buckets[(arr[i] / exp) % 10] - 1] = arr[i]; buckets[(arr[i] / exp) % 10]--; &#125; // 将排序好的数组赋值给arr for (i = 0; i &lt; len; i++) arr[i] = output[i]; &#125;&#125; 5.1.2 分段说明 分段说明举例说明的乱序数组为：{53, 3, 542, 748, 14, 214, 154, 63, 616}，为了更好的说明过程，for循环的说明将会以个位排序，演示整个过程 5.1.2.1 外层循环 arrMax是整个数组中最大的数字，同时也是位数最多的那个数字，比如arrMax是748，那么需要进行3次循环，分别对整个数组的个位，十位，百位来进行排序，故，外层循环的次数是由arrMax的位数来决定的。 123for (int exp = 1; arrMax / exp &gt; 0; exp *= 10) &#123; …… &#125; exp = 1，arrMax = 748/1 = 748&gt; 0，对个位进行排序 exp = 10，arrMax = 748/10 = 74 &gt; 0，对十位进行排序 exp = 100，arrMax = 748/100 = 8 &gt; 0，对百位进行排序 exp = 1000，arrMax = 748/1000 = 0 &gt; 0，false，中止外层循环 5.1.2.2 内部循环两个辅助数组的作用 首先，先来看一下，我们熟知的基数排序的过程： 很清楚能知道，其中一个辅助数组为buckets长度为10，即为上面的桶。但问题是，模拟的时候，是将每个数字放入桶中，然后取出的顺序是放入的先后顺序一致，颇有一种每个桶里面放的都是一个队列，先进先出，这样想倒是很符合，很自然，可以声明一个Object[]数组，之后每个位置存储一个队列，队列不需要自己实现，可以使用java.util包下的Queue实现类，之后操作就比较简单了，完全就和手动模拟的过程是一致的。（倘若用C语言，这样想能恶心死你= =） 但上面这种考虑虽然简单，但空间复杂度肯定是小不了的，这里给出的是另外一种比较巧妙的解决方案。可见后面更为详细的过程图。 1234// 存储被排序数组的临时数组int[] output = new int[arr.length];// 桶,因为不管是什么数字,个数十位不管是哪一位,都是0-9，所以桶数组的长度是10int[] buckets = new int[10]; 5.1.2.3 内部四for第一for: 将数据出现的次数进行统计 (arr[i]/exp)%10的目的是要获得目标位置的数字。 首先，将需要的那一位变为个位，比如214，想要取得十位1，此时的exp = 10，先要除exp，得到21，这样想要的十位数字1就挪到了个位，之后让21 % 10，即可得到想要的十位数字1 这里的for循环其实目的是统计每个数字的exp位（exp = 1 表示每个数字的个位，exp = 10 表示每个数字的十位……）出现的次数。 123for (i = 0; i &lt; len; i++) &#123; buckets[(arr[i] / exp) % 10]++;&#125; 以个排序演示完整过程，出现次数：为待排序数组，每个数字的个位出现的次数 5.1.2.4 内部四for第二for: 转为累加数组 1234// 转为累加数组。目的是让更改后的buckets[i]的值，是该数据在output中的位置for (i = 1; i &lt; 10; i++) &#123; buckets[i] += buckets[i - 1];&#125; 这个累加数组中的值，就代表了每个数字最终应该存储的位置。比如53这个数字，当按照个位排完序，应该在哪里？ 首先，我们应该能想到应该要遍历待排序数组，然后按照某种规则放入用来临时存储的output数组中。那么问题来了，应该正向遍历，还是逆向遍历？ 假设是正向遍历，遍历到每个数字都需要考虑一些问题： 有多少个数字在我前面 和我拥有相同的个位，有多少个，还有多少个没有被安排进临时数组 比如，第一个数字53，首先，获取53的个位数字3，对应到buckets数组中发现buckets[3] = 4，说明最后一个个位为3的数字应该排在第四个。通过buckets[2] = 1，说明能排在个位3前面的数字只有1个，能推出，在最后的排序结果中，以3为个位的数字应该排在序列的第2,3,4位置。问题来了，如何确定到底是那个位置，同时还要保证相同个位的数字之间相对位置不变。 假设是逆序，它天然就能保证在最终结果序列中，相同个位之间相对顺序不变。比如063。 buckets[3] = 4，让063排第4位，buckets[3] = 3 buckets[3] = 3，让003排第3位，buckets[3] = 2 buckets[2] = 2，让053排第2位，buckets[3] = 1 这个逻辑写起来就会很轻松。 5.1.2.5 内部四for第三for: 将数据存储到临时数组output中 这里是整个排序中最不好懂的一部分。但是当你看到上面的说明，这里就会比较容易去理解。为了方便理解，将源代码中的两行代码拆分。 12345678910111213 // 将数据存储到临时数组output中for (i = len - 1; i &gt;= 0; i--) &#123; // 获取这个数字的exp位 int pos = (arr[i] / exp) % 10; // 对应到buckets数组 int b = buckets[pos]; // 数组下标从0开始,需要减1,才是arr[i]应该存储的地方 output[--b] = arr[i]; // 让桶的数字自减 buckets[pos]--; //output[buckets[(arr[i] / exp) % 10] - 1] = arr[i]; //buckets[(arr[i] / exp) % 10]--;&#125; 第1次：616，获取个位6，buckets[6] = 8，需要减1才是存放处，output[8 - 1] = 616，桶的数字减1，buckets[6] = 7 第2次：063，获取个位3，buckets[3] = 4，需要减1才是存放处，output[4 - 1] = 063，桶的数字减1，buckets[3] = 3 第3次：154，获取个位4，buckets[4] = 7，需要减1才是存放处，output[7 - 1] = 154，桶的数字减1，buckets[4] = 6 第4次：214，获取个位4，buckets[4] = 6，需要减1才是存放处，output[6 - 1] = 124，桶的数字减1，buckets[4] = 5 第5次：014，获取个位4，buckets[4] = 5，需要减1才是存放处，output[5 - 1] = 014，桶的数字减1，buckets[4] = 4 第6次：748，获取个位8，buckets[8] = 9，需要减1才是存放处，output[9 - 1] = 748，桶的数字减1，buckets[8] = 8 第7次：542，获取个位2，buckets[2] = 1，需要减1才是存放处，output[1 - 1] = 542，桶的数字减1，buckets[2] = 0 第8次：003，获取个位3，buckets[3] = 3，需要减1才是存放处，output[3 - 1] = 003，桶的数字减1，buckets[3] = 2 第9次：053，获取个位3，buckets[3] = 2，需要减1才是存放处，output[2 - 1] = 053，桶的数字减1，buckets[3] = 1 5.1.3 完整代码（适用于负数） 1234567891011121314151617181920212223242526272829303132public void radixSort(int[] arr) &#123; int len = arr.length; if(len == 1 ||len == 0) return; int[] temp = getMinMax(arr); // 应该是位数最多的那一个 int arrMax = Math.max(Math.abs(temp[0]), Math.abs(temp[1])); for (int exp = 1; arrMax / exp != 0; exp *= 10) &#123; int i; // 存储被排序数组的临时数组 int[] output = new int[len]; // 桶,因为要考虑负数,桶编号从-9~9,，所以桶数组的长度是19 int[] buckets = new int[19]; // 将数据出现的次数进行统计,其中buckets数组下标0-8代表-9~-1,下标9代表0,10-18代表1-9 for (i = 0; i &lt; len; i++) &#123; //获取这一位 int bit = arr[i]/exp % 10; buckets[bit + 9]++; &#125; // 转为累加数组。目的是让更改后的buckets[i]的值，是该数据在output中的位置 for (i = 1; i &lt; buckets.length; i++) &#123; buckets[i] += buckets[i - 1]; &#125; // 将数据存储到临时数组output中 for (i = len - 1; i &gt;= 0; i--) &#123; output[buckets[(arr[i] / exp) % 10 + 9] - 1] = arr[i]; buckets[(arr[i] / exp) % 10 + 9]--; &#125; // 将排序好的数组赋值给arr for (i = 0; i &lt; len; i++) arr[i] = output[i]; &#125;&#125; 首先和上面不包含负数的基数排序相比，变动的地方如下： arrMax 12int[] temp = getMinMax(arr);int arrMax = Math.max(Math.abs(temp[0]), Math.abs(temp[1])); 实际上，arrMax的意义其实没有变化，都指的是这一串数字当中位数最多的那个数字，至于是正的还是负的，这无所谓，只要它位数最多。 所以，倘若这串数字包含负数，在获取位数最多的那个数字，可以这样获取。 其中getMinMax是获取arr中的最小值和最大值，返回值{min，max} 桶数组大小变动 12345678910111213int[] buckets = new int[19];// 将数据出现的次数进行统计,其中buckets数组下标0-8代表-9~-1,下标9代表0,10-18代表1-9for (i = 0; i &lt; len; i++) &#123; //获取这一位 int bit = arr[i]/exp % 10; buckets[bit + 9]++;&#125;……// 将数据存储到临时数组output中for (i = len - 1; i &gt;= 0; i--) &#123; output[buckets[(arr[i] / exp) % 10 + 9] - 1] = arr[i]; buckets[(arr[i] / exp) % 10 + 9]--;&#125; 因为要考虑到负数，应该有：-9，-8，-7，-6，……，0，1，2，……，9共计19个桶 因为数组下标是从0开始的，所以在第一个计数的for循环，当在得到该数字的某一位时，需要+9 同时在第三个for循环，在获取某个桶的值的时候，也需要+9 5.2 计数排序 利用桶，空间换时间，在面对在一定范围内的大量重复数字的场景下，很适用。 比如一个省的高考成绩排名，可以声明一个长度为751的计数数组，其数组下标为0-750，代表每个分数。之后遍历整个省的所有人，统计每个分数的出现的次数，然后再遍历计数数组，即可实现有序。 1234567891011121314151617181920212223242526/** * @Title: countSort * @Description:计数排序,适用于数字的范围小，排序量大的数组 * @param arr 数组 * @param min 该数组中的最小值 * @param max 该数组中的最大值 * @return: int[] */public void countSort(int[] arr, int min, int max) &#123; // arr的最小值到最大值之间的数字，即为countArr的下标 int[] countArr = new int[max - min + 1]; // 统计arr中每个数字出现的次数 for (int j = 0; j &lt; arr.length; j++) countArr[arr[j] - min]++; int[] res = new int[arr.length]; // 将countArr变为累加数组,这一步主要是实现算法稳定 for (int m = 1; m &lt; countArr.length; m++) countArr[m] += countArr[m - 1]; // 这一步参见基数排序的过程示意图 for(int k = arr.length - 1; k &gt;= 0; k--) res[--countArr[arr[k] - min]] = arr[k]; // 将排序好的数组赋值给arr for(int i = 0; i &lt; arr.length; i++) &#123; arr[i] = res[i]; &#125;&#125; 6. 排序比较 排序 英文 平均 最坏 最好 空间 稳定性 插入排序 Insertion n2 n2 n 1 稳 折半插入 n2 n2 nlog2n 1 稳 希尔排序 Shell n1.3 n2 n 1 不稳 堆排序 Heap nlog2n nlog2n nlog2n 1 不稳 选择排序 Selection n2 n2 n2 1 不稳 冒泡排序 Bubble n2 n2 n 1 稳 快速排序 Quick nlog2n n2 nlog2n log2n 不稳 归并排序 Merge nlog2n nlog2n nlog2n n 稳 桶排序 Bucket n+k n2 n n+k 稳 计数排序 Counting n+k n+k n+k n+k 稳 基数排序 Radix n*k n*k n*k n+k 稳 经过一趟排序能够使某个关键字到达最终位置的排序：交换类排序（冒泡，快速排序）、选择类排序（简单选择，堆排序） 排序算法的关键字比较次数和原始序列无关：简单选择排序和折半插入排序 排序算法的排序趟数和原始序列有关：交换类排序（冒泡，快速排序）","categories":[{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"排序","slug":"排序","permalink":"blog.silverbeats.cn/tags/%E6%8E%92%E5%BA%8F/"}],"author":"silverbeats"},{"title":"hexo之yelee主题配置","slug":"hexo之yelee主题配置","date":"2020-09-13T11:53:59.000Z","updated":"2020-09-21T23:28:58.841Z","comments":true,"path":"hexo之yelee主题配置/","link":"","permalink":"blog.silverbeats.cn/hexo%E4%B9%8Byelee%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/","excerpt":"","text":"参考文章： 使用Github搭建Hexo技术博客托管在GitHub Pages上–安装教程 博客系统hexo yelee搭建历程 hexo在文章中添加图片 Hexo七牛插件安装与使用 hexo相关命令语法 1. 前期准备 github账号、安装git nodejs notepad++或者editplus，记事本也可以 typora（后期写md格式文章用的软件） 可选内容 修改node.js源 123456// 设置 淘宝镜像源npm config set registry https://registry.npm.taobao.org// 查看使用的镜像源npm config get registry// 安装淘宝镜像源npm install -g cnpm --registry=https://registry.npm.taobao.org 2. 实操 2.1 安装Hexo框架 123npm install -g hexo-cli// 或者cnpm install -g hexo-cli 2.2 创建Hexo项目 在本地，选择要创建项目的目录 打开Git Bash（或者cmd命令行，或者powershell），并进入该目录 输入并运行hexo init blog之后，会在当前目录下创建blog文件夹，并初始化相关文件 cd blog进入创建的项目，运行npm install下载相关依赖包 2.3 相关命令 12345678910111213#清理之前生成的旧文件hexo clean#重新生成静态文件 下面是简写hexo generatehexo g#本地预览 下面是简写hexo serverhexo s#合并写法hexo clean | hexo g | hexo s#通过git提交到仓库,需要配置,见后文hexo deployhexo d 2.4 下载yelee主题 在当前目录下，输入命令git clone https://github.com/MOxFIVE/hexo-theme-yelee themes/yelee，倘若下载速度是龟速，不如直接用迅雷下zip压缩包来的快…… Hexo主题压缩包，百度云，密码abcd 下载完成之后，需要修改项目目录下的_config.yml文件，找到theme主题字样，将后面的默认主题landscape修改为yelee。倘若之后想要更换主题也是如此。 2.5 修改_config.yml文件 2.5.1 首页不显示文章列表 启动后会发现左侧导航栏，点击主页后不显示文章列表 进入yelee模板页的 _config.yml 12345search: on: true onload: true ## true: get search.xml file when the page has loaded ## false: get the file when search box gets focus 2.5.2 相关链接无法跳转 在themes/yelee/_config.yml中类似如下的内容。实际上当预览的时候会发现有相关的链接没有配置路由。 12345678## About Page: `hexo new page about`## Tags Cloud Page: `hexo new page tags`menu: 主页: / 所有文章: /archives/ 随笔: /note/ 标签云: /tags/ 关于我: /about/ 因为随笔、标签云、关于我这种链接，在此项目中是没有的，需要去创建。留意上方注释，已经说明如何创建。 1234#在项目根目录下操作, 根据需要创建系统页hexo new page tagshexo new page abouthexo new page categories 2.5.3 添加文章的字数统计和大概看完的时间 12#项目根路径下操作npm i --save hexo-wordcount 文件配置： 在yelee/layout/_partial/post/word.ejs下创建word.ejs文件： 123456789101112131415161718&lt;!--倘若出现tag标签和统计字数的文件有布局上的问题，可以对上下外边距进行调整--&gt;&lt;div style&#x3D;&quot;margin-top:10px;margin-bottom: 30px&quot;&gt; &lt;span class&#x3D;&quot;post-time&quot;&gt; &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt; &lt;i class&#x3D;&quot;fa fa-keyboard-o&quot;&gt;&lt;&#x2F;i&gt; &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt; 字数统计: &lt;&#x2F;span&gt; &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; wordcount(post.content) %&gt;字&lt;&#x2F;span&gt; &lt;&#x2F;span&gt; &lt;&#x2F;span&gt; &lt;span class&#x3D;&quot;post-time&quot;&gt; &amp;nbsp; | &amp;nbsp; &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt; &lt;i class&#x3D;&quot;fa fa-hourglass-half&quot;&gt;&lt;&#x2F;i&gt; &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt; 阅读时长: &lt;&#x2F;span&gt; &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; min2read(post.content) %&gt;分&lt;&#x2F;span&gt; &lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;&#x2F;div&gt; 然后在 themes/yelee/layout/_partial/article.ejs中添加 12345678910111213&lt;div class&#x3D;&quot;article-inner&quot;&gt; &lt;% if (theme.fancybox)&#123; %&gt; &lt;input type&#x3D;&quot;hidden&quot; class&#x3D;&quot;isFancy&quot; &#x2F;&gt; &lt;% &#125; %&gt; &lt;% if (post.link || post.title)&#123; %&gt; &lt;header class&#x3D;&quot;article-header&quot;&gt; &lt;%- partial(&#39;post&#x2F;title&#39;, &#123;class_name: &#39;article-title&#39;&#125;) %&gt; &lt;!-- 开始添加字数统计,这里才是添加的东西--&gt; &lt;% if(theme.word_count &amp;&amp; !post.no_word_count)&#123;%&gt; &lt;%- partial(&#39;post&#x2F;word&#39;) %&gt; &lt;% &#125; %&gt; &lt;!-- 添加完成 --&gt; &lt;&#x2F;header&gt; 开启功能 在yelee主题的_config.yml中添加： 1word_count: true 2.5.4 配置本地搜索 12# 项目根目录运行npm install hexo-generator-search --save 然后配置文件themes/yelee/_config.yml中修改为： 12345search: on: true onload: true ## true: get search.xml file when the page has loaded ## false: get the file when search box gets focus 2.5.5 添加网站运行时间 \\themes\\yelee\\layout\\_partial路径下找到footer.ejs添加如下代码： 123456789101112131415161718192021222324252627&lt;footer id&#x3D;&quot;footer&quot;&gt; &lt;div class&#x3D;&quot;outer&quot;&gt; &lt;div id&#x3D;&quot;footer-info&quot;&gt; &lt;div class&#x3D;&quot;footer-left&quot;&gt; &lt;&#x2F;div&gt; &lt;!--添加代码的位置,以及要添加的代码 &lt;span id&#x3D;&quot;timeDate&quot;&gt;载入天数...&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;times&quot;&gt;载入时分秒...&lt;&#x2F;span&gt; &lt;script&gt; var now &#x3D; new Date(); function createtime() &#123; var grt &#x3D; new Date(&quot;09&#x2F;13&#x2F;2020 12:49:00&quot;);&#x2F;&#x2F;此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime() + 250); days &#x3D; (now - grt) &#x2F; 1000 &#x2F; 60 &#x2F; 60 &#x2F; 24; dnum &#x3D; Math.floor(days); hours &#x3D; (now - grt) &#x2F; 1000 &#x2F; 60 &#x2F; 60 - (24 * dnum); hnum &#x3D; Math.floor(hours); if (String(hnum).length &#x3D;&#x3D; 1) &#123; hnum &#x3D; &quot;0&quot; + hnum; &#125; minutes &#x3D; (now - grt) &#x2F; 1000 &#x2F; 60 - (24 * 60 * dnum) - (60 * hnum); mnum &#x3D; Math.floor(minutes); if (String(mnum).length &#x3D;&#x3D; 1) &#123; mnum &#x3D; &quot;0&quot; + mnum; &#125; seconds &#x3D; (now - grt) &#x2F; 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum &#x3D; Math.round(seconds); if (String(snum).length &#x3D;&#x3D; 1) &#123; snum &#x3D; &quot;0&quot; + snum; &#125; document.getElementById(&quot;timeDate&quot;).innerHTML &#x3D; &quot;本站已安全运行 &quot; + dnum + &quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML &#x3D; hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; &#125; setInterval(&quot;createtime()&quot;, 250); &lt;&#x2F;script&gt; --&gt; &lt;div class&#x3D;&quot;footer-right&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; ……&lt;&#x2F;footer&gt; 2.5.6 Url持久化 可以发现 hexo 默认生成的文章地址路径是 【网站名称／年／月／日／文章名称】。 这种链接对搜索爬虫是很不友好的，它的 url 结构超过了三层，太深了。 安装 hexo-abbrlink 插件： 1npm install hexo-abbrlink --save 然后配置根目录的_config.yml 12permalink: :title/#permalink: :year/:month/:day/:title/ 2.5.7 添加二次元虚拟人物 获取： 1npm install --save hexo-helper-live2d 下载人物模型，官方： 12345npm install live2d-widget-model-shizuku # 对应use: live2d-widget-model-unitychannpm install live2d-widget-model-hibiki# 对应use: live2d-widget-model-hibiki 配置： 123456789101112live2d: enable: true scriptFrom: local model: #只需要修改unitychan就可以更换虚拟人物 use: live2d-widget-model-unitychan display: position: right width: 150 height: 300 mobile: show: true 2.5.8 当文章中有图片时 图片在博文中十分常见，因博客部署在GitHub上，空间有限，推荐将图片、音频、视频等文件存放在七牛云这样的地方。 2.5.8.1 使用七牛云同步插件 注册账号登录，点击对象存储，创建存储空间，并绑定域名，绑定域名参考官网提供的说明 hexo安装七牛云同步插件：npm install hexo-qiniu-sync --save hexo的配置文件中进行七牛云配置 12345678910111213141516171819202122232425262728#plugins:# - hexo-qiniu-syncqiniu: offline: true # 离线,true会省流量 sync: true bucket: #这里需要填写第一步创建的存储空间的名字 # 这里将其注释掉，不注释，执行hexo g报错 # secret_file: sec/qn.json or C: #登录自己的七牛云账号，点击右上角的投降，选择密钥管理，可以获得 access_key: your access_key secret_key: your secret_key // 上传的资源子目录前缀.如设置，需与urlPrefix同步 dirPrefix: static //外链前缀，第一步绑定的加速域名 urlPrefix: http://自己的加速域名/static //使用默认配置即可 up_host: http://upload.qiniu.com //本地目录 local_dir: static // 是否更新已经上传过的文件(仅文件大小不同或在上次上传后进行更新的才会重新上传) update_exist: true image: folder: images extend: js: folder: js css: folder: css 在hexo根目录下创建如下目录结构，之后将对应的想要存放到七牛云的文件放到对应的文件夹即可 1234static - images - js - css 在文章中插入图片 1&#123;% qnimg 图片.图片格式 title: alt: &#39;class:&#39; extend:?imageView2&#x2F;2&#x2F;w&#x2F;450 %&#125; 将本地static目录下的文件同步到七牛云 1234567hexo qiniu sync#或者hexo qiniu s#或者hexo qiniu sync2#或者hexo qiniu s2 2.5.8.2 使用picGo工具 同步插件在使用过程中发现，在文章使用过程中看不到预览，并且在生成过程中还是会把图片放到public目录，所以会推荐使用picGo，提取码cdef工具来上传，成功后会返回外链地址，方便使用。 2.5.9 文章底部不显示作者 倘若出现了这种情况，可以在主题的配置文件中添加： 1author: 作者名字 2.5.10 添加点击爱心效果 下载js文件，链接地址,密码bcde 在theme/yelee/source下创建resources目录并将js文件拷贝到此目录下 在/themes/yelee/layout/_partial/after-footer.ejs下添加代码 1234&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;resources&#x2F;float.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;resources&#x2F;love.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; color&#x3D;0,104,183 opacity&#x3D;1 zindex&#x3D;-1 count&#x3D;50 src&#x3D;&quot;&#x2F;resources&#x2F;particle.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;resources&#x2F;typewriter.js&quot;&gt;&lt;&#x2F;script&gt; 2.5.11 其它 主题文件的_config.yml还可以配置什么： 网站的ico图标 自己的头像 导航栏链接 背景图片 是否开启分享 是否需要评论、以及是否显示评论数量 文章的标题风格、字体大小 …… 3. 把本地的博客内容同步到 Github 上 因为博客托管在GitHub上，所以在建立博客仓库时，仓库的名字需要命名为：用户名.github.io这样就可以通过用户名.github.io来访问该站点了。 创建好仓库后，需要本地生成SSH秘钥，方便通过git来进行提交 命令行输入：ssh-keygen -t rsa -C &quot;你的邮箱地址&quot;,之后不停的回车，期间，留意秘钥保存的路径，一般是：C:\\Users\\你的计算机用户名\\.ssh，会生成两个文件： 私钥：id_rsa 公钥：id_rsa.pub 访问自己GitHub账户的setting/SSH keys，将公钥的内容复制粘贴到Key的位置（主义末尾不要留有空行），title内容随意。 安装两个跟部署相关的 hexo 插件 12npm install hexo -server --savenpm install hexo-deployer-git --save 编辑全局的hexo配置文件：_config.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 这一块区域主要是设置博客的主要说明，需要注意的是：每个冒号后面都是有一个空格，然后再书写自己的内容的stitle: LearnFoever #网站标题subtitle: #网站副标题description: #描述author: silverbeatsemail: 418116014@qq.comlanguage: zh-CNtimezone: #网站时区。Hexo 默认使用您电脑的时区# URL 这一块一般可以设置的是 url 这个参数，比如我要设置绑定域名的，这里就需要填写我的域名信息## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;url: http://silverbeats.github.io #倘若已经购买了域名的话可以填买的域名root: /#这里配置的url持久化permalink: :title/ #:year/:month/:day/:title/ permalink_defaults:# Directorysource_dir: source #源文件夹，这个文件夹用来存放内容。public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #nclude code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，可使用 glob 表达式来匹配路径# Writingnew_post_name: :title.md #新建文章默认文件名default_layout: post # 默认布局titlecase: false # Transform title into titlecaseexternal_link: true # 在新标签中打开一个外部链接，默认为truefilename_case: 0 render_drafts: false #是否渲染_drafts目录下的文章，默认为falsepost_asset_folder: true #启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址，默认falsefuture: true #显示未来的文章，默认falsehighlight: #代码块的设置 enable: true line_number: true auto_detect: false tab_replace: &#x27;&#x27; wrap: true hljs: falseprismjs: enable: false preprocess: true line_number: true tab_replace: &#x27;&#x27;# Home page setting# path: Root path for your blogs index page. (default = &#x27;&#x27;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &#x27;&#x27; per_page: 10 order_by: -date# Category &amp; Tag #分类和标签的设置default_category: uncategorized #默认分类category_map:tag_map:# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;updated_option: &#x27;mtime&#x27;# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Include / Exclude file(s)## include:/exclude: options only apply to the &#x27;source/&#x27; folderinclude:exclude:ignore:# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yelee # next yeleesearch: path: search.xml field: all# Deployment## 这里是重点，这里是修改发布地址，因为我们前面已经加了 SSH 密钥信息在 Github 设置里面了，所以只要我们电脑里面持有那两个密钥文件就可以无需密码地跟 Github 做同步。## 需要注意的是这里的 repo 采用的是 ssh 的地址，而不是 https 的。分支我们默认采用 master 分支，以后熟悉了要换其他也无所谓。## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:SilverBeats/SilverBeats.github.io.git,master# hexo-neat 对静态文件进行压缩neat_enable: trueneat_html: enable: true exclude: neat_css: enable: true exclude: - &#x27;*.min.css&#x27;neat_js: enable: true mangle: true output: compress: exclude: - &#x27;*.min.js&#x27;#萌妹子live2d: enable: true scriptFrom: local model: use: live2d-widget-model-hibiki display: position: right width: 150 height: 300 mobile: show: true","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"blog.silverbeats.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"blog.silverbeats.cn/tags/hexo/"},{"name":"git","slug":"git","permalink":"blog.silverbeats.cn/tags/git/"},{"name":"github","slug":"github","permalink":"blog.silverbeats.cn/tags/github/"},{"name":"nodejs","slug":"nodejs","permalink":"blog.silverbeats.cn/tags/nodejs/"}],"author":"silverbeats"}],"categories":[{"name":"java","slug":"java","permalink":"blog.silverbeats.cn/categories/java/"},{"name":"Mybatis","slug":"java/Mybatis","permalink":"blog.silverbeats.cn/categories/java/Mybatis/"},{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"算法设计与分析","slug":"算法/算法设计与分析","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"blog.silverbeats.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"博客搭建","slug":"博客搭建","permalink":"blog.silverbeats.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"blog.silverbeats.cn/tags/Mybatis/"},{"name":"算法","slug":"算法","permalink":"blog.silverbeats.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"blog.silverbeats.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"串","slug":"串","permalink":"blog.silverbeats.cn/tags/%E4%B8%B2/"},{"name":"KMP","slug":"KMP","permalink":"blog.silverbeats.cn/tags/KMP/"},{"name":"分治法","slug":"分治法","permalink":"blog.silverbeats.cn/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"},{"name":"最短路径","slug":"最短路径","permalink":"blog.silverbeats.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"blog.silverbeats.cn/tags/Dijkstra/"},{"name":"Floyd","slug":"Floyd","permalink":"blog.silverbeats.cn/tags/Floyd/"},{"name":"hexo","slug":"hexo","permalink":"blog.silverbeats.cn/tags/hexo/"},{"name":"排序","slug":"排序","permalink":"blog.silverbeats.cn/tags/%E6%8E%92%E5%BA%8F/"},{"name":"git","slug":"git","permalink":"blog.silverbeats.cn/tags/git/"},{"name":"github","slug":"github","permalink":"blog.silverbeats.cn/tags/github/"},{"name":"nodejs","slug":"nodejs","permalink":"blog.silverbeats.cn/tags/nodejs/"}]}